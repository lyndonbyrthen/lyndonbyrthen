webpackJsonp([0],{

/***/ 414:
/*!************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./src/client/app/subapps/App3.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ 2);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _matter = __webpack_require__(/*! ../libs/matter.min */ 415);\n\nvar _matter2 = _interopRequireDefault(_matter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar App3 = function (_React$Component) {\n    _inherits(App3, _React$Component);\n\n    function App3(props) {\n        _classCallCheck(this, App3);\n\n        var _this = _possibleConstructorReturn(this, (App3.__proto__ || Object.getPrototypeOf(App3)).call(this, props));\n\n        _this.engine = _this.engine.bind(_this);\n\n        return _this;\n    }\n\n    _createClass(App3, [{\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            // console.log(this.props.menuItem.name,nextProps)\n            if (this.props.isCurApp && !nextProps.isCurApp) {\n                //console.log('will stop');\n                this.en.pause();\n            } else if (!this.props.isCurApp && nextProps.isCurApp) {\n                //console.log('will start');\n                this.en.resume();\n            }\n        }\n    }, {\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            if (this.en) return;\n            try {\n                this.en = this.engine();\n            } catch (e) {\n                console.log(e, 'ph error');\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {}\n    }, {\n        key: 'engine',\n        value: function engine() {\n            var Engine = _matter2.default.Engine,\n                Render = _matter2.default.Render,\n                Runner = _matter2.default.Runner,\n                Composites = _matter2.default.Composites,\n                MouseConstraint = _matter2.default.MouseConstraint,\n                Mouse = _matter2.default.Mouse,\n                World = _matter2.default.World,\n                Constraint = _matter2.default.Constraint,\n                Bodies = _matter2.default.Bodies;\n\n            // create engine\n            var engine = Engine.create(),\n                world = engine.world;\n\n            // create renderer\n            var render = Render.create({\n                element: this.refs.canvas,\n                engine: engine,\n                options: {\n                    width: 800,\n                    height: 600,\n                    showAngleIndicator: true\n                }\n            });\n\n            Render.run(render);\n\n            // create runner\n            var runner = Runner.create();\n            Runner.run(runner, engine);\n\n            // add bodies\n            var rows = 10,\n                yy = 600 - 21 - 40 * rows;\n\n            var stack = Composites.stack(400, yy, 5, rows, 0, 0, function (x, y) {\n                return Bodies.rectangle(x, y, 40, 40);\n            });\n\n            World.add(world, [stack,\n            // walls\n            Bodies.rectangle(400, 0, 800, 50, { isStatic: true }), Bodies.rectangle(400, 600, 800, 50, { isStatic: true }), Bodies.rectangle(800, 300, 50, 600, { isStatic: true }), Bodies.rectangle(0, 300, 50, 600, { isStatic: true })]);\n\n            var ball = Bodies.circle(100, 400, 50, { density: 0.04, frictionAir: 0.005 });\n\n            World.add(world, ball);\n            World.add(world, Constraint.create({\n                pointA: { x: 300, y: 100 },\n                bodyB: ball\n            }));\n\n            // add mouse control\n            var mouse = Mouse.create(render.canvas),\n                mouseConstraint = MouseConstraint.create(engine, {\n                mouse: mouse,\n                constraint: {\n                    stiffness: 0.2,\n                    render: {\n                        visible: false\n                    }\n                }\n            });\n\n            World.add(world, mouseConstraint);\n\n            // keep the mouse in sync with rendering\n            render.mouse = mouse;\n\n            // fit the render viewport to the scene\n            /*Render.lookAt(render, {\r\n                min: { x: 0, y: 0 },\r\n                max: { x: 800, y: 600 }\r\n            });*/\n\n            // context for MatterTools.Demo\n            return {\n                engine: engine,\n                runner: runner,\n                render: render,\n                canvas: render.canvas,\n                pause: function pause() {\n                    Runner.stop(runner);\n                },\n                resume: function resume() {\n                    Runner.start(runner, engine);\n                }\n            };\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n\n            return _react2.default.createElement('div', { ref: 'canvas' });\n        }\n    }]);\n\n    return App3;\n}(_react2.default.Component);\n\nexports.default = App3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jbGllbnQvYXBwL3N1YmFwcHMvQXBwMy5qcz9jNGQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xyXG5pbXBvcnQgTWF0dGVyIGZyb20gJy4uL2xpYnMvbWF0dGVyLm1pbidcclxuXHJcbmNsYXNzIEFwcDMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIFxyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLmVuZ2luZSA9IHRoaXMuZW5naW5lLmJpbmQodGhpcyk7XHJcblxyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucHJvcHMubWVudUl0ZW0ubmFtZSxuZXh0UHJvcHMpXHJcbiAgICBpZiAodGhpcy5wcm9wcy5pc0N1ckFwcCAmJiAhbmV4dFByb3BzLmlzQ3VyQXBwKSB7XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ3dpbGwgc3RvcCcpO1xyXG4gICAgICB0aGlzLmVuLnBhdXNlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghdGhpcy5wcm9wcy5pc0N1ckFwcCAmJiBuZXh0UHJvcHMuaXNDdXJBcHApIHtcclxuICAgICAgLy9jb25zb2xlLmxvZygnd2lsbCBzdGFydCcpO1xyXG4gICAgICB0aGlzLmVuLnJlc3VtZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgaWYgKHRoaXMuZW4pIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZW4gPSB0aGlzLmVuZ2luZSgpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhlLCdwaCBlcnJvcicpXHJcbiAgICB9XHJcbiAgICBcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gIH1cclxuXHJcbiAgZW5naW5lKCkge1xyXG4gICAgdmFyIEVuZ2luZSA9IE1hdHRlci5FbmdpbmUsXHJcbiAgICAgICAgUmVuZGVyID0gTWF0dGVyLlJlbmRlcixcclxuICAgICAgICBSdW5uZXIgPSBNYXR0ZXIuUnVubmVyLFxyXG4gICAgICAgIENvbXBvc2l0ZXMgPSBNYXR0ZXIuQ29tcG9zaXRlcyxcclxuICAgICAgICBNb3VzZUNvbnN0cmFpbnQgPSBNYXR0ZXIuTW91c2VDb25zdHJhaW50LFxyXG4gICAgICAgIE1vdXNlID0gTWF0dGVyLk1vdXNlLFxyXG4gICAgICAgIFdvcmxkID0gTWF0dGVyLldvcmxkLFxyXG4gICAgICAgIENvbnN0cmFpbnQgPSBNYXR0ZXIuQ29uc3RyYWludCxcclxuICAgICAgICBCb2RpZXMgPSBNYXR0ZXIuQm9kaWVzO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBlbmdpbmVcclxuICAgIHZhciBlbmdpbmUgPSBFbmdpbmUuY3JlYXRlKCksXHJcbiAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQ7XHJcblxyXG4gICAgLy8gY3JlYXRlIHJlbmRlcmVyXHJcbiAgICB2YXIgcmVuZGVyID0gUmVuZGVyLmNyZWF0ZSh7XHJcbiAgICAgICAgZWxlbWVudDogdGhpcy5yZWZzLmNhbnZhcyxcclxuICAgICAgICBlbmdpbmU6IGVuZ2luZSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiA4MDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogNjAwLFxyXG4gICAgICAgICAgICBzaG93QW5nbGVJbmRpY2F0b3I6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBSZW5kZXIucnVuKHJlbmRlcik7XHJcblxyXG4gICAgLy8gY3JlYXRlIHJ1bm5lclxyXG4gICAgdmFyIHJ1bm5lciA9IFJ1bm5lci5jcmVhdGUoKTtcclxuICAgIFJ1bm5lci5ydW4ocnVubmVyLCBlbmdpbmUpO1xyXG5cclxuICAgIC8vIGFkZCBib2RpZXNcclxuICAgIHZhciByb3dzID0gMTAsXHJcbiAgICAgICAgeXkgPSA2MDAgLSAyMSAtIDQwICogcm93cztcclxuICAgIFxyXG4gICAgdmFyIHN0YWNrID0gQ29tcG9zaXRlcy5zdGFjayg0MDAsIHl5LCA1LCByb3dzLCAwLCAwLCBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIEJvZGllcy5yZWN0YW5nbGUoeCwgeSwgNDAsIDQwKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBXb3JsZC5hZGQod29ybGQsIFtcclxuICAgICAgICBzdGFjayxcclxuICAgICAgICAvLyB3YWxsc1xyXG4gICAgICAgIEJvZGllcy5yZWN0YW5nbGUoNDAwLCAwLCA4MDAsIDUwLCB7IGlzU3RhdGljOiB0cnVlIH0pLFxyXG4gICAgICAgIEJvZGllcy5yZWN0YW5nbGUoNDAwLCA2MDAsIDgwMCwgNTAsIHsgaXNTdGF0aWM6IHRydWUgfSksXHJcbiAgICAgICAgQm9kaWVzLnJlY3RhbmdsZSg4MDAsIDMwMCwgNTAsIDYwMCwgeyBpc1N0YXRpYzogdHJ1ZSB9KSxcclxuICAgICAgICBCb2RpZXMucmVjdGFuZ2xlKDAsIDMwMCwgNTAsIDYwMCwgeyBpc1N0YXRpYzogdHJ1ZSB9KVxyXG4gICAgXSk7XHJcbiAgICBcclxuICAgIHZhciBiYWxsID0gQm9kaWVzLmNpcmNsZSgxMDAsIDQwMCwgNTAsIHsgZGVuc2l0eTogMC4wNCwgZnJpY3Rpb25BaXI6IDAuMDA1fSk7XHJcbiAgICBcclxuICAgIFdvcmxkLmFkZCh3b3JsZCwgYmFsbCk7XHJcbiAgICBXb3JsZC5hZGQod29ybGQsIENvbnN0cmFpbnQuY3JlYXRlKHtcclxuICAgICAgICBwb2ludEE6IHsgeDogMzAwLCB5OiAxMDAgfSxcclxuICAgICAgICBib2R5QjogYmFsbFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIGFkZCBtb3VzZSBjb250cm9sXHJcbiAgICB2YXIgbW91c2UgPSBNb3VzZS5jcmVhdGUocmVuZGVyLmNhbnZhcyksXHJcbiAgICAgICAgbW91c2VDb25zdHJhaW50ID0gTW91c2VDb25zdHJhaW50LmNyZWF0ZShlbmdpbmUsIHtcclxuICAgICAgICAgICAgbW91c2U6IG1vdXNlLFxyXG4gICAgICAgICAgICBjb25zdHJhaW50OiB7XHJcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3M6IDAuMixcclxuICAgICAgICAgICAgICAgIHJlbmRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICBXb3JsZC5hZGQod29ybGQsIG1vdXNlQ29uc3RyYWludCk7XHJcblxyXG4gICAgLy8ga2VlcCB0aGUgbW91c2UgaW4gc3luYyB3aXRoIHJlbmRlcmluZ1xyXG4gICAgcmVuZGVyLm1vdXNlID0gbW91c2U7XHJcblxyXG4gICAgLy8gZml0IHRoZSByZW5kZXIgdmlld3BvcnQgdG8gdGhlIHNjZW5lXHJcbiAgICAvKlJlbmRlci5sb29rQXQocmVuZGVyLCB7XHJcbiAgICAgICAgbWluOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICBtYXg6IHsgeDogODAwLCB5OiA2MDAgfVxyXG4gICAgfSk7Ki9cclxuXHJcbiAgICAvLyBjb250ZXh0IGZvciBNYXR0ZXJUb29scy5EZW1vXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVuZ2luZTogZW5naW5lLFxyXG4gICAgICAgIHJ1bm5lcjogcnVubmVyLFxyXG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxyXG4gICAgICAgIGNhbnZhczogcmVuZGVyLmNhbnZhcyxcclxuICAgICAgICBwYXVzZTogKCkgPT4ge1xyXG4gICAgICAgICAgICBSdW5uZXIuc3RvcChydW5uZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXN1bWU6ICgpID0+IHtcclxuICAgICAgICAgICAgUnVubmVyLnN0YXJ0KHJ1bm5lcixlbmdpbmUpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuXHJcbiAgXHRyZXR1cm4gKFxyXG4gIFx0XHQ8ZGl2IHJlZj0nY2FudmFzJz5cclxuICBcdFx0PC9kaXY+XHJcbiAgXHQpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBcHAzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2xpZW50L2FwcC9zdWJhcHBzL0FwcDMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUZBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBOzs7QUFFQTtBQUNBO0FBQ0E7QUFJQTs7OztBQXZJQTtBQUNBO0FBeUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n");

/***/ }),

/***/ 415:
/*!*******************************************!*\
  !*** ./src/client/app/libs/matter.min.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* matter-js 0.13.0 by @liabru 2017-07-06\n* http://brm.io/matter-js/\n* License MIT\n*/\n!function (e) {\n  if (\"object\" == ( false ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {\n    var t;t = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, t.Matter = e();\n  }\n}(function () {\n  return function e(t, n, o) {\n    function i(s, a) {\n      if (!n[s]) {\n        if (!t[s]) {\n          var l = \"function\" == typeof require && require;if (!a && l) return require(s, !0);if (r) return r(s, !0);var c = new Error(\"Cannot find module '\" + s + \"'\");throw c.code = \"MODULE_NOT_FOUND\", c;\n        }var d = n[s] = { exports: {} };t[s][0].call(d.exports, function (e) {\n          var n = t[s][1][e];return i(n ? n : e);\n        }, d, d.exports, e, t, n, o);\n      }return n[s].exports;\n    }for (var r = \"function\" == typeof require && require, s = 0; s < o.length; s++) {\n      i(o[s]);\n    }return i;\n  }({ 1: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Sleeping\"),\n          a = (e(\"../render/Render\"), e(\"../core/Common\")),\n          l = e(\"../geometry/Bounds\"),\n          c = e(\"../geometry/Axes\");!function () {\n        o._inertiaScale = 4, o._nextCollidingGroupId = 1, o._nextNonCollidingGroupId = -1, o._nextCategory = 1, o.create = function (t) {\n          var n = { id: a.nextId(), type: \"body\", label: \"Body\", parts: [], plugin: {}, angle: 0, vertices: i.fromPath(\"L 0 0 L 40 0 L 40 40 L 0 40\"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 }, lineWidth: 0 } },\n              o = a.extend(n, t);return e(o, t), o;\n        }, o.nextGroup = function (e) {\n          return e ? o._nextNonCollidingGroupId-- : o._nextCollidingGroupId++;\n        }, o.nextCategory = function () {\n          return o._nextCategory = o._nextCategory << 1, o._nextCategory;\n        };var e = function e(_e, t) {\n          t = t || {}, o.set(_e, { bounds: _e.bounds || l.create(_e.vertices), positionPrev: _e.positionPrev || r.clone(_e.position),\n            anglePrev: _e.anglePrev || _e.angle, vertices: _e.vertices, parts: _e.parts || [_e], isStatic: _e.isStatic, isSleeping: _e.isSleeping, parent: _e.parent || _e }), i.rotate(_e.vertices, _e.angle, _e.position), c.rotate(_e.axes, _e.angle), l.update(_e.bounds, _e.vertices, _e.velocity), o.set(_e, { axes: t.axes || _e.axes, area: t.area || _e.area, mass: t.mass || _e.mass, inertia: t.inertia || _e.inertia });var n = _e.isStatic ? \"#2e2b44\" : a.choose([\"#006BA6\", \"#0496FF\", \"#FFBC42\", \"#D81159\", \"#8F2D56\"]),\n              s = \"#000\";_e.render.fillStyle = _e.render.fillStyle || n, _e.render.strokeStyle = _e.render.strokeStyle || s, _e.render.sprite.xOffset += -(_e.bounds.min.x - _e.position.x) / (_e.bounds.max.x - _e.bounds.min.x), _e.render.sprite.yOffset += -(_e.bounds.min.y - _e.position.y) / (_e.bounds.max.y - _e.bounds.min.y);\n        };o.set = function (e, t, n) {\n          var i;\"string\" == typeof t && (i = t, t = {}, t[i] = n);for (i in t) {\n            if (n = t[i], t.hasOwnProperty(i)) switch (i) {case \"isStatic\":\n                o.setStatic(e, n);break;case \"isSleeping\":\n                s.set(e, n);break;case \"mass\":\n                o.setMass(e, n);break;case \"density\":\n                o.setDensity(e, n);break;case \"inertia\":\n                o.setInertia(e, n);break;case \"vertices\":\n                o.setVertices(e, n);break;case \"position\":\n                o.setPosition(e, n);break;case \"angle\":\n                o.setAngle(e, n);break;case \"velocity\":\n                o.setVelocity(e, n);break;case \"angularVelocity\":\n                o.setAngularVelocity(e, n);break;case \"parts\":\n                o.setParts(e, n);break;default:\n                e[i] = n;}\n          }\n        }, o.setStatic = function (e, t) {\n          for (var n = 0; n < e.parts.length; n++) {\n            var o = e.parts[n];o.isStatic = t, t ? (o._original = { restitution: o.restitution, friction: o.friction, mass: o.mass, inertia: o.inertia, density: o.density, inverseMass: o.inverseMass, inverseInertia: o.inverseInertia }, o.restitution = 0, o.friction = 1, o.mass = o.inertia = o.density = 1 / 0, o.inverseMass = o.inverseInertia = 0, o.positionPrev.x = o.position.x, o.positionPrev.y = o.position.y, o.anglePrev = o.angle, o.angularVelocity = 0, o.speed = 0, o.angularSpeed = 0, o.motion = 0) : o._original && (o.restitution = o._original.restitution, o.friction = o._original.friction, o.mass = o._original.mass, o.inertia = o._original.inertia, o.density = o._original.density, o.inverseMass = o._original.inverseMass, o.inverseInertia = o._original.inverseInertia, delete o._original);\n          }\n        }, o.setMass = function (e, t) {\n          e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area;\n        }, o.setDensity = function (e, t) {\n          o.setMass(e, t * e.area), e.density = t;\n        }, o.setInertia = function (e, t) {\n          e.inertia = t, e.inverseInertia = 1 / e.inertia;\n        }, o.setVertices = function (e, t) {\n          t[0].body === e ? e.vertices = t : e.vertices = i.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = i.area(e.vertices), o.setMass(e, e.density * e.area);var n = i.centre(e.vertices);i.translate(e.vertices, n, -1), o.setInertia(e, o._inertiaScale * i.inertia(e.vertices, e.mass)), i.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity);\n        }, o.setParts = function (e, n, r) {\n          var s;for (n = n.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, s = 0; s < n.length; s++) {\n            var a = n[s];a !== e && (a.parent = e, e.parts.push(a));\n          }if (1 !== e.parts.length) {\n            if (r = \"undefined\" == typeof r || r) {\n              var l = [];for (s = 0; s < n.length; s++) {\n                l = l.concat(n[s].vertices);\n              }i.clockwiseSort(l);var c = i.hull(l),\n                  d = i.centre(c);o.setVertices(e, c), i.translate(e.vertices, d);\n            }var u = t(e);e.area = u.area, e.parent = e, e.position.x = u.centre.x, e.position.y = u.centre.y, e.positionPrev.x = u.centre.x, e.positionPrev.y = u.centre.y, o.setMass(e, u.mass), o.setInertia(e, u.inertia), o.setPosition(e, u.centre);\n          }\n        }, o.setPosition = function (e, t) {\n          var n = r.sub(t, e.position);e.positionPrev.x += n.x, e.positionPrev.y += n.y;for (var o = 0; o < e.parts.length; o++) {\n            var s = e.parts[o];s.position.x += n.x, s.position.y += n.y, i.translate(s.vertices, n), l.update(s.bounds, s.vertices, e.velocity);\n          }\n        }, o.setAngle = function (e, t) {\n          var n = t - e.angle;e.anglePrev += n;for (var o = 0; o < e.parts.length; o++) {\n            var s = e.parts[o];s.angle += n, i.rotate(s.vertices, n, e.position), c.rotate(s.axes, n), l.update(s.bounds, s.vertices, e.velocity), o > 0 && r.rotateAbout(s.position, n, e.position, s.position);\n          }\n        }, o.setVelocity = function (e, t) {\n          e.positionPrev.x = e.position.x - t.x, e.positionPrev.y = e.position.y - t.y, e.velocity.x = t.x, e.velocity.y = t.y, e.speed = r.magnitude(e.velocity);\n        }, o.setAngularVelocity = function (e, t) {\n          e.anglePrev = e.angle - t, e.angularVelocity = t, e.angularSpeed = Math.abs(e.angularVelocity);\n        }, o.translate = function (e, t) {\n          o.setPosition(e, r.add(e.position, t));\n        }, o.rotate = function (e, t, n) {\n          if (n) {\n            var i = Math.cos(t),\n                r = Math.sin(t),\n                s = e.position.x - n.x,\n                a = e.position.y - n.y;o.setPosition(e, { x: n.x + (s * i - a * r), y: n.y + (s * r + a * i) }), o.setAngle(e, e.angle + t);\n          } else o.setAngle(e, e.angle + t);\n        }, o.scale = function (e, n, r, s) {\n          for (var a = 0; a < e.parts.length; a++) {\n            var d = e.parts[a];i.scale(d.vertices, n, r, e.position), d.axes = c.fromVertices(d.vertices), e.isStatic || (d.area = i.area(d.vertices), o.setMass(d, e.density * d.area), i.translate(d.vertices, { x: -d.position.x, y: -d.position.y }), o.setInertia(d, i.inertia(d.vertices, d.mass)), i.translate(d.vertices, { x: d.position.x, y: d.position.y })), l.update(d.bounds, d.vertices, e.velocity);\n          }if (e.circleRadius && (n === r ? e.circleRadius *= n : e.circleRadius = null), !e.isStatic) {\n            var u = t(e);e.area = u.area, o.setMass(e, u.mass), o.setInertia(e, u.inertia);\n          }\n        }, o.update = function (e, t, n, o) {\n          var s = Math.pow(t * n * e.timeScale, 2),\n              a = 1 - e.frictionAir * n * e.timeScale,\n              d = e.position.x - e.positionPrev.x,\n              u = e.position.y - e.positionPrev.y;e.velocity.x = d * a * o + e.force.x / e.mass * s, e.velocity.y = u * a * o + e.force.y / e.mass * s, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.angularVelocity = (e.angle - e.anglePrev) * a * o + e.torque / e.inertia * s, e.anglePrev = e.angle, e.angle += e.angularVelocity, e.speed = r.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity);for (var p = 0; p < e.parts.length; p++) {\n            var f = e.parts[p];i.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (i.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && r.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity);\n          }\n        }, o.applyForce = function (e, t, n) {\n          e.force.x += n.x, e.force.y += n.y;var o = { x: t.x - e.position.x, y: t.y - e.position.y };e.torque += o.x * n.y - o.y * n.x;\n        };var t = function t(e) {\n          for (var t = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, n = 1 === e.parts.length ? 0 : 1; n < e.parts.length; n++) {\n            var o = e.parts[n];t.mass += o.mass, t.area += o.area, t.inertia += o.inertia, t.centre = r.add(t.centre, r.mult(o.position, o.mass !== 1 / 0 ? o.mass : 1));\n          }return t.centre = r.div(t.centre, t.mass !== 1 / 0 ? t.mass : e.parts.length), t;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Sleeping\": 22, \"../geometry/Axes\": 25, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29, \"../render/Render\": 31 }], 2: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../core/Events\"),\n          r = e(\"../core/Common\"),\n          s = e(\"./Body\");!function () {\n        o.create = function (e) {\n          return r.extend({ id: r.nextId(), type: \"composite\", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: \"Composite\", plugin: {} }, e);\n        }, o.setModified = function (e, t, n, i) {\n          if (e.isModified = t, n && e.parent && o.setModified(e.parent, t, n, i), i) for (var r = 0; r < e.composites.length; r++) {\n            var s = e.composites[r];o.setModified(s, t, n, i);\n          }\n        }, o.add = function (e, t) {\n          var n = [].concat(t);i.trigger(e, \"beforeAdd\", { object: t });for (var s = 0; s < n.length; s++) {\n            var a = n[s];switch (a.type) {case \"body\":\n                if (a.parent !== a) {\n                  r.warn(\"Composite.add: skipped adding a compound body part (you must add its parent instead)\");break;\n                }o.addBody(e, a);break;case \"constraint\":\n                o.addConstraint(e, a);\n                break;case \"composite\":\n                o.addComposite(e, a);break;case \"mouseConstraint\":\n                o.addConstraint(e, a.constraint);}\n          }return i.trigger(e, \"afterAdd\", { object: t }), e;\n        }, o.remove = function (e, t, n) {\n          var r = [].concat(t);i.trigger(e, \"beforeRemove\", { object: t });for (var s = 0; s < r.length; s++) {\n            var a = r[s];switch (a.type) {case \"body\":\n                o.removeBody(e, a, n);break;case \"constraint\":\n                o.removeConstraint(e, a, n);break;case \"composite\":\n                o.removeComposite(e, a, n);break;case \"mouseConstraint\":\n                o.removeConstraint(e, a.constraint);}\n          }return i.trigger(e, \"afterRemove\", { object: t }), e;\n        }, o.addComposite = function (e, t) {\n          return e.composites.push(t), t.parent = e, o.setModified(e, !0, !0, !1), e;\n        }, o.removeComposite = function (e, t, n) {\n          var i = r.indexOf(e.composites, t);if (i !== -1 && (o.removeCompositeAt(e, i), o.setModified(e, !0, !0, !1)), n) for (var s = 0; s < e.composites.length; s++) {\n            o.removeComposite(e.composites[s], t, !0);\n          }return e;\n        }, o.removeCompositeAt = function (e, t) {\n          return e.composites.splice(t, 1), o.setModified(e, !0, !0, !1), e;\n        }, o.addBody = function (e, t) {\n          return e.bodies.push(t), o.setModified(e, !0, !0, !1), e;\n        }, o.removeBody = function (e, t, n) {\n          var i = r.indexOf(e.bodies, t);if (i !== -1 && (o.removeBodyAt(e, i), o.setModified(e, !0, !0, !1)), n) for (var s = 0; s < e.composites.length; s++) {\n            o.removeBody(e.composites[s], t, !0);\n          }return e;\n        }, o.removeBodyAt = function (e, t) {\n          return e.bodies.splice(t, 1), o.setModified(e, !0, !0, !1), e;\n        }, o.addConstraint = function (e, t) {\n          return e.constraints.push(t), o.setModified(e, !0, !0, !1), e;\n        }, o.removeConstraint = function (e, t, n) {\n          var i = r.indexOf(e.constraints, t);if (i !== -1 && o.removeConstraintAt(e, i), n) for (var s = 0; s < e.composites.length; s++) {\n            o.removeConstraint(e.composites[s], t, !0);\n          }return e;\n        }, o.removeConstraintAt = function (e, t) {\n          return e.constraints.splice(t, 1), o.setModified(e, !0, !0, !1), e;\n        }, o.clear = function (e, t, n) {\n          if (n) for (var i = 0; i < e.composites.length; i++) {\n            o.clear(e.composites[i], t, !0);\n          }return t ? e.bodies = e.bodies.filter(function (e) {\n            return e.isStatic;\n          }) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, o.setModified(e, !0, !0, !1), e;\n        }, o.allBodies = function (e) {\n          for (var t = [].concat(e.bodies), n = 0; n < e.composites.length; n++) {\n            t = t.concat(o.allBodies(e.composites[n]));\n          }return t;\n        }, o.allConstraints = function (e) {\n          for (var t = [].concat(e.constraints), n = 0; n < e.composites.length; n++) {\n            t = t.concat(o.allConstraints(e.composites[n]));\n          }return t;\n        }, o.allComposites = function (e) {\n          for (var t = [].concat(e.composites), n = 0; n < e.composites.length; n++) {\n            t = t.concat(o.allComposites(e.composites[n]));\n          }return t;\n        }, o.get = function (e, t, n) {\n          var i, r;switch (n) {case \"body\":\n              i = o.allBodies(e);break;case \"constraint\":\n              i = o.allConstraints(e);break;case \"composite\":\n              i = o.allComposites(e).concat(e);}return i ? (r = i.filter(function (e) {\n            return e.id.toString() === t.toString();\n          }), 0 === r.length ? null : r[0]) : null;\n        }, o.move = function (e, t, n) {\n          return o.remove(e, t), o.add(n, t), e;\n        }, o.rebase = function (e) {\n          for (var t = o.allBodies(e).concat(o.allConstraints(e)).concat(o.allComposites(e)), n = 0; n < t.length; n++) {\n            t[n].id = r.nextId();\n          }return o.setModified(e, !0, !0, !1), e;\n        }, o.translate = function (e, t, n) {\n          for (var i = n ? o.allBodies(e) : e.bodies, r = 0; r < i.length; r++) {\n            s.translate(i[r], t);\n          }return o.setModified(e, !0, !0, !1), e;\n        }, o.rotate = function (e, t, n, i) {\n          for (var r = Math.cos(t), a = Math.sin(t), l = i ? o.allBodies(e) : e.bodies, c = 0; c < l.length; c++) {\n            var d = l[c],\n                u = d.position.x - n.x,\n                p = d.position.y - n.y;s.setPosition(d, { x: n.x + (u * r - p * a), y: n.y + (u * a + p * r) }), s.rotate(d, t);\n          }return o.setModified(e, !0, !0, !1), e;\n        }, o.scale = function (e, t, n, i, r) {\n          for (var a = r ? o.allBodies(e) : e.bodies, l = 0; l < a.length; l++) {\n            var c = a[l],\n                d = c.position.x - i.x,\n                u = c.position.y - i.y;s.setPosition(c, { x: i.x + d * t, y: i.y + u * n }), s.scale(c, t, n);\n          }return o.setModified(e, !0, !0, !1), e;\n        }, o.bounds = function (e) {\n          for (var t = Matter.Composite.allBodies(e), n = [], o = 0; o < t.length; o += 1) {\n            var i = t[o];n.push(i.bounds.min, i.bounds.max);\n          }return Matter.Bounds.create(n);\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Events\": 16, \"./Body\": 1 }], 3: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Composite\"),\n          r = (e(\"../constraint/Constraint\"), e(\"../core/Common\"));!function () {\n        o.create = function (e) {\n          var t = i.create(),\n              n = { label: \"World\", gravity: { x: 0, y: 1, scale: .001 }, bounds: { min: { x: -(1 / 0), y: -(1 / 0) }, max: { x: 1 / 0, y: 1 / 0 } } };return r.extend(t, n, e);\n        };\n      }();\n    }, { \"../constraint/Constraint\": 12, \"../core/Common\": 14, \"./Composite\": 2 }], 4: [function (e, t, n) {\n      var o = {};t.exports = o, function () {\n        o.create = function (e) {\n          return { id: o.id(e), vertex: e, normalImpulse: 0, tangentImpulse: 0 };\n        }, o.id = function (e) {\n          return e.body.id + \"_\" + e.index;\n        };\n      }();\n    }, {}], 5: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./SAT\"),\n          r = e(\"./Pair\"),\n          s = e(\"../geometry/Bounds\");!function () {\n        o.collisions = function (e, t) {\n          for (var n = [], a = t.pairs.table, l = 0; l < e.length; l++) {\n            var c = e[l][0],\n                d = e[l][1];if ((!c.isStatic && !c.isSleeping || !d.isStatic && !d.isSleeping) && o.canCollide(c.collisionFilter, d.collisionFilter) && s.overlaps(c.bounds, d.bounds)) for (var u = c.parts.length > 1 ? 1 : 0; u < c.parts.length; u++) {\n              for (var p = c.parts[u], f = d.parts.length > 1 ? 1 : 0; f < d.parts.length; f++) {\n                var m = d.parts[f];if (p === c && m === d || s.overlaps(p.bounds, m.bounds)) {\n                  var v,\n                      y = r.id(p, m),\n                      g = a[y];v = g && g.isActive ? g.collision : null;var x = i.collides(p, m, v);x.collided && n.push(x);\n                }\n              }\n            }\n          }return n;\n        }, o.canCollide = function (e, t) {\n          return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 !== (e.mask & t.category) && 0 !== (t.mask & e.category);\n        };\n      }();\n    }, { \"../geometry/Bounds\": 26, \"./Pair\": 7, \"./SAT\": 11 }], 6: [function (e, t, n) {\n      var o = {};t.exports = o;\n      var i = e(\"./Pair\"),\n          r = e(\"./Detector\"),\n          s = e(\"../core/Common\");!function () {\n        o.create = function (e) {\n          var t = { controller: o, detector: r.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 };return s.extend(t, e);\n        }, o.update = function (n, o, i, r) {\n          var s,\n              p,\n              f,\n              m,\n              v,\n              y = i.world,\n              g = n.buckets,\n              x = !1;for (s = 0; s < o.length; s++) {\n            var h = o[s];if ((!h.isSleeping || r) && !(h.bounds.max.x < y.bounds.min.x || h.bounds.min.x > y.bounds.max.x || h.bounds.max.y < y.bounds.min.y || h.bounds.min.y > y.bounds.max.y)) {\n              var b = t(n, h);if (!h.region || b.id !== h.region.id || r) {\n                h.region && !r || (h.region = b);var w = e(b, h.region);for (p = w.startCol; p <= w.endCol; p++) {\n                  for (f = w.startRow; f <= w.endRow; f++) {\n                    v = a(p, f), m = g[v];var S = p >= b.startCol && p <= b.endCol && f >= b.startRow && f <= b.endRow,\n                        C = p >= h.region.startCol && p <= h.region.endCol && f >= h.region.startRow && f <= h.region.endRow;!S && C && C && m && d(n, m, h), (h.region === b || S && !C || r) && (m || (m = l(g, v)), c(n, m, h));\n                  }\n                }h.region = b, x = !0;\n              }\n            }\n          }x && (n.pairsList = u(n));\n        }, o.clear = function (e) {\n          e.buckets = {}, e.pairs = {}, e.pairsList = [];\n        };var e = function e(_e2, t) {\n          var o = Math.min(_e2.startCol, t.startCol),\n              i = Math.max(_e2.endCol, t.endCol),\n              r = Math.min(_e2.startRow, t.startRow),\n              s = Math.max(_e2.endRow, t.endRow);\n          return n(o, i, r, s);\n        },\n            t = function t(e, _t) {\n          var o = _t.bounds,\n              i = Math.floor(o.min.x / e.bucketWidth),\n              r = Math.floor(o.max.x / e.bucketWidth),\n              s = Math.floor(o.min.y / e.bucketHeight),\n              a = Math.floor(o.max.y / e.bucketHeight);return n(i, r, s, a);\n        },\n            n = function n(e, t, _n, o) {\n          return { id: e + \",\" + t + \",\" + _n + \",\" + o, startCol: e, endCol: t, startRow: _n, endRow: o };\n        },\n            a = function a(e, t) {\n          return \"C\" + e + \"R\" + t;\n        },\n            l = function l(e, t) {\n          var n = e[t] = [];return n;\n        },\n            c = function c(e, t, n) {\n          for (var o = 0; o < t.length; o++) {\n            var r = t[o];if (!(n.id === r.id || n.isStatic && r.isStatic)) {\n              var s = i.id(n, r),\n                  a = e.pairs[s];a ? a[2] += 1 : e.pairs[s] = [n, r, 1];\n            }\n          }t.push(n);\n        },\n            d = function d(e, t, n) {\n          t.splice(s.indexOf(t, n), 1);for (var o = 0; o < t.length; o++) {\n            var r = t[o],\n                a = i.id(n, r),\n                l = e.pairs[a];l && (l[2] -= 1);\n          }\n        },\n            u = function u(e) {\n          var t,\n              n,\n              o = [];t = s.keys(e.pairs);for (var i = 0; i < t.length; i++) {\n            n = e.pairs[t[i]], n[2] > 0 ? o.push(n) : delete e.pairs[t[i]];\n          }return o;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"./Detector\": 5, \"./Pair\": 7 }], 7: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Contact\");!function () {\n        o.create = function (e, t) {\n          var n = e.bodyA,\n              i = e.bodyB,\n              r = e.parentA,\n              s = e.parentB,\n              a = {\n            id: o.id(n, i), bodyA: n, bodyB: i, contacts: {}, activeContacts: [], separation: 0, isActive: !0, isSensor: n.isSensor || i.isSensor, timeCreated: t, timeUpdated: t, inverseMass: r.inverseMass + s.inverseMass, friction: Math.min(r.friction, s.friction), frictionStatic: Math.max(r.frictionStatic, s.frictionStatic), restitution: Math.max(r.restitution, s.restitution), slop: Math.max(r.slop, s.slop) };return o.update(a, e, t), a;\n        }, o.update = function (e, t, n) {\n          var r = e.contacts,\n              s = t.supports,\n              a = e.activeContacts,\n              l = t.parentA,\n              c = t.parentB;if (e.collision = t, e.inverseMass = l.inverseMass + c.inverseMass, e.friction = Math.min(l.friction, c.friction), e.frictionStatic = Math.max(l.frictionStatic, c.frictionStatic), e.restitution = Math.max(l.restitution, c.restitution), e.slop = Math.max(l.slop, c.slop), a.length = 0, t.collided) {\n            for (var d = 0; d < s.length; d++) {\n              var u = s[d],\n                  p = i.id(u),\n                  f = r[p];f ? a.push(f) : a.push(r[p] = i.create(u));\n            }e.separation = t.depth, o.setActive(e, !0, n);\n          } else e.isActive === !0 && o.setActive(e, !1, n);\n        }, o.setActive = function (e, t, n) {\n          t ? (e.isActive = !0, e.timeUpdated = n) : (e.isActive = !1, e.activeContacts.length = 0);\n        }, o.id = function (e, t) {\n          return e.id < t.id ? \"A\" + e.id + \"B\" + t.id : \"A\" + t.id + \"B\" + e.id;\n        };\n      }();\n    }, { \"./Contact\": 4 }], 8: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Pair\"),\n          r = e(\"../core/Common\");!function () {\n        var e = 1e3;o.create = function (e) {\n          return r.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, e);\n        }, o.update = function (e, t, n) {\n          var o,\n              s,\n              a,\n              l,\n              c = e.list,\n              d = e.table,\n              u = e.collisionStart,\n              p = e.collisionEnd,\n              f = e.collisionActive,\n              m = [];for (u.length = 0, p.length = 0, f.length = 0, l = 0; l < t.length; l++) {\n            o = t[l], o.collided && (s = i.id(o.bodyA, o.bodyB), m.push(s), a = d[s], a ? (a.isActive ? f.push(a) : u.push(a), i.update(a, o, n)) : (a = i.create(o, n), d[s] = a, u.push(a), c.push(a)));\n          }for (l = 0; l < c.length; l++) {\n            a = c[l], a.isActive && r.indexOf(m, a.id) === -1 && (i.setActive(a, !1, n), p.push(a));\n          }\n        }, o.removeOld = function (t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a = t.list,\n              l = t.table,\n              c = [];for (s = 0; s < a.length; s++) {\n            o = a[s], i = o.collision, i.bodyA.isSleeping || i.bodyB.isSleeping ? o.timeUpdated = n : n - o.timeUpdated > e && c.push(s);\n          }for (s = 0; s < c.length; s++) {\n            r = c[s] - s, o = a[r], delete l[o.id], a.splice(r, 1);\n          }\n        }, o.clear = function (e) {\n          return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"./Pair\": 7 }], 9: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vector\"),\n          r = e(\"./SAT\"),\n          s = e(\"../geometry/Bounds\"),\n          a = e(\"../factory/Bodies\"),\n          l = e(\"../geometry/Vertices\");!function () {\n        o.ray = function (e, t, n, o) {\n          o = o || 1e-100;for (var l = i.angle(t, n), c = i.magnitude(i.sub(t, n)), d = .5 * (n.x + t.x), u = .5 * (n.y + t.y), p = a.rectangle(d, u, c, o, { angle: l }), f = [], m = 0; m < e.length; m++) {\n            var v = e[m];if (s.overlaps(v.bounds, p.bounds)) for (var y = 1 === v.parts.length ? 0 : 1; y < v.parts.length; y++) {\n              var g = v.parts[y];if (s.overlaps(g.bounds, p.bounds)) {\n                var x = r.collides(g, p);if (x.collided) {\n                  x.body = x.bodyA = x.bodyB = v, f.push(x);break;\n                }\n              }\n            }\n          }return f;\n        }, o.region = function (e, t, n) {\n          for (var o = [], i = 0; i < e.length; i++) {\n            var r = e[i],\n                a = s.overlaps(r.bounds, t);(a && !n || !a && n) && o.push(r);\n          }return o;\n        }, o.point = function (e, t) {\n          for (var n = [], o = 0; o < e.length; o++) {\n            var i = e[o];if (s.contains(i.bounds, t)) for (var r = 1 === i.parts.length ? 0 : 1; r < i.parts.length; r++) {\n              var a = i.parts[r];if (s.contains(a.bounds, t) && l.contains(a.vertices, t)) {\n                n.push(i);break;\n              }\n            }\n          }return n;\n        };\n      }();\n    }, { \"../factory/Bodies\": 23, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29, \"./SAT\": 11 }], 10: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Common\"),\n          a = e(\"../geometry/Bounds\");!function () {\n        o._restingThresh = 4, o._restingThreshTangent = 6, o._positionDampen = .9, o._positionWarming = .8, o._frictionNormalMultiplier = 5, o.preSolvePosition = function (e) {\n          var t, n, o;for (t = 0; t < e.length; t++) {\n            n = e[t], n.isActive && (o = n.activeContacts.length, n.collision.parentA.totalContacts += o, n.collision.parentB.totalContacts += o);\n          }\n        }, o.solvePosition = function (e, t) {\n          var n,\n              i,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f = r._temp[0],\n              m = r._temp[1],\n              v = r._temp[2],\n              y = r._temp[3];for (n = 0; n < e.length; n++) {\n            i = e[n], i.isActive && !i.isSensor && (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, d = r.sub(r.add(l.positionImpulse, l.position, f), r.add(a.positionImpulse, r.sub(l.position, s.penetration, m), v), y), i.separation = r.dot(c, d));\n          }for (n = 0; n < e.length; n++) {\n            i = e[n], i.isActive && !i.isSensor && (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, p = (i.separation - i.slop) * t, (a.isStatic || l.isStatic) && (p *= 2), a.isStatic || a.isSleeping || (u = o._positionDampen / a.totalContacts, a.positionImpulse.x += c.x * p * u, a.positionImpulse.y += c.y * p * u), l.isStatic || l.isSleeping || (u = o._positionDampen / l.totalContacts, l.positionImpulse.x -= c.x * p * u, l.positionImpulse.y -= c.y * p * u));\n          }\n        }, o.postSolvePosition = function (e) {\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];if (n.totalContacts = 0, 0 !== n.positionImpulse.x || 0 !== n.positionImpulse.y) {\n              for (var s = 0; s < n.parts.length; s++) {\n                var l = n.parts[s];i.translate(l.vertices, n.positionImpulse), a.update(l.bounds, l.vertices, n.velocity), l.position.x += n.positionImpulse.x, l.position.y += n.positionImpulse.y;\n              }n.positionPrev.x += n.positionImpulse.x, n.positionPrev.y += n.positionImpulse.y, r.dot(n.positionImpulse, n.velocity) < 0 ? (n.positionImpulse.x = 0, n.positionImpulse.y = 0) : (n.positionImpulse.x *= o._positionWarming, n.positionImpulse.y *= o._positionWarming);\n            }\n          }\n        }, o.preSolveVelocity = function (e) {\n          var t,\n              n,\n              o,\n              i,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f,\n              m,\n              v,\n              y = r._temp[0],\n              g = r._temp[1];for (t = 0; t < e.length; t++) {\n            if (o = e[t], o.isActive && !o.isSensor) for (i = o.activeContacts, s = o.collision, a = s.parentA, l = s.parentB, c = s.normal, d = s.tangent, n = 0; n < i.length; n++) {\n              u = i[n], p = u.vertex, f = u.normalImpulse, m = u.tangentImpulse, 0 === f && 0 === m || (y.x = c.x * f + d.x * m, y.y = c.y * f + d.y * m, a.isStatic || a.isSleeping || (v = r.sub(p, a.position, g), a.positionPrev.x += y.x * a.inverseMass, a.positionPrev.y += y.y * a.inverseMass, a.anglePrev += r.cross(v, y) * a.inverseInertia), l.isStatic || l.isSleeping || (v = r.sub(p, l.position, g), l.positionPrev.x -= y.x * l.inverseMass, l.positionPrev.y -= y.y * l.inverseMass, l.anglePrev -= r.cross(v, y) * l.inverseInertia));\n            }\n          }\n        }, o.solveVelocity = function (e, t) {\n          for (var n = t * t, i = r._temp[0], a = r._temp[1], l = r._temp[2], c = r._temp[3], d = r._temp[4], u = r._temp[5], p = 0; p < e.length; p++) {\n            var f = e[p];if (f.isActive && !f.isSensor) {\n              var m = f.collision,\n                  v = m.parentA,\n                  y = m.parentB,\n                  g = m.normal,\n                  x = m.tangent,\n                  h = f.activeContacts,\n                  b = 1 / h.length;v.velocity.x = v.position.x - v.positionPrev.x, v.velocity.y = v.position.y - v.positionPrev.y, y.velocity.x = y.position.x - y.positionPrev.x, y.velocity.y = y.position.y - y.positionPrev.y, v.angularVelocity = v.angle - v.anglePrev, y.angularVelocity = y.angle - y.anglePrev;for (var w = 0; w < h.length; w++) {\n                var S = h[w],\n                    C = S.vertex,\n                    A = r.sub(C, v.position, a),\n                    P = r.sub(C, y.position, l),\n                    B = r.add(v.velocity, r.mult(r.perp(A), v.angularVelocity), c),\n                    M = r.add(y.velocity, r.mult(r.perp(P), y.angularVelocity), d),\n                    k = r.sub(B, M, u),\n                    I = r.dot(g, k),\n                    T = r.dot(x, k),\n                    V = Math.abs(T),\n                    _ = s.sign(T),\n                    R = (1 + f.restitution) * I,\n                    E = s.clamp(f.separation + I, 0, 1) * o._frictionNormalMultiplier,\n                    L = T,\n                    F = 1 / 0;V > f.friction * f.frictionStatic * E * n && (F = V, L = s.clamp(f.friction * _ * n, -F, F));var O = r.cross(A, g),\n                    q = r.cross(P, g),\n                    W = b / (v.inverseMass + y.inverseMass + v.inverseInertia * O * O + y.inverseInertia * q * q);if (R *= W, L *= W, I < 0 && I * I > o._restingThresh * n) S.normalImpulse = 0;else {\n                  var D = S.normalImpulse;S.normalImpulse = Math.min(S.normalImpulse + R, 0), R = S.normalImpulse - D;\n                }if (T * T > o._restingThreshTangent * n) S.tangentImpulse = 0;else {\n                  var N = S.tangentImpulse;S.tangentImpulse = s.clamp(S.tangentImpulse + L, -F, F), L = S.tangentImpulse - N;\n                }i.x = g.x * R + x.x * L, i.y = g.y * R + x.y * L, v.isStatic || v.isSleeping || (v.positionPrev.x += i.x * v.inverseMass, v.positionPrev.y += i.y * v.inverseMass, v.anglePrev += r.cross(A, i) * v.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= i.x * y.inverseMass, y.positionPrev.y -= i.y * y.inverseMass, y.anglePrev -= r.cross(P, i) * y.inverseInertia);\n              }\n            }\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29 }], 11: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\");!function () {\n        o.collides = function (t, o, s) {\n          var a,\n              l,\n              c,\n              d,\n              u = !1;if (s) {\n            var p = t.parent,\n                f = o.parent,\n                m = p.speed * p.speed + p.angularSpeed * p.angularSpeed + f.speed * f.speed + f.angularSpeed * f.angularSpeed;u = s && s.collided && m < .2, d = s;\n          } else d = { collided: !1, bodyA: t, bodyB: o };if (s && u) {\n            var v = d.axisBody,\n                y = v === t ? o : t,\n                g = [v.axes[s.axisNumber]];if (c = e(v.vertices, y.vertices, g), d.reused = !0, c.overlap <= 0) return d.collided = !1, d;\n          } else {\n            if (a = e(t.vertices, o.vertices, t.axes), a.overlap <= 0) return d.collided = !1, d;if (l = e(o.vertices, t.vertices, o.axes), l.overlap <= 0) return d.collided = !1, d;a.overlap < l.overlap ? (c = a, d.axisBody = t) : (c = l, d.axisBody = o), d.axisNumber = c.axisNumber;\n          }d.bodyA = t.id < o.id ? t : o, d.bodyB = t.id < o.id ? o : t, d.collided = !0, d.depth = c.overlap, d.parentA = d.bodyA.parent, d.parentB = d.bodyB.parent, t = d.bodyA, o = d.bodyB, r.dot(c.axis, r.sub(o.position, t.position)) < 0 ? d.normal = { x: c.axis.x, y: c.axis.y } : d.normal = { x: -c.axis.x, y: -c.axis.y }, d.tangent = r.perp(d.normal), d.penetration = d.penetration || {}, d.penetration.x = d.normal.x * d.depth, d.penetration.y = d.normal.y * d.depth;var x = n(t, o, d.normal),\n              h = [];if (i.contains(t.vertices, x[0]) && h.push(x[0]), i.contains(t.vertices, x[1]) && h.push(x[1]), h.length < 2) {\n            var b = n(o, t, r.neg(d.normal));i.contains(o.vertices, b[0]) && h.push(b[0]), h.length < 2 && i.contains(o.vertices, b[1]) && h.push(b[1]);\n          }return h.length < 1 && (h = [x[0]]), d.supports = h, d;\n        };var e = function e(_e3, n, o) {\n          for (var i, s, a = r._temp[0], l = r._temp[1], c = { overlap: Number.MAX_VALUE }, d = 0; d < o.length; d++) {\n            if (s = o[d], t(a, _e3, s), t(l, n, s), i = Math.min(a.max - l.min, l.max - a.min), i <= 0) return c.overlap = i, c;i < c.overlap && (c.overlap = i, c.axis = s, c.axisNumber = d);\n          }return c;\n        },\n            t = function t(e, _t2, n) {\n          for (var o = r.dot(_t2[0], n), i = o, s = 1; s < _t2.length; s += 1) {\n            var a = r.dot(_t2[s], n);a > i ? i = a : a < o && (o = a);\n          }e.min = o, e.max = i;\n        },\n            n = function n(e, t, _n2) {\n          for (var o, i, s, a, l = Number.MAX_VALUE, c = r._temp[0], d = t.vertices, u = e.position, p = 0; p < d.length; p++) {\n            i = d[p], c.x = i.x - u.x, c.y = i.y - u.y, o = -r.dot(_n2, c), o < l && (l = o, s = i);\n          }var f = s.index - 1 >= 0 ? s.index - 1 : d.length - 1;i = d[f], c.x = i.x - u.x, c.y = i.y - u.y, l = -r.dot(_n2, c), a = i;var m = (s.index + 1) % d.length;return i = d[m], c.x = i.x - u.x, c.y = i.y - u.y, o = -r.dot(_n2, c), o < l && (a = i), [s, a];\n        };\n      }();\n    }, { \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29 }], 12: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Sleeping\"),\n          a = e(\"../geometry/Bounds\"),\n          l = e(\"../geometry/Axes\"),\n          c = e(\"../core/Common\");!function () {\n        o._warming = .4, o._torqueDampen = 1, o._minLength = 1e-6, o.create = function (e) {\n          var t = e;t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 });var n = t.bodyA ? r.add(t.bodyA.position, t.pointA) : t.pointA,\n              o = t.bodyB ? r.add(t.bodyB.position, t.pointB) : t.pointB,\n              i = r.magnitude(r.sub(n, o));\n          t.length = \"undefined\" != typeof t.length ? t.length : i, t.id = t.id || c.nextId(), t.label = t.label || \"Constraint\", t.type = \"constraint\", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {};var s = { visible: !0, lineWidth: 2, strokeStyle: \"#ffffff\", type: \"line\", anchors: !0 };return 0 === t.length && t.stiffness > .1 ? (s.type = \"pin\", s.anchors = !1) : t.stiffness < .9 && (s.type = \"spring\"), t.render = c.extend(s, t.render), t;\n        }, o.preSolveAll = function (e) {\n          for (var t = 0; t < e.length; t += 1) {\n            var n = e[t],\n                o = n.constraintImpulse;n.isStatic || 0 === o.x && 0 === o.y && 0 === o.angle || (n.position.x += o.x, n.position.y += o.y, n.angle += o.angle);\n          }\n        }, o.solveAll = function (e, t) {\n          for (var n = 0; n < e.length; n += 1) {\n            var i = e[n],\n                r = !i.bodyA || i.bodyA && i.bodyA.isStatic,\n                s = !i.bodyB || i.bodyB && i.bodyB.isStatic;(r || s) && o.solve(e[n], t);\n          }for (n = 0; n < e.length; n += 1) {\n            i = e[n], r = !i.bodyA || i.bodyA && i.bodyA.isStatic, s = !i.bodyB || i.bodyB && i.bodyB.isStatic, r || s || o.solve(e[n], t);\n          }\n        }, o.solve = function (e, t) {\n          var n = e.bodyA,\n              i = e.bodyB,\n              s = e.pointA,\n              a = e.pointB;if (n || i) {\n            n && !n.isStatic && (r.rotate(s, n.angle - e.angleA, s), e.angleA = n.angle), i && !i.isStatic && (r.rotate(a, i.angle - e.angleB, a), e.angleB = i.angle);var l = s,\n                c = a;if (n && (l = r.add(n.position, s)), i && (c = r.add(i.position, a)), l && c) {\n              var d = r.sub(l, c),\n                  u = r.magnitude(d);u < o._minLength && (u = o._minLength);var p,\n                  f,\n                  m,\n                  v,\n                  y,\n                  g = (u - e.length) / u,\n                  x = e.stiffness < 1 ? e.stiffness * t : e.stiffness,\n                  h = r.mult(d, g * x),\n                  b = (n ? n.inverseMass : 0) + (i ? i.inverseMass : 0),\n                  w = (n ? n.inverseInertia : 0) + (i ? i.inverseInertia : 0),\n                  S = b + w;if (e.damping) {\n                var C = r.create();m = r.div(d, u), y = r.sub(i && r.sub(i.position, i.positionPrev) || C, n && r.sub(n.position, n.positionPrev) || C), v = r.dot(m, y);\n              }n && !n.isStatic && (f = n.inverseMass / b, n.constraintImpulse.x -= h.x * f, n.constraintImpulse.y -= h.y * f, n.position.x -= h.x * f, n.position.y -= h.y * f, e.damping && (n.positionPrev.x -= e.damping * m.x * v * f, n.positionPrev.y -= e.damping * m.y * v * f), p = r.cross(s, h) / S * o._torqueDampen * n.inverseInertia * (1 - e.angularStiffness), n.constraintImpulse.angle -= p, n.angle -= p), i && !i.isStatic && (f = i.inverseMass / b, i.constraintImpulse.x += h.x * f, i.constraintImpulse.y += h.y * f, i.position.x += h.x * f, i.position.y += h.y * f, e.damping && (i.positionPrev.x += e.damping * m.x * v * f, i.positionPrev.y += e.damping * m.y * v * f), p = r.cross(a, h) / S * o._torqueDampen * i.inverseInertia * (1 - e.angularStiffness), i.constraintImpulse.angle += p, i.angle += p);\n            }\n          }\n        }, o.postSolveAll = function (e) {\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t],\n                c = n.constraintImpulse;if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {\n              s.set(n, !1);for (var d = 0; d < n.parts.length; d++) {\n                var u = n.parts[d];i.translate(u.vertices, c), d > 0 && (u.position.x += c.x, u.position.y += c.y), 0 !== c.angle && (i.rotate(u.vertices, c.angle, n.position), l.rotate(u.axes, c.angle), d > 0 && r.rotateAbout(u.position, c.angle, n.position, u.position)), a.update(u.bounds, u.vertices, n.velocity);\n              }c.angle *= o._warming, c.x *= o._warming, c.y *= o._warming;\n            }\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Sleeping\": 22, \"../geometry/Axes\": 25, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29 }], 13: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../core/Sleeping\"),\n          s = e(\"../core/Mouse\"),\n          a = e(\"../core/Events\"),\n          l = e(\"../collision/Detector\"),\n          c = e(\"./Constraint\"),\n          d = e(\"../body/Composite\"),\n          u = e(\"../core/Common\"),\n          p = e(\"../geometry/Bounds\");!function () {\n        o.create = function (t, n) {\n          var i = (t ? t.mouse : null) || (n ? n.mouse : null);i || (t && t.render && t.render.canvas ? i = s.create(t.render.canvas) : n && n.element ? i = s.create(n.element) : (i = s.create(), u.warn(\"MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected\")));var r = c.create({ label: \"Mouse Constraint\", pointA: i.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: \"#90EE90\", lineWidth: 3 } }),\n              l = { type: \"mouseConstraint\", mouse: i, element: null, body: null, constraint: r, collisionFilter: { category: 1, mask: 4294967295, group: 0 } },\n              p = u.extend(l, n);return a.on(t, \"beforeUpdate\", function () {\n            var n = d.allBodies(t.world);o.update(p, n), e(p);\n          }), p;\n        }, o.update = function (e, t) {\n          var n = e.mouse,\n              o = e.constraint,\n              s = e.body;\n          if (0 === n.button) {\n            if (o.bodyB) r.set(o.bodyB, !1), o.pointA = n.position;else for (var c = 0; c < t.length; c++) {\n              if (s = t[c], p.contains(s.bounds, n.position) && l.canCollide(s.collisionFilter, e.collisionFilter)) for (var d = s.parts.length > 1 ? 1 : 0; d < s.parts.length; d++) {\n                var u = s.parts[d];if (i.contains(u.vertices, n.position)) {\n                  o.pointA = n.position, o.bodyB = e.body = s, o.pointB = { x: n.position.x - s.position.x, y: n.position.y - s.position.y }, o.angleB = s.angle, r.set(s, !1), a.trigger(e, \"startdrag\", { mouse: n, body: s });break;\n                }\n              }\n            }\n          } else o.bodyB = e.body = null, o.pointB = null, s && a.trigger(e, \"enddrag\", { mouse: n, body: s });\n        };var e = function e(_e4) {\n          var t = _e4.mouse,\n              n = t.sourceEvents;n.mousemove && a.trigger(_e4, \"mousemove\", { mouse: t }), n.mousedown && a.trigger(_e4, \"mousedown\", { mouse: t }), n.mouseup && a.trigger(_e4, \"mouseup\", { mouse: t }), s.clearSourceEvents(t);\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../collision/Detector\": 5, \"../core/Common\": 14, \"../core/Events\": 16, \"../core/Mouse\": 19, \"../core/Sleeping\": 22, \"../geometry/Bounds\": 26, \"../geometry/Vertices\": 29, \"./Constraint\": 12 }], 14: [function (e, t, n) {\n      var o = {};t.exports = o, function () {\n        o._nextId = 0, o._seed = 0, o._nowStartTime = +new Date(), o.extend = function (e, t) {\n          var n, i;\"boolean\" == typeof t ? (n = 2, i = t) : (n = 1, i = !0);for (var r = n; r < arguments.length; r++) {\n            var s = arguments[r];if (s) for (var a in s) {\n              i && s[a] && s[a].constructor === Object ? e[a] && e[a].constructor !== Object ? e[a] = s[a] : (e[a] = e[a] || {}, o.extend(e[a], i, s[a])) : e[a] = s[a];\n            }\n          }return e;\n        }, o.clone = function (e, t) {\n          return o.extend({}, t, e);\n        }, o.keys = function (e) {\n          if (Object.keys) return Object.keys(e);var t = [];for (var n in e) {\n            t.push(n);\n          }return t;\n        }, o.values = function (e) {\n          var t = [];if (Object.keys) {\n            for (var n = Object.keys(e), o = 0; o < n.length; o++) {\n              t.push(e[n[o]]);\n            }return t;\n          }for (var i in e) {\n            t.push(e[i]);\n          }return t;\n        }, o.get = function (e, t, n, o) {\n          t = t.split(\".\").slice(n, o);for (var i = 0; i < t.length; i += 1) {\n            e = e[t[i]];\n          }return e;\n        }, o.set = function (e, t, n, i, r) {\n          var s = t.split(\".\").slice(i, r);return o.get(e, t, 0, -1)[s[s.length - 1]] = n, n;\n        }, o.shuffle = function (e) {\n          for (var t = e.length - 1; t > 0; t--) {\n            var n = Math.floor(o.random() * (t + 1)),\n                i = e[t];e[t] = e[n], e[n] = i;\n          }return e;\n        }, o.choose = function (e) {\n          return e[Math.floor(o.random() * e.length)];\n        }, o.isElement = function (e) {\n          return e instanceof HTMLElement;\n        }, o.isArray = function (e) {\n          return \"[object Array]\" === Object.prototype.toString.call(e);\n        }, o.isFunction = function (e) {\n          return \"function\" == typeof e;\n        }, o.isPlainObject = function (e) {\n          return \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && e.constructor === Object;\n        }, o.isString = function (e) {\n          return \"[object String]\" === toString.call(e);\n        }, o.clamp = function (e, t, n) {\n          return e < t ? t : e > n ? n : e;\n        }, o.sign = function (e) {\n          return e < 0 ? -1 : 1;\n        }, o.now = function () {\n          if (window.performance) {\n            if (window.performance.now) return window.performance.now();if (window.performance.webkitNow) return window.performance.webkitNow();\n          }return new Date() - o._nowStartTime;\n        }, o.random = function (t, n) {\n          return t = \"undefined\" != typeof t ? t : 0, n = \"undefined\" != typeof n ? n : 1, t + e() * (n - t);\n        };var e = function e() {\n          return o._seed = (9301 * o._seed + 49297) % 233280, o._seed / 233280;\n        };o.colorToNumber = function (e) {\n          return e = e.replace(\"#\", \"\"), 3 == e.length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16);\n        }, o.logLevel = 1, o.log = function () {\n          console && o.logLevel > 0 && o.logLevel <= 3 && console.log.apply(console, [\"matter-js:\"].concat(Array.prototype.slice.call(arguments)));\n        }, o.info = function () {\n          console && o.logLevel > 0 && o.logLevel <= 2 && console.info.apply(console, [\"matter-js:\"].concat(Array.prototype.slice.call(arguments)));\n        }, o.warn = function () {\n          console && o.logLevel > 0 && o.logLevel <= 3 && console.warn.apply(console, [\"matter-js:\"].concat(Array.prototype.slice.call(arguments)));\n        }, o.nextId = function () {\n          return o._nextId++;\n        }, o.indexOf = function (e, t) {\n          if (e.indexOf) return e.indexOf(t);for (var n = 0; n < e.length; n++) {\n            if (e[n] === t) return n;\n          }return -1;\n        }, o.map = function (e, t) {\n          if (e.map) return e.map(t);for (var n = [], o = 0; o < e.length; o += 1) {\n            n.push(t(e[o]));\n          }return n;\n        }, o.topologicalSort = function (e) {\n          var n = [],\n              o = [],\n              i = [];for (var r in e) {\n            o[r] || i[r] || t(r, o, i, e, n);\n          }return n;\n        };var t = function t(e, n, o, i, r) {\n          var s = i[e] || [];o[e] = !0;for (var a = 0; a < s.length; a += 1) {\n            var l = s[a];o[l] || n[l] || t(l, n, o, i, r);\n          }o[e] = !1, n[e] = !0, r.push(e);\n        };o.chain = function () {\n          for (var e = [], t = 0; t < arguments.length; t += 1) {\n            var n = arguments[t];\n            n._chained ? e.push.apply(e, n._chained) : e.push(n);\n          }var o = function o() {\n            for (var t, n = new Array(arguments.length), o = 0, i = arguments.length; o < i; o++) {\n              n[o] = arguments[o];\n            }for (o = 0; o < e.length; o += 1) {\n              var r = e[o].apply(t, n);\"undefined\" != typeof r && (t = r);\n            }return t;\n          };return o._chained = e, o;\n        }, o.chainPathBefore = function (e, t, n) {\n          return o.set(e, t, o.chain(n, o.get(e, t)));\n        }, o.chainPathAfter = function (e, t, n) {\n          return o.set(e, t, o.chain(o.get(e, t), n));\n        };\n      }();\n    }, {}], 15: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../body/World\"),\n          r = e(\"./Sleeping\"),\n          s = e(\"../collision/Resolver\"),\n          a = e(\"../render/Render\"),\n          l = e(\"../collision/Pairs\"),\n          c = (e(\"./Metrics\"), e(\"../collision/Grid\")),\n          d = e(\"./Events\"),\n          u = e(\"../body/Composite\"),\n          p = e(\"../constraint/Constraint\"),\n          f = e(\"./Common\"),\n          m = e(\"../body/Body\");!function () {\n        o.create = function (e, t) {\n          t = f.isElement(e) ? t : e, e = f.isElement(e) ? e : null, t = t || {}, (e || t.render) && f.warn(\"Engine.create: engine.render is deprecated (see docs)\");var n = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [],\n            plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: c } },\n              o = f.extend(n, t);if (e || o.render) {\n            var r = { element: e, controller: a };o.render = f.extend(r, o.render);\n          }return o.render && o.render.controller && (o.render = o.render.controller.create(o.render)), o.render && (o.render.engine = o), o.world = t.world || i.create(o.world), o.pairs = l.create(), o.broadphase = o.broadphase.controller.create(o.broadphase), o.metrics = o.metrics || { extended: !1 }, o;\n        }, o.update = function (o, i, a) {\n          i = i || 1e3 / 60, a = a || 1;var c,\n              f = o.world,\n              m = o.timing,\n              v = o.broadphase,\n              y = [];m.timestamp += i * m.timeScale;var g = { timestamp: m.timestamp };d.trigger(o, \"beforeUpdate\", g);var x = u.allBodies(f),\n              h = u.allConstraints(f);for (o.enableSleeping && r.update(x, m.timeScale), t(x, f.gravity), n(x, i, m.timeScale, a, f.bounds), p.preSolveAll(x), c = 0; c < o.constraintIterations; c++) {\n            p.solveAll(h, m.timeScale);\n          }p.postSolveAll(x), v.controller ? (f.isModified && v.controller.clear(v), v.controller.update(v, x, o, f.isModified), y = v.pairsList) : y = x, f.isModified && u.setModified(f, !1, !1, !0);var b = v.detector(y, o),\n              w = o.pairs,\n              S = m.timestamp;\n          for (l.update(w, b, S), l.removeOld(w, S), o.enableSleeping && r.afterCollisions(w.list, m.timeScale), w.collisionStart.length > 0 && d.trigger(o, \"collisionStart\", { pairs: w.collisionStart }), s.preSolvePosition(w.list), c = 0; c < o.positionIterations; c++) {\n            s.solvePosition(w.list, m.timeScale);\n          }for (s.postSolvePosition(x), p.preSolveAll(x), c = 0; c < o.constraintIterations; c++) {\n            p.solveAll(h, m.timeScale);\n          }for (p.postSolveAll(x), s.preSolveVelocity(w.list), c = 0; c < o.velocityIterations; c++) {\n            s.solveVelocity(w.list, m.timeScale);\n          }return w.collisionActive.length > 0 && d.trigger(o, \"collisionActive\", { pairs: w.collisionActive }), w.collisionEnd.length > 0 && d.trigger(o, \"collisionEnd\", { pairs: w.collisionEnd }), e(x), d.trigger(o, \"afterUpdate\", g), o;\n        }, o.merge = function (e, t) {\n          if (f.extend(e, t), t.world) {\n            e.world = t.world, o.clear(e);for (var n = u.allBodies(e.world), i = 0; i < n.length; i++) {\n              var s = n[i];r.set(s, !1), s.id = f.nextId();\n            }\n          }\n        }, o.clear = function (e) {\n          var t = e.world;l.clear(e.pairs);var n = e.broadphase;if (n.controller) {\n            var o = u.allBodies(t);n.controller.clear(n), n.controller.update(n, o, e, !0);\n          }\n        };var e = function e(_e5) {\n          for (var t = 0; t < _e5.length; t++) {\n            var n = _e5[t];n.force.x = 0, n.force.y = 0, n.torque = 0;\n          }\n        },\n            t = function t(e, _t3) {\n          var n = \"undefined\" != typeof _t3.scale ? _t3.scale : .001;if ((0 !== _t3.x || 0 !== _t3.y) && 0 !== n) for (var o = 0; o < e.length; o++) {\n            var i = e[o];i.isStatic || i.isSleeping || (i.force.y += i.mass * _t3.y * n, i.force.x += i.mass * _t3.x * n);\n          }\n        },\n            n = function n(e, t, _n3, o, i) {\n          for (var r = 0; r < e.length; r++) {\n            var s = e[r];s.isStatic || s.isSleeping || m.update(s, t, _n3, o);\n          }\n        };\n      }();\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../body/World\": 3, \"../collision/Grid\": 6, \"../collision/Pairs\": 8, \"../collision/Resolver\": 10, \"../constraint/Constraint\": 12, \"../render/Render\": 31, \"./Common\": 14, \"./Events\": 16, \"./Metrics\": 18, \"./Sleeping\": 22 }], 16: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Common\");!function () {\n        o.on = function (e, t, n) {\n          for (var o, i = t.split(\" \"), r = 0; r < i.length; r++) {\n            o = i[r], e.events = e.events || {}, e.events[o] = e.events[o] || [], e.events[o].push(n);\n          }return n;\n        }, o.off = function (e, t, n) {\n          if (!t) return void (e.events = {});\"function\" == typeof t && (n = t, t = i.keys(e.events).join(\" \"));for (var o = t.split(\" \"), r = 0; r < o.length; r++) {\n            var s = e.events[o[r]],\n                a = [];if (n && s) for (var l = 0; l < s.length; l++) {\n              s[l] !== n && a.push(s[l]);\n            }e.events[o[r]] = a;\n          }\n        }, o.trigger = function (e, t, n) {\n          var o, r, s, a;if (e.events) {\n            n || (n = {}), o = t.split(\" \");for (var l = 0; l < o.length; l++) {\n              if (r = o[l], s = e.events[r]) {\n                a = i.clone(n, !1), a.name = r, a.source = e;for (var c = 0; c < s.length; c++) {\n                  s[c].apply(e, [a]);\n                }\n              }\n            }\n          }\n        };\n      }();\n    }, { \"./Common\": 14 }], 17: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Plugin\"),\n          r = e(\"./Common\");!function () {\n        o.name = \"matter-js\", o.version = \"0.13.0\", o.uses = [], o.used = [], o.use = function () {\n          i.use(o, Array.prototype.slice.call(arguments));\n        }, o.before = function (e, t) {\n          return e = e.replace(/^Matter./, \"\"), r.chainPathBefore(o, e, t);\n        }, o.after = function (e, t) {\n          return e = e.replace(/^Matter./, \"\"), r.chainPathAfter(o, e, t);\n        };\n      }();\n    }, { \"./Common\": 14, \"./Plugin\": 20 }], 18: [function (e, t, n) {}, { \"../body/Composite\": 2, \"./Common\": 14 }], 19: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../core/Common\");!function () {\n        o.create = function (t) {\n          var n = {};return t || i.log(\"Mouse.create: element was undefined, defaulting to document.body\", \"warn\"), n.element = t || document.body, n.absolute = { x: 0, y: 0 }, n.position = { x: 0, y: 0 }, n.mousedownPosition = { x: 0, y: 0 }, n.mouseupPosition = { x: 0, y: 0 }, n.offset = { x: 0, y: 0 }, n.scale = { x: 1, y: 1 }, n.wheelDelta = 0, n.button = -1, n.pixelRatio = n.element.getAttribute(\"data-pixel-ratio\") || 1, n.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, n.mousemove = function (t) {\n            var o = e(t, n.element, n.pixelRatio),\n                i = t.changedTouches;i && (n.button = 0, t.preventDefault()), n.absolute.x = o.x, n.absolute.y = o.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.sourceEvents.mousemove = t;\n          }, n.mousedown = function (t) {\n            var o = e(t, n.element, n.pixelRatio),\n                i = t.changedTouches;i ? (n.button = 0, t.preventDefault()) : n.button = t.button, n.absolute.x = o.x, n.absolute.y = o.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.mousedownPosition.x = n.position.x, n.mousedownPosition.y = n.position.y, n.sourceEvents.mousedown = t;\n          }, n.mouseup = function (t) {\n            var o = e(t, n.element, n.pixelRatio),\n                i = t.changedTouches;\n            i && t.preventDefault(), n.button = -1, n.absolute.x = o.x, n.absolute.y = o.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.mouseupPosition.x = n.position.x, n.mouseupPosition.y = n.position.y, n.sourceEvents.mouseup = t;\n          }, n.mousewheel = function (e) {\n            n.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault();\n          }, o.setElement(n, n.element), n;\n        }, o.setElement = function (e, t) {\n          e.element = t, t.addEventListener(\"mousemove\", e.mousemove), t.addEventListener(\"mousedown\", e.mousedown), t.addEventListener(\"mouseup\", e.mouseup), t.addEventListener(\"mousewheel\", e.mousewheel), t.addEventListener(\"DOMMouseScroll\", e.mousewheel), t.addEventListener(\"touchmove\", e.mousemove), t.addEventListener(\"touchstart\", e.mousedown), t.addEventListener(\"touchend\", e.mouseup);\n        }, o.clearSourceEvents = function (e) {\n          e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0;\n        }, o.setOffset = function (e, t) {\n          e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;\n        }, o.setScale = function (e, t) {\n          e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;\n        };var e = function e(_e6, t, n) {\n          var o,\n              i,\n              r = t.getBoundingClientRect(),\n              s = document.documentElement || document.body.parentNode || document.body,\n              a = void 0 !== window.pageXOffset ? window.pageXOffset : s.scrollLeft,\n              l = void 0 !== window.pageYOffset ? window.pageYOffset : s.scrollTop,\n              c = _e6.changedTouches;return c ? (o = c[0].pageX - r.left - a, i = c[0].pageY - r.top - l) : (o = _e6.pageX - r.left - a, i = _e6.pageY - r.top - l), { x: o / (t.clientWidth / (t.width || t.clientWidth) * n), y: i / (t.clientHeight / (t.height || t.clientHeight) * n) };\n        };\n      }();\n    }, { \"../core/Common\": 14 }], 20: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Common\");!function () {\n        o._registry = {}, o.register = function (e) {\n          if (o.isPlugin(e) || i.warn(\"Plugin.register:\", o.toString(e), \"does not implement all required fields.\"), e.name in o._registry) {\n            var t = o._registry[e.name],\n                n = o.versionParse(e.version).number,\n                r = o.versionParse(t.version).number;\n            n > r ? (i.warn(\"Plugin.register:\", o.toString(t), \"was upgraded to\", o.toString(e)), o._registry[e.name] = e) : n < r ? i.warn(\"Plugin.register:\", o.toString(t), \"can not be downgraded to\", o.toString(e)) : e !== t && i.warn(\"Plugin.register:\", o.toString(e), \"is already registered to different plugin object\");\n          } else o._registry[e.name] = e;return e;\n        }, o.resolve = function (e) {\n          return o._registry[o.dependencyParse(e).name];\n        }, o.toString = function (e) {\n          return \"string\" == typeof e ? e : (e.name || \"anonymous\") + \"@\" + (e.version || e.range || \"0.0.0\");\n        }, o.isPlugin = function (e) {\n          return e && e.name && e.version && e.install;\n        }, o.isUsed = function (e, t) {\n          return e.used.indexOf(t) > -1;\n        }, o.isFor = function (e, t) {\n          var n = e.for && o.dependencyParse(e.for);return !e.for || t.name === n.name && o.versionSatisfies(t.version, n.range);\n        }, o.use = function (e, t) {\n          if (e.uses = (e.uses || []).concat(t || []), 0 === e.uses.length) return void i.warn(\"Plugin.use:\", o.toString(e), \"does not specify any dependencies to install.\");for (var n = o.dependencies(e), r = i.topologicalSort(n), s = [], a = 0; a < r.length; a += 1) {\n            if (r[a] !== e.name) {\n              var l = o.resolve(r[a]);l ? o.isUsed(e, l.name) || (o.isFor(l, e) || (i.warn(\"Plugin.use:\", o.toString(l), \"is for\", l.for, \"but installed on\", o.toString(e) + \".\"), l._warned = !0), l.install ? l.install(e) : (i.warn(\"Plugin.use:\", o.toString(l), \"does not specify an install function.\"), l._warned = !0), l._warned ? (s.push(\" \" + o.toString(l)), delete l._warned) : s.push(\" \" + o.toString(l)), e.used.push(l.name)) : s.push(\" \" + r[a]);\n            }\n          }s.length > 0 && i.info(s.join(\"  \"));\n        }, o.dependencies = function (e, t) {\n          var n = o.dependencyParse(e),\n              r = n.name;if (t = t || {}, !(r in t)) {\n            e = o.resolve(e) || e, t[r] = i.map(e.uses || [], function (t) {\n              o.isPlugin(t) && o.register(t);var r = o.dependencyParse(t),\n                  s = o.resolve(t);return s && !o.versionSatisfies(s.version, r.range) ? (i.warn(\"Plugin.dependencies:\", o.toString(s), \"does not satisfy\", o.toString(r), \"used by\", o.toString(n) + \".\"), s._warned = !0, e._warned = !0) : s || (i.warn(\"Plugin.dependencies:\", o.toString(t), \"used by\", o.toString(n), \"could not be resolved.\"), e._warned = !0), r.name;\n            });for (var s = 0; s < t[r].length; s += 1) {\n              o.dependencies(t[r][s], t);\n            }return t;\n          }\n        }, o.dependencyParse = function (e) {\n          if (i.isString(e)) {\n            var t = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/;return t.test(e) || i.warn(\"Plugin.dependencyParse:\", e, \"is not a valid dependency string.\"), { name: e.split(\"@\")[0], range: e.split(\"@\")[1] || \"*\" };\n          }return { name: e.name, range: e.range || e.version };\n        }, o.versionParse = function (e) {\n          var t = /^\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?$/;t.test(e) || i.warn(\"Plugin.versionParse:\", e, \"is not a valid version or range.\");var n = e.split(\"-\");e = n[0];var o = isNaN(Number(e[0])),\n              r = o ? e.substr(1) : e,\n              s = i.map(r.split(\".\"), function (e) {\n            return Number(e);\n          });return { isRange: o, version: r, range: e, operator: o ? e[0] : \"\", parts: s, prerelease: n[1], number: 1e8 * s[0] + 1e4 * s[1] + s[2] };\n        }, o.versionSatisfies = function (e, t) {\n          t = t || \"*\";var n = o.versionParse(t),\n              i = n.parts,\n              r = o.versionParse(e),\n              s = r.parts;if (n.isRange) {\n            if (\"*\" === n.operator || \"*\" === e) return !0;if (\"~\" === n.operator) return s[0] === i[0] && s[1] === i[1] && s[2] >= i[2];if (\"^\" === n.operator) return i[0] > 0 ? s[0] === i[0] && r.number >= n.number : i[1] > 0 ? s[1] === i[1] && s[2] >= i[2] : s[2] === i[2];\n          }return e === t || \"*\" === e;\n        };\n      }();\n    }, { \"./Common\": 14 }], 21: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Events\"),\n          r = e(\"./Engine\"),\n          s = e(\"./Common\");!function () {\n        var e, t;if (\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), !e) {\n          var n;e = function e(_e7) {\n            n = setTimeout(function () {\n              _e7(s.now());\n            }, 1e3 / 60);\n          }, t = function t() {\n            clearTimeout(n);\n          };\n        }o.create = function (e) {\n          var t = { fps: 60, correction: 1, deltaSampleSize: 60, counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: !1, enabled: !0 },\n              n = s.extend(t, e);return n.delta = n.delta || 1e3 / n.fps, n.deltaMin = n.deltaMin || 1e3 / n.fps, n.deltaMax = n.deltaMax || 1e3 / (.5 * n.fps), n.fps = 1e3 / n.delta, n;\n        }, o.run = function (t, n) {\n          return \"undefined\" != typeof t.positionIterations && (n = t, t = o.create()), function i(r) {\n            t.frameRequestId = e(i), r && t.enabled && o.tick(t, n, r);\n          }(), t;\n        }, o.tick = function (e, t, n) {\n          var o,\n              s = t.timing,\n              a = 1,\n              l = { timestamp: s.timestamp };i.trigger(e, \"beforeTick\", l), i.trigger(t, \"beforeTick\", l), e.isFixed ? o = e.delta : (o = n - e.timePrev || e.delta, e.timePrev = n, e.deltaHistory.push(o), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), o = Math.min.apply(null, e.deltaHistory), o = o < e.deltaMin ? e.deltaMin : o, o = o > e.deltaMax ? e.deltaMax : o, a = o / e.delta, e.delta = o), 0 !== e.timeScalePrev && (a *= s.timeScale / e.timeScalePrev), 0 === s.timeScale && (a = 0), e.timeScalePrev = s.timeScale, e.correction = a, e.frameCounter += 1, n - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((n - e.counterTimestamp) / 1e3), e.counterTimestamp = n, e.frameCounter = 0), i.trigger(e, \"tick\", l), i.trigger(t, \"tick\", l), t.world.isModified && t.render && t.render.controller && t.render.controller.clear && t.render.controller.clear(t.render), i.trigger(e, \"beforeUpdate\", l), r.update(t, o, a), i.trigger(e, \"afterUpdate\", l), t.render && t.render.controller && (i.trigger(e, \"beforeRender\", l), i.trigger(t, \"beforeRender\", l), t.render.controller.world(t.render), i.trigger(e, \"afterRender\", l), i.trigger(t, \"afterRender\", l)), i.trigger(e, \"afterTick\", l), i.trigger(t, \"afterTick\", l);\n        }, o.stop = function (e) {\n          t(e.frameRequestId);\n        }, o.start = function (e, t) {\n          o.run(e, t);\n        };\n      }();\n    }, { \"./Common\": 14, \"./Engine\": 15, \"./Events\": 16 }], 22: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"./Events\");!function () {\n        o._motionWakeThreshold = .18, o._motionSleepThreshold = .08, o._minBias = .9, o.update = function (e, t) {\n          for (var n = t * t * t, i = 0; i < e.length; i++) {\n            var r = e[i],\n                s = r.speed * r.speed + r.angularSpeed * r.angularSpeed;if (0 === r.force.x && 0 === r.force.y) {\n              var a = Math.min(r.motion, s),\n                  l = Math.max(r.motion, s);r.motion = o._minBias * a + (1 - o._minBias) * l, r.sleepThreshold > 0 && r.motion < o._motionSleepThreshold * n ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && o.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1);\n            } else o.set(r, !1);\n          }\n        }, o.afterCollisions = function (e, t) {\n          for (var n = t * t * t, i = 0; i < e.length; i++) {\n            var r = e[i];if (r.isActive) {\n              var s = r.collision,\n                  a = s.bodyA.parent,\n                  l = s.bodyB.parent;if (!(a.isSleeping && l.isSleeping || a.isStatic || l.isStatic) && (a.isSleeping || l.isSleeping)) {\n                var c = a.isSleeping && !a.isStatic ? a : l,\n                    d = c === a ? l : a;!c.isStatic && d.motion > o._motionWakeThreshold * n && o.set(c, !1);\n              }\n            }\n          }\n        }, o.set = function (e, t) {\n          var n = e.isSleeping;t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, n || i.trigger(e, \"sleepStart\")) : (e.isSleeping = !1, e.sleepCounter = 0, n && i.trigger(e, \"sleepEnd\"));\n        };\n      }();\n    }, { \"./Events\": 16 }], 23: [function (e, t, n) {\n      (function (n) {\n        var o = {};t.exports = o;var i = e(\"../geometry/Vertices\"),\n            r = e(\"../core/Common\"),\n            s = e(\"../body/Body\"),\n            a = e(\"../geometry/Bounds\"),\n            l = e(\"../geometry/Vector\"),\n            c = \"undefined\" != typeof window ? window.decomp : \"undefined\" != typeof n ? n.decomp : null;!function () {\n          o.rectangle = function (e, t, n, o, a) {\n            a = a || {};var l = { label: \"Rectangle Body\", position: { x: e, y: t }, vertices: i.fromPath(\"L 0 0 L \" + n + \" 0 L \" + n + \" \" + o + \" L 0 \" + o) };if (a.chamfer) {\n              var c = a.chamfer;l.vertices = i.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete a.chamfer;\n            }return s.create(r.extend({}, l, a));\n          }, o.trapezoid = function (e, t, n, o, a, l) {\n            l = l || {}, a *= .5;var c,\n                d = (1 - 2 * a) * n,\n                u = n * a,\n                p = u + d,\n                f = p + u;c = a < .5 ? \"L 0 0 L \" + u + \" \" + -o + \" L \" + p + \" \" + -o + \" L \" + f + \" 0\" : \"L 0 0 L \" + p + \" \" + -o + \" L \" + f + \" 0\";var m = { label: \"Trapezoid Body\", position: { x: e, y: t }, vertices: i.fromPath(c) };if (l.chamfer) {\n              var v = l.chamfer;m.vertices = i.chamfer(m.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer;\n            }return s.create(r.extend({}, m, l));\n          }, o.circle = function (e, t, n, i, s) {\n            i = i || {};var a = { label: \"Circle Body\", circleRadius: n };s = s || 25;var l = Math.ceil(Math.max(10, Math.min(s, n)));return l % 2 === 1 && (l += 1), o.polygon(e, t, l, n, r.extend({}, a, i));\n          }, o.polygon = function (e, t, n, a, l) {\n            if (l = l || {}, n < 3) return o.circle(e, t, a, l);for (var c = 2 * Math.PI / n, d = \"\", u = .5 * c, p = 0; p < n; p += 1) {\n              var f = u + p * c,\n                  m = Math.cos(f) * a,\n                  v = Math.sin(f) * a;d += \"L \" + m.toFixed(3) + \" \" + v.toFixed(3) + \" \";\n            }var y = { label: \"Polygon Body\", position: { x: e, y: t }, vertices: i.fromPath(d) };if (l.chamfer) {\n              var g = l.chamfer;y.vertices = i.chamfer(y.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete l.chamfer;\n            }return s.create(r.extend({}, y, l));\n          }, o.fromVertices = function (e, t, n, o, d, u, p) {\n            var f, m, v, y, g, x, h, b, w;for (o = o || {}, m = [], d = \"undefined\" != typeof d && d, u = \"undefined\" != typeof u ? u : .01, p = \"undefined\" != typeof p ? p : 10, c || r.warn(\"Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.\"), r.isArray(n[0]) || (n = [n]), b = 0; b < n.length; b += 1) {\n              if (y = n[b], v = i.isConvex(y), v || !c) y = v ? i.clockwiseSort(y) : i.hull(y), m.push({ position: { x: e, y: t }, vertices: y });else {\n                var S = y.map(function (e) {\n                  return [e.x, e.y];\n                });c.makeCCW(S), u !== !1 && c.removeCollinearPoints(S, u);var C = c.quickDecomp(S);for (g = 0; g < C.length; g++) {\n                  var A = C[g],\n                      P = A.map(function (e) {\n                    return { x: e[0], y: e[1] };\n                  });p > 0 && i.area(P) < p || m.push({ position: i.centre(P), vertices: P });\n                }\n              }\n            }for (g = 0; g < m.length; g++) {\n              m[g] = s.create(r.extend(m[g], o));\n            }if (d) {\n              var B = 5;for (g = 0; g < m.length; g++) {\n                var M = m[g];for (x = g + 1; x < m.length; x++) {\n                  var k = m[x];if (a.overlaps(M.bounds, k.bounds)) {\n                    var I = M.vertices,\n                        T = k.vertices;for (h = 0; h < M.vertices.length; h++) {\n                      for (w = 0; w < k.vertices.length; w++) {\n                        var V = l.magnitudeSquared(l.sub(I[(h + 1) % I.length], T[w])),\n                            _ = l.magnitudeSquared(l.sub(I[h], T[(w + 1) % T.length]));V < B && _ < B && (I[h].isInternal = !0, T[w].isInternal = !0);\n                      }\n                    }\n                  }\n                }\n              }\n            }return m.length > 1 ? (f = s.create(r.extend({ parts: m.slice(0) }, o)), s.setPosition(f, { x: e, y: t }), f) : m[0];\n          };\n        }();\n      }).call(this, \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n    }, { \"../body/Body\": 1, \"../core/Common\": 14, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29 }], 24: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../body/Composite\"),\n          r = e(\"../constraint/Constraint\"),\n          s = e(\"../core/Common\"),\n          a = e(\"../body/Body\"),\n          l = e(\"./Bodies\");!function () {\n        o.stack = function (e, t, n, o, r, s, l) {\n          for (var c, d = i.create({ label: \"Stack\" }), u = e, p = t, f = 0, m = 0; m < o; m++) {\n            for (var v = 0, y = 0; y < n; y++) {\n              var g = l(u, p, y, m, c, f);if (g) {\n                var x = g.bounds.max.y - g.bounds.min.y,\n                    h = g.bounds.max.x - g.bounds.min.x;x > v && (v = x), a.translate(g, { x: .5 * h, y: .5 * x }), u = g.bounds.max.x + r, i.addBody(d, g), c = g, f += 1;\n              } else u += r;\n            }p += v + s, u = e;\n          }return d;\n        }, o.chain = function (e, t, n, o, a, l) {\n          for (var c = e.bodies, d = 1; d < c.length; d++) {\n            var u = c[d - 1],\n                p = c[d],\n                f = u.bounds.max.y - u.bounds.min.y,\n                m = u.bounds.max.x - u.bounds.min.x,\n                v = p.bounds.max.y - p.bounds.min.y,\n                y = p.bounds.max.x - p.bounds.min.x,\n                g = { bodyA: u, pointA: { x: m * t, y: f * n }, bodyB: p, pointB: { x: y * o, y: v * a } },\n                x = s.extend(g, l);i.addConstraint(e, r.create(x));\n          }return e.label += \" Chain\", e;\n        }, o.mesh = function (e, t, n, o, a) {\n          var l,\n              c,\n              d,\n              u,\n              p,\n              f = e.bodies;for (l = 0; l < n; l++) {\n            for (c = 1; c < t; c++) {\n              d = f[c - 1 + l * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({ bodyA: d, bodyB: u }, a)));\n            }if (l > 0) for (c = 0; c < t; c++) {\n              d = f[c + (l - 1) * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({ bodyA: d, bodyB: u }, a))), o && c > 0 && (p = f[c - 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({ bodyA: p, bodyB: u }, a)))), o && c < t - 1 && (p = f[c + 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({ bodyA: p, bodyB: u }, a))));\n            }\n          }return e.label += \" Mesh\", e;\n        }, o.pyramid = function (e, t, n, i, r, s, l) {\n          return o.stack(e, t, n, i, r, s, function (t, o, s, c, d, u) {\n            var p = Math.min(i, Math.ceil(n / 2)),\n                f = d ? d.bounds.max.x - d.bounds.min.x : 0;if (!(c > p)) {\n              c = p - c;var m = c,\n                  v = n - 1 - c;if (!(s < m || s > v)) {\n                1 === u && a.translate(d, { x: (s + (n % 2 === 1 ? 1 : -1)) * f, y: 0 });var y = d ? s * f : 0;return l(e + y + s * r, o, s, c, d, u);\n              }\n            }\n          });\n        }, o.newtonsCradle = function (e, t, n, o, s) {\n          for (var a = i.create({ label: \"Newtons Cradle\" }), c = 0; c < n; c++) {\n            var d = 1.9,\n                u = l.circle(e + c * (o * d), t + s, o, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }),\n                p = r.create({ pointA: { x: e + c * (o * d), y: t }, bodyB: u });i.addBody(a, u), i.addConstraint(a, p);\n          }return a;\n        }, o.car = function (e, t, n, o, s) {\n          var c = a.nextGroup(!0),\n              d = 20,\n              u = .5 * -n + d,\n              p = .5 * n - d,\n              f = 0,\n              m = i.create({ label: \"Car\" }),\n              v = l.rectangle(e, t, n, o, { collisionFilter: { group: c }, chamfer: { radius: .5 * o }, density: 2e-4 }),\n              y = l.circle(e + u, t + f, s, { collisionFilter: { group: c }, friction: .8 }),\n              g = l.circle(e + p, t + f, s, { collisionFilter: { group: c }, friction: .8 }),\n              x = r.create({ bodyB: v, pointB: { x: u, y: f }, bodyA: y, stiffness: 1, length: 0 }),\n              h = r.create({ bodyB: v, pointB: { x: p, y: f }, bodyA: g, stiffness: 1, length: 0 });return i.addBody(m, v), i.addBody(m, y), i.addBody(m, g), i.addConstraint(m, x), i.addConstraint(m, h), m;\n        }, o.softBody = function (e, t, n, i, r, a, c, d, u, p) {\n          u = s.extend({ inertia: 1 / 0 }, u), p = s.extend({\n            stiffness: .2, render: { type: \"line\", anchors: !1 } }, p);var f = o.stack(e, t, n, i, r, a, function (e, t) {\n            return l.circle(e, t, d, u);\n          });return o.mesh(f, n, i, c, p), f.label = \"Soft Body\", f;\n        };\n      }();\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../constraint/Constraint\": 12, \"../core/Common\": 14, \"./Bodies\": 23 }], 25: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vector\"),\n          r = e(\"../core/Common\");!function () {\n        o.fromVertices = function (e) {\n          for (var t = {}, n = 0; n < e.length; n++) {\n            var o = (n + 1) % e.length,\n                s = i.normalise({ x: e[o].y - e[n].y, y: e[n].x - e[o].x }),\n                a = 0 === s.y ? 1 / 0 : s.x / s.y;a = a.toFixed(3).toString(), t[a] = s;\n          }return r.values(t);\n        }, o.rotate = function (e, t) {\n          if (0 !== t) for (var n = Math.cos(t), o = Math.sin(t), i = 0; i < e.length; i++) {\n            var r,\n                s = e[i];r = s.x * n - s.y * o, s.y = s.x * o + s.y * n, s.x = r;\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Vector\": 28 }], 26: [function (e, t, n) {\n      var o = {};t.exports = o, function () {\n        o.create = function (e) {\n          var t = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } };return e && o.update(t, e), t;\n        }, o.update = function (e, t, n) {\n          e.min.x = 1 / 0, e.max.x = -(1 / 0), e.min.y = 1 / 0, e.max.y = -(1 / 0);for (var o = 0; o < t.length; o++) {\n            var i = t[o];i.x > e.max.x && (e.max.x = i.x), i.x < e.min.x && (e.min.x = i.x), i.y > e.max.y && (e.max.y = i.y), i.y < e.min.y && (e.min.y = i.y);\n          }n && (n.x > 0 ? e.max.x += n.x : e.min.x += n.x, n.y > 0 ? e.max.y += n.y : e.min.y += n.y);\n        }, o.contains = function (e, t) {\n          return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y;\n        }, o.overlaps = function (e, t) {\n          return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y;\n        }, o.translate = function (e, t) {\n          e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y;\n        }, o.shift = function (e, t) {\n          var n = e.max.x - e.min.x,\n              o = e.max.y - e.min.y;e.min.x = t.x, e.max.x = t.x + n, e.min.y = t.y, e.max.y = t.y + o;\n        };\n      }();\n    }, {}], 27: [function (e, t, n) {\n      var o = {};t.exports = o;e(\"../geometry/Bounds\");!function () {\n        o.pathToVertices = function (t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f,\n              m,\n              v = [],\n              y = 0,\n              g = 0,\n              x = 0;n = n || 15;var h = function h(e, t, n) {\n            var o = n % 2 === 1 && n > 1;if (!u || e != u.x || t != u.y) {\n              u && o ? (f = u.x, m = u.y) : (f = 0, m = 0);var i = { x: f + e, y: m + t };!o && u || (u = i), v.push(i), g = f + e, x = m + t;\n            }\n          },\n              b = function b(e) {\n            var t = e.pathSegTypeAsLetter.toUpperCase();if (\"Z\" !== t) {\n              switch (t) {case \"M\":case \"L\":case \"T\":case \"C\":\n                case \"S\":case \"Q\":\n                  g = e.x, x = e.y;break;case \"H\":\n                  g = e.x;break;case \"V\":\n                  x = e.y;}h(g, x, e.pathSegType);\n            }\n          };for (e(t), r = t.getTotalLength(), l = [], o = 0; o < t.pathSegList.numberOfItems; o += 1) {\n            l.push(t.pathSegList.getItem(o));\n          }for (c = l.concat(); y < r;) {\n            if (p = t.getPathSegAtLength(y), a = l[p], a != d) {\n              for (; c.length && c[0] != a;) {\n                b(c.shift());\n              }d = a;\n            }switch (a.pathSegTypeAsLetter.toUpperCase()) {case \"C\":case \"T\":case \"S\":case \"Q\":case \"A\":\n                s = t.getPointAtLength(y), h(s.x, s.y, 0);}y += n;\n          }for (o = 0, i = c.length; o < i; ++o) {\n            b(c[o]);\n          }return v;\n        };var e = function e(_e8) {\n          for (var t, n, o, i, r, s, a = _e8.pathSegList, l = 0, c = 0, d = a.numberOfItems, u = 0; u < d; ++u) {\n            var p = a.getItem(u),\n                f = p.pathSegTypeAsLetter;if (/[MLHVCSQTA]/.test(f)) \"x\" in p && (l = p.x), \"y\" in p && (c = p.y);else switch (\"x1\" in p && (o = l + p.x1), \"x2\" in p && (r = l + p.x2), \"y1\" in p && (i = c + p.y1), \"y2\" in p && (s = c + p.y2), \"x\" in p && (l += p.x), \"y\" in p && (c += p.y), f) {case \"m\":\n                a.replaceItem(_e8.createSVGPathSegMovetoAbs(l, c), u);break;case \"l\":\n                a.replaceItem(_e8.createSVGPathSegLinetoAbs(l, c), u);break;case \"h\":\n                a.replaceItem(_e8.createSVGPathSegLinetoHorizontalAbs(l), u);break;\n              case \"v\":\n                a.replaceItem(_e8.createSVGPathSegLinetoVerticalAbs(c), u);break;case \"c\":\n                a.replaceItem(_e8.createSVGPathSegCurvetoCubicAbs(l, c, o, i, r, s), u);break;case \"s\":\n                a.replaceItem(_e8.createSVGPathSegCurvetoCubicSmoothAbs(l, c, r, s), u);break;case \"q\":\n                a.replaceItem(_e8.createSVGPathSegCurvetoQuadraticAbs(l, c, o, i), u);break;case \"t\":\n                a.replaceItem(_e8.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), u);break;case \"a\":\n                a.replaceItem(_e8.createSVGPathSegArcAbs(l, c, p.r1, p.r2, p.angle, p.largeArcFlag, p.sweepFlag), u);break;case \"z\":case \"Z\":\n                l = t, c = n;}\"M\" != f && \"m\" != f || (t = l, n = c);\n          }\n        };\n      }();\n    }, { \"../geometry/Bounds\": 26 }], 28: [function (e, t, n) {\n      var o = {};t.exports = o, function () {\n        o.create = function (e, t) {\n          return { x: e || 0, y: t || 0 };\n        }, o.clone = function (e) {\n          return { x: e.x, y: e.y };\n        }, o.magnitude = function (e) {\n          return Math.sqrt(e.x * e.x + e.y * e.y);\n        }, o.magnitudeSquared = function (e) {\n          return e.x * e.x + e.y * e.y;\n        }, o.rotate = function (e, t, n) {\n          var o = Math.cos(t),\n              i = Math.sin(t);n || (n = {});var r = e.x * o - e.y * i;return n.y = e.x * i + e.y * o, n.x = r, n;\n        }, o.rotateAbout = function (e, t, n, o) {\n          var i = Math.cos(t),\n              r = Math.sin(t);\n          o || (o = {});var s = n.x + ((e.x - n.x) * i - (e.y - n.y) * r);return o.y = n.y + ((e.x - n.x) * r + (e.y - n.y) * i), o.x = s, o;\n        }, o.normalise = function (e) {\n          var t = o.magnitude(e);return 0 === t ? { x: 0, y: 0 } : { x: e.x / t, y: e.y / t };\n        }, o.dot = function (e, t) {\n          return e.x * t.x + e.y * t.y;\n        }, o.cross = function (e, t) {\n          return e.x * t.y - e.y * t.x;\n        }, o.cross3 = function (e, t, n) {\n          return (t.x - e.x) * (n.y - e.y) - (t.y - e.y) * (n.x - e.x);\n        }, o.add = function (e, t, n) {\n          return n || (n = {}), n.x = e.x + t.x, n.y = e.y + t.y, n;\n        }, o.sub = function (e, t, n) {\n          return n || (n = {}), n.x = e.x - t.x, n.y = e.y - t.y, n;\n        }, o.mult = function (e, t) {\n          return { x: e.x * t, y: e.y * t };\n        }, o.div = function (e, t) {\n          return { x: e.x / t, y: e.y / t };\n        }, o.perp = function (e, t) {\n          return t = t === !0 ? -1 : 1, { x: t * -e.y, y: t * e.x };\n        }, o.neg = function (e) {\n          return { x: -e.x, y: -e.y };\n        }, o.angle = function (e, t) {\n          return Math.atan2(t.y - e.y, t.x - e.x);\n        }, o._temp = [o.create(), o.create(), o.create(), o.create(), o.create(), o.create()];\n      }();\n    }, {}], 29: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Vector\"),\n          r = e(\"../core/Common\");!function () {\n        o.create = function (e, t) {\n          for (var n = [], o = 0; o < e.length; o++) {\n            var i = e[o],\n                r = { x: i.x, y: i.y, index: o,\n              body: t, isInternal: !1 };n.push(r);\n          }return n;\n        }, o.fromPath = function (e, t) {\n          var n = /L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/gi,\n              i = [];return e.replace(n, function (e, t, n) {\n            i.push({ x: parseFloat(t), y: parseFloat(n) });\n          }), o.create(i, t);\n        }, o.centre = function (e) {\n          for (var t, n, r, s = o.area(e, !0), a = { x: 0, y: 0 }, l = 0; l < e.length; l++) {\n            r = (l + 1) % e.length, t = i.cross(e[l], e[r]), n = i.mult(i.add(e[l], e[r]), t), a = i.add(a, n);\n          }return i.div(a, 6 * s);\n        }, o.mean = function (e) {\n          for (var t = { x: 0, y: 0 }, n = 0; n < e.length; n++) {\n            t.x += e[n].x, t.y += e[n].y;\n          }return i.div(t, e.length);\n        }, o.area = function (e, t) {\n          for (var n = 0, o = e.length - 1, i = 0; i < e.length; i++) {\n            n += (e[o].x - e[i].x) * (e[o].y + e[i].y), o = i;\n          }return t ? n / 2 : Math.abs(n) / 2;\n        }, o.inertia = function (e, t) {\n          for (var n, o, r = 0, s = 0, a = e, l = 0; l < a.length; l++) {\n            o = (l + 1) % a.length, n = Math.abs(i.cross(a[o], a[l])), r += n * (i.dot(a[o], a[o]) + i.dot(a[o], a[l]) + i.dot(a[l], a[l])), s += n;\n          }return t / 6 * (r / s);\n        }, o.translate = function (e, t, n) {\n          var o;if (n) for (o = 0; o < e.length; o++) {\n            e[o].x += t.x * n, e[o].y += t.y * n;\n          } else for (o = 0; o < e.length; o++) {\n            e[o].x += t.x, e[o].y += t.y;\n          }return e;\n        }, o.rotate = function (e, t, n) {\n          if (0 !== t) {\n            for (var o = Math.cos(t), i = Math.sin(t), r = 0; r < e.length; r++) {\n              var s = e[r],\n                  a = s.x - n.x,\n                  l = s.y - n.y;s.x = n.x + (a * o - l * i), s.y = n.y + (a * i + l * o);\n            }return e;\n          }\n        }, o.contains = function (e, t) {\n          for (var n = 0; n < e.length; n++) {\n            var o = e[n],\n                i = e[(n + 1) % e.length];if ((t.x - o.x) * (i.y - o.y) + (t.y - o.y) * (o.x - i.x) > 0) return !1;\n          }return !0;\n        }, o.scale = function (e, t, n, r) {\n          if (1 === t && 1 === n) return e;r = r || o.centre(e);for (var s, a, l = 0; l < e.length; l++) {\n            s = e[l], a = i.sub(s, r), e[l].x = r.x + a.x * t, e[l].y = r.y + a.y * n;\n          }return e;\n        }, o.chamfer = function (e, t, n, o, s) {\n          t = t || [8], t.length || (t = [t]), n = \"undefined\" != typeof n ? n : -1, o = o || 2, s = s || 14;for (var a = [], l = 0; l < e.length; l++) {\n            var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],\n                d = e[l],\n                u = e[(l + 1) % e.length],\n                p = t[l < t.length ? l : t.length - 1];if (0 !== p) {\n              var f = i.normalise({ x: d.y - c.y, y: c.x - d.x }),\n                  m = i.normalise({ x: u.y - d.y, y: d.x - u.x }),\n                  v = Math.sqrt(2 * Math.pow(p, 2)),\n                  y = i.mult(r.clone(f), p),\n                  g = i.normalise(i.mult(i.add(f, m), .5)),\n                  x = i.sub(d, i.mult(g, v)),\n                  h = n;n === -1 && (h = 1.75 * Math.pow(p, .32)), h = r.clamp(h, o, s), h % 2 === 1 && (h += 1);for (var b = Math.acos(i.dot(f, m)), w = b / h, S = 0; S < h; S++) {\n                a.push(i.add(i.rotate(y, w * S), x));\n              }\n            } else a.push(d);\n          }return a;\n        }, o.clockwiseSort = function (e) {\n          var t = o.mean(e);return e.sort(function (e, n) {\n            return i.angle(t, e) - i.angle(t, n);\n          }), e;\n        }, o.isConvex = function (e) {\n          var t,\n              n,\n              o,\n              i,\n              r = 0,\n              s = e.length;if (s < 3) return null;for (t = 0; t < s; t++) {\n            if (n = (t + 1) % s, o = (t + 2) % s, i = (e[n].x - e[t].x) * (e[o].y - e[n].y), i -= (e[n].y - e[t].y) * (e[o].x - e[n].x), i < 0 ? r |= 1 : i > 0 && (r |= 2), 3 === r) return !1;\n          }return 0 !== r || null;\n        }, o.hull = function (e) {\n          var t,\n              n,\n              o = [],\n              r = [];for (e = e.slice(0), e.sort(function (e, t) {\n            var n = e.x - t.x;return 0 !== n ? n : e.y - t.y;\n          }), n = 0; n < e.length; n += 1) {\n            for (t = e[n]; r.length >= 2 && i.cross3(r[r.length - 2], r[r.length - 1], t) <= 0;) {\n              r.pop();\n            }r.push(t);\n          }for (n = e.length - 1; n >= 0; n -= 1) {\n            for (t = e[n]; o.length >= 2 && i.cross3(o[o.length - 2], o[o.length - 1], t) <= 0;) {\n              o.pop();\n            }o.push(t);\n          }return o.pop(), r.pop(), o.concat(r);\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Vector\": 28 }], 30: [function (e, t, n) {\n      var o = t.exports = e(\"../core/Matter\");o.Body = e(\"../body/Body\"), o.Composite = e(\"../body/Composite\"), o.World = e(\"../body/World\"), o.Contact = e(\"../collision/Contact\"), o.Detector = e(\"../collision/Detector\"), o.Grid = e(\"../collision/Grid\"), o.Pairs = e(\"../collision/Pairs\"), o.Pair = e(\"../collision/Pair\"), o.Query = e(\"../collision/Query\"), o.Resolver = e(\"../collision/Resolver\"), o.SAT = e(\"../collision/SAT\"), o.Constraint = e(\"../constraint/Constraint\"), o.MouseConstraint = e(\"../constraint/MouseConstraint\"), o.Common = e(\"../core/Common\"), o.Engine = e(\"../core/Engine\"), o.Events = e(\"../core/Events\"), o.Mouse = e(\"../core/Mouse\"), o.Runner = e(\"../core/Runner\"), o.Sleeping = e(\"../core/Sleeping\"), o.Plugin = e(\"../core/Plugin\"), o.Bodies = e(\"../factory/Bodies\"), o.Composites = e(\"../factory/Composites\"), o.Axes = e(\"../geometry/Axes\"), o.Bounds = e(\"../geometry/Bounds\"), o.Svg = e(\"../geometry/Svg\"), o.Vector = e(\"../geometry/Vector\"), o.Vertices = e(\"../geometry/Vertices\"), o.Render = e(\"../render/Render\"), o.RenderPixi = e(\"../render/RenderPixi\"), o.World.add = o.Composite.add, o.World.remove = o.Composite.remove, o.World.addComposite = o.Composite.addComposite, o.World.addBody = o.Composite.addBody, o.World.addConstraint = o.Composite.addConstraint, o.World.clear = o.Composite.clear, o.Engine.run = o.Runner.run;\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../body/World\": 3, \"../collision/Contact\": 4, \"../collision/Detector\": 5, \"../collision/Grid\": 6, \"../collision/Pair\": 7, \"../collision/Pairs\": 8, \"../collision/Query\": 9, \"../collision/Resolver\": 10, \"../collision/SAT\": 11, \"../constraint/Constraint\": 12, \"../constraint/MouseConstraint\": 13, \"../core/Common\": 14, \"../core/Engine\": 15, \"../core/Events\": 16, \"../core/Matter\": 17, \"../core/Metrics\": 18, \"../core/Mouse\": 19, \"../core/Plugin\": 20, \"../core/Runner\": 21, \"../core/Sleeping\": 22, \"../factory/Bodies\": 23, \"../factory/Composites\": 24, \"../geometry/Axes\": 25, \"../geometry/Bounds\": 26, \"../geometry/Svg\": 27, \"../geometry/Vector\": 28, \"../geometry/Vertices\": 29, \"../render/Render\": 31, \"../render/RenderPixi\": 32 }], 31: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../core/Common\"),\n          r = e(\"../body/Composite\"),\n          s = e(\"../geometry/Bounds\"),\n          a = e(\"../core/Events\"),\n          l = e(\"../collision/Grid\"),\n          c = e(\"../geometry/Vector\"),\n          d = e(\"../core/Mouse\");!function () {\n        var e, t;\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          window.setTimeout(function () {\n            e(i.now());\n          }, 1e3 / 60);\n        }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), o.create = function (e) {\n          var t = { controller: o, engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, options: { width: 800, height: 600, pixelRatio: 1, background: \"#18181d\", wireframeBackground: \"#0f0f13\", hasBounds: !!e.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } },\n              r = i.extend(t, e);return r.canvas && (r.canvas.width = r.options.width || r.canvas.width, r.canvas.height = r.options.height || r.canvas.height), r.mouse = e.mouse, r.engine = e.engine, r.canvas = r.canvas || n(r.options.width, r.options.height), r.context = r.canvas.getContext(\"2d\"), r.textures = {}, r.bounds = r.bounds || { min: { x: 0,\n              y: 0 }, max: { x: r.canvas.width, y: r.canvas.height } }, 1 !== r.options.pixelRatio && o.setPixelRatio(r, r.options.pixelRatio), i.isElement(r.element) ? r.element.appendChild(r.canvas) : i.log(\"Render.create: options.element was undefined, render.canvas was created but not appended\", \"warn\"), r;\n        }, o.run = function (t) {\n          !function n(i) {\n            t.frameRequestId = e(n), o.world(t);\n          }();\n        }, o.stop = function (e) {\n          t(e.frameRequestId);\n        }, o.setPixelRatio = function (e, t) {\n          var n = e.options,\n              o = e.canvas;\"auto\" === t && (t = u(o)), n.pixelRatio = t, o.setAttribute(\"data-pixel-ratio\", t), o.width = n.width * t, o.height = n.height * t, o.style.width = n.width + \"px\", o.style.height = n.height + \"px\", e.context.scale(t, t);\n        }, o.lookAt = function (e, t, n, o) {\n          o = \"undefined\" == typeof o || o, t = i.isArray(t) ? t : [t], n = n || { x: 0, y: 0 };for (var r = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -(1 / 0), y: -(1 / 0) } }, s = 0; s < t.length; s += 1) {\n            var a = t[s],\n                l = a.bounds ? a.bounds.min : a.min || a.position || a,\n                c = a.bounds ? a.bounds.max : a.max || a.position || a;l && c && (l.x < r.min.x && (r.min.x = l.x), c.x > r.max.x && (r.max.x = c.x), l.y < r.min.y && (r.min.y = l.y), c.y > r.max.y && (r.max.y = c.y));\n          }var u = r.max.x - r.min.x + 2 * n.x,\n              p = r.max.y - r.min.y + 2 * n.y,\n              f = e.canvas.height,\n              m = e.canvas.width,\n              v = m / f,\n              y = u / p,\n              g = 1,\n              x = 1;y > v ? x = y / v : g = v / y, e.options.hasBounds = !0, e.bounds.min.x = r.min.x, e.bounds.max.x = r.min.x + u * g, e.bounds.min.y = r.min.y, e.bounds.max.y = r.min.y + p * x, o && (e.bounds.min.x += .5 * u - u * g * .5, e.bounds.max.x += .5 * u - u * g * .5, e.bounds.min.y += .5 * p - p * x * .5, e.bounds.max.y += .5 * p - p * x * .5), e.bounds.min.x -= n.x, e.bounds.max.x -= n.x, e.bounds.min.y -= n.y, e.bounds.max.y -= n.y, e.mouse && (d.setScale(e.mouse, { x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width, y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height }), d.setOffset(e.mouse, e.bounds.min));\n        }, o.startViewTransform = function (e) {\n          var t = e.bounds.max.x - e.bounds.min.x,\n              n = e.bounds.max.y - e.bounds.min.y,\n              o = t / e.options.width,\n              i = n / e.options.height;e.context.scale(1 / o, 1 / i), e.context.translate(-e.bounds.min.x, -e.bounds.min.y);\n        }, o.endViewTransform = function (e) {\n          e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0);\n        }, o.world = function (e) {\n          var t,\n              n = e.engine,\n              i = n.world,\n              u = e.canvas,\n              p = e.context,\n              m = e.options,\n              v = r.allBodies(i),\n              y = r.allConstraints(i),\n              g = m.wireframes ? m.wireframeBackground : m.background,\n              x = [],\n              h = [],\n              b = {\n            timestamp: n.timing.timestamp };if (a.trigger(e, \"beforeRender\", b), e.currentBackground !== g && f(e, g), p.globalCompositeOperation = \"source-in\", p.fillStyle = \"transparent\", p.fillRect(0, 0, u.width, u.height), p.globalCompositeOperation = \"source-over\", m.hasBounds) {\n            for (t = 0; t < v.length; t++) {\n              var w = v[t];s.overlaps(w.bounds, e.bounds) && x.push(w);\n            }for (t = 0; t < y.length; t++) {\n              var S = y[t],\n                  C = S.bodyA,\n                  A = S.bodyB,\n                  P = S.pointA,\n                  B = S.pointB;C && (P = c.add(C.position, S.pointA)), A && (B = c.add(A.position, S.pointB)), P && B && (s.contains(e.bounds, P) || s.contains(e.bounds, B)) && h.push(S);\n            }o.startViewTransform(e), e.mouse && (d.setScale(e.mouse, { x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width, y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height }), d.setOffset(e.mouse, e.bounds.min));\n          } else h = y, x = v;!m.wireframes || n.enableSleeping && m.showSleeping ? o.bodies(e, x, p) : (m.showConvexHulls && o.bodyConvexHulls(e, x, p), o.bodyWireframes(e, x, p)), m.showBounds && o.bodyBounds(e, x, p), (m.showAxes || m.showAngleIndicator) && o.bodyAxes(e, x, p), m.showPositions && o.bodyPositions(e, x, p), m.showVelocity && o.bodyVelocity(e, x, p), m.showIds && o.bodyIds(e, x, p), m.showSeparations && o.separations(e, n.pairs.list, p), m.showCollisions && o.collisions(e, n.pairs.list, p), m.showVertexNumbers && o.vertexNumbers(e, x, p), m.showMousePosition && o.mousePosition(e, e.mouse, p), o.constraints(h, p), m.showBroadphase && n.broadphase.controller === l && o.grid(e, n.broadphase, p), m.showDebug && o.debug(e, p), m.hasBounds && o.endViewTransform(e), a.trigger(e, \"afterRender\", b);\n        }, o.debug = function (e, t) {\n          var n = t,\n              o = e.engine,\n              i = o.world,\n              s = o.metrics,\n              a = e.options,\n              l = (r.allBodies(i), \"    \");if (o.timing.timestamp - (e.debugTimestamp || 0) >= 500) {\n            var c = \"\";s.timing && (c += \"fps: \" + Math.round(s.timing.fps) + l), e.debugString = c, e.debugTimestamp = o.timing.timestamp;\n          }if (e.debugString) {\n            n.font = \"12px Arial\", a.wireframes ? n.fillStyle = \"rgba(255,255,255,0.5)\" : n.fillStyle = \"rgba(0,0,0,0.5)\";for (var d = e.debugString.split(\"\\n\"), u = 0; u < d.length; u++) {\n              n.fillText(d[u], 50, 50 + 18 * u);\n            }\n          }\n        }, o.constraints = function (e, t) {\n          for (var n = t, o = 0; o < e.length; o++) {\n            var r = e[o];if (r.render.visible && r.pointA && r.pointB) {\n              var s,\n                  a,\n                  l = r.bodyA,\n                  d = r.bodyB;\n              if (s = l ? c.add(l.position, r.pointA) : r.pointA, \"pin\" === r.render.type) n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.closePath();else {\n                if (a = d ? c.add(d.position, r.pointB) : r.pointB, n.beginPath(), n.moveTo(s.x, s.y), \"spring\" === r.render.type) for (var u, p = c.sub(a, s), f = c.perp(c.normalise(p)), m = Math.ceil(i.clamp(r.length / 5, 12, 20)), v = 1; v < m; v += 1) {\n                  u = v % 2 === 0 ? 1 : -1, n.lineTo(s.x + p.x * (v / m) + f.x * u * 4, s.y + p.y * (v / m) + f.y * u * 4);\n                }n.lineTo(a.x, a.y);\n              }r.render.lineWidth && (n.lineWidth = r.render.lineWidth, n.strokeStyle = r.render.strokeStyle, n.stroke()), r.render.anchors && (n.fillStyle = r.render.strokeStyle, n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill());\n            }\n          }\n        }, o.bodyShadows = function (e, t, n) {\n          for (var o = n, i = (e.engine, 0); i < t.length; i++) {\n            var r = t[i];if (r.render.visible) {\n              if (r.circleRadius) o.beginPath(), o.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI), o.closePath();else {\n                o.beginPath(), o.moveTo(r.vertices[0].x, r.vertices[0].y);for (var s = 1; s < r.vertices.length; s++) {\n                  o.lineTo(r.vertices[s].x, r.vertices[s].y);\n                }o.closePath();\n              }var a = r.position.x - .5 * e.options.width,\n                  l = r.position.y - .2 * e.options.height,\n                  c = Math.abs(a) + Math.abs(l);o.shadowColor = \"rgba(0,0,0,0.15)\", o.shadowOffsetX = .05 * a, o.shadowOffsetY = .05 * l, o.shadowBlur = 1 + 12 * Math.min(1, c / 1e3), o.fill(), o.shadowColor = null, o.shadowOffsetX = null, o.shadowOffsetY = null, o.shadowBlur = null;\n            }\n          }\n        }, o.bodies = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a = n,\n              l = (e.engine, e.options),\n              c = l.showInternalEdges || !l.wireframes;for (r = 0; r < t.length; r++) {\n            if (o = t[r], o.render.visible) for (s = o.parts.length > 1 ? 1 : 0; s < o.parts.length; s++) {\n              if (i = o.parts[s], i.render.visible) {\n                if (l.showSleeping && o.isSleeping ? a.globalAlpha = .5 * i.render.opacity : 1 !== i.render.opacity && (a.globalAlpha = i.render.opacity), i.render.sprite && i.render.sprite.texture && !l.wireframes) {\n                  var d = i.render.sprite,\n                      u = p(e, d.texture);a.translate(i.position.x, i.position.y), a.rotate(i.angle), a.drawImage(u, u.width * -d.xOffset * d.xScale, u.height * -d.yOffset * d.yScale, u.width * d.xScale, u.height * d.yScale), a.rotate(-i.angle), a.translate(-i.position.x, -i.position.y);\n                } else {\n                  if (i.circleRadius) a.beginPath(), a.arc(i.position.x, i.position.y, i.circleRadius, 0, 2 * Math.PI);else {\n                    a.beginPath(), a.moveTo(i.vertices[0].x, i.vertices[0].y);for (var f = 1; f < i.vertices.length; f++) {\n                      !i.vertices[f - 1].isInternal || c ? a.lineTo(i.vertices[f].x, i.vertices[f].y) : a.moveTo(i.vertices[f].x, i.vertices[f].y), i.vertices[f].isInternal && !c && a.moveTo(i.vertices[(f + 1) % i.vertices.length].x, i.vertices[(f + 1) % i.vertices.length].y);\n                    }a.lineTo(i.vertices[0].x, i.vertices[0].y), a.closePath();\n                  }l.wireframes ? (a.lineWidth = 1, a.strokeStyle = \"#bbb\", a.stroke()) : (a.fillStyle = i.render.fillStyle, i.render.lineWidth && (a.lineWidth = i.render.lineWidth, a.strokeStyle = i.render.strokeStyle, a.stroke()), a.fill());\n                }a.globalAlpha = 1;\n              }\n            }\n          }\n        }, o.bodyWireframes = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a,\n              l = n,\n              c = e.options.showInternalEdges;for (l.beginPath(), r = 0; r < t.length; r++) {\n            if (o = t[r], o.render.visible) for (a = o.parts.length > 1 ? 1 : 0; a < o.parts.length; a++) {\n              for (i = o.parts[a], l.moveTo(i.vertices[0].x, i.vertices[0].y), s = 1; s < i.vertices.length; s++) {\n                !i.vertices[s - 1].isInternal || c ? l.lineTo(i.vertices[s].x, i.vertices[s].y) : l.moveTo(i.vertices[s].x, i.vertices[s].y), i.vertices[s].isInternal && !c && l.moveTo(i.vertices[(s + 1) % i.vertices.length].x, i.vertices[(s + 1) % i.vertices.length].y);\n              }l.lineTo(i.vertices[0].x, i.vertices[0].y);\n            }\n          }l.lineWidth = 1, l.strokeStyle = \"#bbb\", l.stroke();\n        }, o.bodyConvexHulls = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s = n;for (s.beginPath(), i = 0; i < t.length; i++) {\n            if (o = t[i], o.render.visible && 1 !== o.parts.length) {\n              for (s.moveTo(o.vertices[0].x, o.vertices[0].y), r = 1; r < o.vertices.length; r++) {\n                s.lineTo(o.vertices[r].x, o.vertices[r].y);\n              }s.lineTo(o.vertices[0].x, o.vertices[0].y);\n            }\n          }s.lineWidth = 1, s.strokeStyle = \"rgba(255,255,255,0.2)\", s.stroke();\n        }, o.vertexNumbers = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s = n;for (o = 0; o < t.length; o++) {\n            var a = t[o].parts;for (r = a.length > 1 ? 1 : 0; r < a.length; r++) {\n              var l = a[r];for (i = 0; i < l.vertices.length; i++) {\n                s.fillStyle = \"rgba(255,255,255,0.2)\", s.fillText(o + \"_\" + i, l.position.x + .8 * (l.vertices[i].x - l.position.x), l.position.y + .8 * (l.vertices[i].y - l.position.y));\n              }\n            }\n          }\n        }, o.mousePosition = function (e, t, n) {\n          var o = n;o.fillStyle = \"rgba(255,255,255,0.8)\", o.fillText(t.position.x + \"  \" + t.position.y, t.position.x + 5, t.position.y - 5);\n        }, o.bodyBounds = function (e, t, n) {\n          var o = n,\n              i = (e.engine, e.options);o.beginPath();for (var r = 0; r < t.length; r++) {\n            var s = t[r];if (s.render.visible) for (var a = t[r].parts, l = a.length > 1 ? 1 : 0; l < a.length; l++) {\n              var c = a[l];o.rect(c.bounds.min.x, c.bounds.min.y, c.bounds.max.x - c.bounds.min.x, c.bounds.max.y - c.bounds.min.y);\n            }\n          }i.wireframes ? o.strokeStyle = \"rgba(255,255,255,0.08)\" : o.strokeStyle = \"rgba(0,0,0,0.1)\", o.lineWidth = 1, o.stroke();\n        }, o.bodyAxes = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a = n,\n              l = (e.engine, e.options);for (a.beginPath(), i = 0; i < t.length; i++) {\n            var c = t[i],\n                d = c.parts;if (c.render.visible) if (l.showAxes) for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {\n              for (o = d[r], s = 0; s < o.axes.length; s++) {\n                var u = o.axes[s];a.moveTo(o.position.x, o.position.y), a.lineTo(o.position.x + 20 * u.x, o.position.y + 20 * u.y);\n              }\n            } else for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {\n              for (o = d[r], s = 0; s < o.axes.length; s++) {\n                a.moveTo(o.position.x, o.position.y), a.lineTo((o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2);\n              }\n            }\n          }l.wireframes ? (a.strokeStyle = \"indianred\", a.lineWidth = 1) : (a.strokeStyle = \"rgba(255, 255, 255, 0.4)\", a.globalCompositeOperation = \"overlay\", a.lineWidth = 2), a.stroke(), a.globalCompositeOperation = \"source-over\";\n        }, o.bodyPositions = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a = n,\n              l = (e.engine, e.options);for (a.beginPath(), r = 0; r < t.length; r++) {\n            if (o = t[r], o.render.visible) for (s = 0; s < o.parts.length; s++) {\n              i = o.parts[s], a.arc(i.position.x, i.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();\n            }\n          }for (l.wireframes ? a.fillStyle = \"indianred\" : a.fillStyle = \"rgba(0,0,0,0.5)\", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {\n            o = t[r], o.render.visible && (a.arc(o.positionPrev.x, o.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());\n          }a.fillStyle = \"rgba(255,165,0,0.8)\", a.fill();\n        }, o.bodyVelocity = function (e, t, n) {\n          var o = n;o.beginPath();for (var i = 0; i < t.length; i++) {\n            var r = t[i];r.render.visible && (o.moveTo(r.position.x, r.position.y), o.lineTo(r.position.x + 2 * (r.position.x - r.positionPrev.x), r.position.y + 2 * (r.position.y - r.positionPrev.y)));\n          }o.lineWidth = 3, o.strokeStyle = \"cornflowerblue\", o.stroke();\n        }, o.bodyIds = function (e, t, n) {\n          var o,\n              i,\n              r = n;\n          for (o = 0; o < t.length; o++) {\n            if (t[o].render.visible) {\n              var s = t[o].parts;for (i = s.length > 1 ? 1 : 0; i < s.length; i++) {\n                var a = s[i];r.font = \"12px Arial\", r.fillStyle = \"rgba(255,255,255,0.5)\", r.fillText(a.id, a.position.x + 10, a.position.y - 10);\n              }\n            }\n          }\n        }, o.collisions = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a = n,\n              l = e.options;for (a.beginPath(), r = 0; r < t.length; r++) {\n            if (o = t[r], o.isActive) for (i = o.collision, s = 0; s < o.activeContacts.length; s++) {\n              var c = o.activeContacts[s],\n                  d = c.vertex;a.rect(d.x - 1.5, d.y - 1.5, 3.5, 3.5);\n            }\n          }for (l.wireframes ? a.fillStyle = \"rgba(255,255,255,0.7)\" : a.fillStyle = \"orange\", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {\n            if (o = t[r], o.isActive && (i = o.collision, o.activeContacts.length > 0)) {\n              var u = o.activeContacts[0].vertex.x,\n                  p = o.activeContacts[0].vertex.y;2 === o.activeContacts.length && (u = (o.activeContacts[0].vertex.x + o.activeContacts[1].vertex.x) / 2, p = (o.activeContacts[0].vertex.y + o.activeContacts[1].vertex.y) / 2), i.bodyB === i.supports[0].body || i.bodyA.isStatic === !0 ? a.moveTo(u - 8 * i.normal.x, p - 8 * i.normal.y) : a.moveTo(u + 8 * i.normal.x, p + 8 * i.normal.y), a.lineTo(u, p);\n            }\n          }l.wireframes ? a.strokeStyle = \"rgba(255,165,0,0.7)\" : a.strokeStyle = \"orange\", a.lineWidth = 1, a.stroke();\n        }, o.separations = function (e, t, n) {\n          var o,\n              i,\n              r,\n              s,\n              a,\n              l = n,\n              c = e.options;for (l.beginPath(), a = 0; a < t.length; a++) {\n            if (o = t[a], o.isActive) {\n              i = o.collision, r = i.bodyA, s = i.bodyB;var d = 1;s.isStatic || r.isStatic || (d = .5), s.isStatic && (d = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x - i.penetration.x * d, s.position.y - i.penetration.y * d), d = 1, s.isStatic || r.isStatic || (d = .5), r.isStatic && (d = 0), l.moveTo(r.position.x, r.position.y), l.lineTo(r.position.x + i.penetration.x * d, r.position.y + i.penetration.y * d);\n            }\n          }c.wireframes ? l.strokeStyle = \"rgba(255,165,0,0.5)\" : l.strokeStyle = \"orange\", l.stroke();\n        }, o.grid = function (e, t, n) {\n          var o = n,\n              r = e.options;r.wireframes ? o.strokeStyle = \"rgba(255,180,0,0.1)\" : o.strokeStyle = \"rgba(255,180,0,0.5)\", o.beginPath();for (var s = i.keys(t.buckets), a = 0; a < s.length; a++) {\n            var l = s[a];if (!(t.buckets[l].length < 2)) {\n              var c = l.split(/C|R/);o.rect(.5 + parseInt(c[1], 10) * t.bucketWidth, .5 + parseInt(c[2], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight);\n            }\n          }o.lineWidth = 1, o.stroke();\n        }, o.inspector = function (e, t) {\n          var n,\n              o = (e.engine, e.selected),\n              i = e.render,\n              r = i.options;if (r.hasBounds) {\n            var s = i.bounds.max.x - i.bounds.min.x,\n                a = i.bounds.max.y - i.bounds.min.y,\n                l = s / i.options.width,\n                c = a / i.options.height;t.scale(1 / l, 1 / c), t.translate(-i.bounds.min.x, -i.bounds.min.y);\n          }for (var d = 0; d < o.length; d++) {\n            var u = o[d].data;switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = \"rgba(255,165,0,0.9)\", t.setLineDash([1, 2]), u.type) {case \"body\":\n                n = u.bounds, t.beginPath(), t.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), t.closePath(), t.stroke();break;case \"constraint\":\n                var p = u.pointA;u.bodyA && (p = u.pointB), t.beginPath(), t.arc(p.x, p.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke();}t.setLineDash([]), t.translate(-.5, -.5);\n          }null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = \"rgba(255,165,0,0.6)\", t.fillStyle = \"rgba(255,165,0,0.1)\", n = e.selectBounds, t.beginPath(), t.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), r.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0);\n        };var n = function n(e, t) {\n          var n = document.createElement(\"canvas\");return n.width = e, n.height = t, n.oncontextmenu = function () {\n            return !1;\n          }, n.onselectstart = function () {\n            return !1;\n          }, n;\n        },\n            u = function u(e) {\n          var t = e.getContext(\"2d\"),\n              n = window.devicePixelRatio || 1,\n              o = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;return n / o;\n        },\n            p = function p(e, t) {\n          var n = e.textures[t];return n ? n : (n = e.textures[t] = new Image(), n.src = t, n);\n        },\n            f = function f(e, t) {\n          var n = t;/(jpg|gif|png)$/.test(t) && (n = \"url(\" + t + \")\"), e.canvas.style.background = n, e.canvas.style.backgroundSize = \"contain\", e.currentBackground = t;\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../collision/Grid\": 6, \"../core/Common\": 14, \"../core/Events\": 16, \"../core/Mouse\": 19, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28 }], 32: [function (e, t, n) {\n      var o = {};t.exports = o;var i = e(\"../geometry/Bounds\"),\n          r = e(\"../body/Composite\"),\n          s = e(\"../core/Common\"),\n          a = e(\"../core/Events\"),\n          l = e(\"../geometry/Vector\");\n      !function () {\n        var e, t;\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          window.setTimeout(function () {\n            e(s.now());\n          }, 1e3 / 60);\n        }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), o.create = function (e) {\n          s.warn(\"RenderPixi.create: Matter.RenderPixi is deprecated (see docs)\");var t = { controller: o, engine: null, element: null, frameRequestId: null, canvas: null, renderer: null, container: null, spriteContainer: null, pixiOptions: null, options: { width: 800, height: 600, background: \"#fafafa\", wireframeBackground: \"#222\", hasBounds: !1, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1 } },\n              n = s.extend(t, e),\n              i = !n.options.wireframes && \"transparent\" === n.options.background;return n.pixiOptions = n.pixiOptions || {\n            view: n.canvas, transparent: i, antialias: !0, backgroundColor: e.background }, n.mouse = e.mouse, n.engine = e.engine, n.renderer = n.renderer || new PIXI.WebGLRenderer(n.options.width, n.options.height, n.pixiOptions), n.container = n.container || new PIXI.Container(), n.spriteContainer = n.spriteContainer || new PIXI.Container(), n.canvas = n.canvas || n.renderer.view, n.bounds = n.bounds || { min: { x: 0, y: 0 }, max: { x: n.options.width, y: n.options.height } }, a.on(n.engine, \"beforeUpdate\", function () {\n            o.clear(n);\n          }), n.textures = {}, n.sprites = {}, n.primitives = {}, n.container.addChild(n.spriteContainer), s.isElement(n.element) ? n.element.appendChild(n.canvas) : s.warn('No \"render.element\" passed, \"render.canvas\" was not inserted into document.'), n.canvas.oncontextmenu = function () {\n            return !1;\n          }, n.canvas.onselectstart = function () {\n            return !1;\n          }, n;\n        }, o.run = function (t) {\n          !function n(i) {\n            t.frameRequestId = e(n), o.world(t);\n          }();\n        }, o.stop = function (e) {\n          t(e.frameRequestId);\n        }, o.clear = function (e) {\n          for (var t = e.container, n = e.spriteContainer; t.children[0];) {\n            t.removeChild(t.children[0]);\n          }for (; n.children[0];) {\n            n.removeChild(n.children[0]);\n          }var o = e.sprites[\"bg-0\"];e.textures = {}, e.sprites = {}, e.primitives = {}, e.sprites[\"bg-0\"] = o, o && t.addChildAt(o, 0), e.container.addChild(e.spriteContainer), e.currentBackground = null, t.scale.set(1, 1), t.position.set(0, 0);\n        }, o.setBackground = function (e, t) {\n          if (e.currentBackground !== t) {\n            var n = t.indexOf && t.indexOf(\"#\") !== -1,\n                o = e.sprites[\"bg-0\"];if (n) {\n              var i = s.colorToNumber(t);e.renderer.backgroundColor = i, o && e.container.removeChild(o);\n            } else if (!o) {\n              var r = d(e, t);o = e.sprites[\"bg-0\"] = new PIXI.Sprite(r), o.position.x = 0, o.position.y = 0, e.container.addChildAt(o, 0);\n            }e.currentBackground = t;\n          }\n        }, o.world = function (e) {\n          var t,\n              n = e.engine,\n              s = n.world,\n              a = e.renderer,\n              c = e.container,\n              d = e.options,\n              u = r.allBodies(s),\n              p = r.allConstraints(s),\n              f = [];d.wireframes ? o.setBackground(e, d.wireframeBackground) : o.setBackground(e, d.background);var m = e.bounds.max.x - e.bounds.min.x,\n              v = e.bounds.max.y - e.bounds.min.y,\n              y = m / e.options.width,\n              g = v / e.options.height;if (d.hasBounds) {\n            for (t = 0; t < u.length; t++) {\n              var x = u[t];x.render.sprite.visible = i.overlaps(x.bounds, e.bounds);\n            }for (t = 0; t < p.length; t++) {\n              var h = p[t],\n                  b = h.bodyA,\n                  w = h.bodyB,\n                  S = h.pointA,\n                  C = h.pointB;b && (S = l.add(b.position, h.pointA)), w && (C = l.add(w.position, h.pointB)), S && C && (i.contains(e.bounds, S) || i.contains(e.bounds, C)) && f.push(h);\n            }c.scale.set(1 / y, 1 / g), c.position.set(-e.bounds.min.x * (1 / y), -e.bounds.min.y * (1 / g));\n          } else f = p;for (t = 0; t < u.length; t++) {\n            o.body(e, u[t]);\n          }for (t = 0; t < f.length; t++) {\n            o.constraint(e, f[t]);\n          }a.render(c);\n        }, o.constraint = function (e, t) {\n          var n = (e.engine, t.bodyA),\n              o = t.bodyB,\n              i = t.pointA,\n              r = t.pointB,\n              a = e.container,\n              l = t.render,\n              c = \"c-\" + t.id,\n              d = e.primitives[c];return d || (d = e.primitives[c] = new PIXI.Graphics()), l.visible && t.pointA && t.pointB ? (s.indexOf(a.children, d) === -1 && a.addChild(d), d.clear(), d.beginFill(0, 0), d.lineStyle(l.lineWidth, s.colorToNumber(l.strokeStyle), 1), n ? d.moveTo(n.position.x + i.x, n.position.y + i.y) : d.moveTo(i.x, i.y), o ? d.lineTo(o.position.x + r.x, o.position.y + r.y) : d.lineTo(r.x, r.y), void d.endFill()) : void d.clear();\n        }, o.body = function (e, t) {\n          var o = (e.engine, t.render);if (o.visible) if (o.sprite && o.sprite.texture) {\n            var i = \"b-\" + t.id,\n                r = e.sprites[i],\n                a = e.spriteContainer;\n            r || (r = e.sprites[i] = n(e, t)), s.indexOf(a.children, r) === -1 && a.addChild(r), r.position.x = t.position.x, r.position.y = t.position.y, r.rotation = t.angle, r.scale.x = o.sprite.xScale || 1, r.scale.y = o.sprite.yScale || 1;\n          } else {\n            var l = \"b-\" + t.id,\n                d = e.primitives[l],\n                u = e.container;d || (d = e.primitives[l] = c(e, t), d.initialAngle = t.angle), s.indexOf(u.children, d) === -1 && u.addChild(d), d.position.x = t.position.x, d.position.y = t.position.y, d.rotation = t.angle - d.initialAngle;\n          }\n        };var n = function n(e, t) {\n          var n = t.render,\n              o = n.sprite.texture,\n              i = d(e, o),\n              r = new PIXI.Sprite(i);return r.anchor.x = t.render.sprite.xOffset, r.anchor.y = t.render.sprite.yOffset, r;\n        },\n            c = function c(e, t) {\n          var n,\n              o = t.render,\n              i = e.options,\n              r = new PIXI.Graphics(),\n              a = s.colorToNumber(o.fillStyle),\n              l = s.colorToNumber(o.strokeStyle),\n              c = s.colorToNumber(o.strokeStyle),\n              d = s.colorToNumber(\"#bbb\"),\n              u = s.colorToNumber(\"#CD5C5C\");r.clear();for (var p = t.parts.length > 1 ? 1 : 0; p < t.parts.length; p++) {\n            n = t.parts[p], i.wireframes ? (r.beginFill(0, 0), r.lineStyle(1, d, 1)) : (r.beginFill(a, 1), r.lineStyle(o.lineWidth, l, 1)), r.moveTo(n.vertices[0].x - t.position.x, n.vertices[0].y - t.position.y);\n            for (var f = 1; f < n.vertices.length; f++) {\n              r.lineTo(n.vertices[f].x - t.position.x, n.vertices[f].y - t.position.y);\n            }r.lineTo(n.vertices[0].x - t.position.x, n.vertices[0].y - t.position.y), r.endFill(), (i.showAngleIndicator || i.showAxes) && (r.beginFill(0, 0), i.wireframes ? r.lineStyle(1, u, 1) : r.lineStyle(1, c), r.moveTo(n.position.x - t.position.x, n.position.y - t.position.y), r.lineTo((n.vertices[0].x + n.vertices[n.vertices.length - 1].x) / 2 - t.position.x, (n.vertices[0].y + n.vertices[n.vertices.length - 1].y) / 2 - t.position.y), r.endFill());\n          }return r;\n        },\n            d = function d(e, t) {\n          var n = e.textures[t];return n || (n = e.textures[t] = PIXI.Texture.fromImage(t)), n;\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../core/Common\": 14, \"../core/Events\": 16, \"../geometry/Bounds\": 26, \"../geometry/Vector\": 28 }] }, {}, [30])(30);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ 155)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jbGllbnQvYXBwL2xpYnMvbWF0dGVyLm1pbi5qcz80ODYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBtYXR0ZXItanMgMC4xMy4wIGJ5IEBsaWFicnUgMjAxNy0wNy0wNlxuKiBodHRwOi8vYnJtLmlvL21hdHRlci1qcy9cbiogTGljZW5zZSBNSVRcbiovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLHQuTWF0dGVyPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLG8pe2Z1bmN0aW9uIGkocyxhKXtpZighbltzXSl7aWYoIXRbc10pe3ZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWEmJmwpcmV0dXJuIGwocywhMCk7aWYocilyZXR1cm4gcihzLCEwKTt2YXIgYz1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3MrXCInXCIpO3Rocm93IGMuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixjfXZhciBkPW5bc109e2V4cG9ydHM6e319O3Rbc11bMF0uY2FsbChkLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtzXVsxXVtlXTtyZXR1cm4gaShuP246ZSl9LGQsZC5leHBvcnRzLGUsdCxuLG8pfXJldHVybiBuW3NdLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUscz0wO3M8by5sZW5ndGg7cysrKWkob1tzXSk7cmV0dXJuIGl9KHsxOltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxzPWUoXCIuLi9jb3JlL1NsZWVwaW5nXCIpLGE9KGUoXCIuLi9yZW5kZXIvUmVuZGVyXCIpLGUoXCIuLi9jb3JlL0NvbW1vblwiKSksbD1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLGM9ZShcIi4uL2dlb21ldHJ5L0F4ZXNcIik7IWZ1bmN0aW9uKCl7by5faW5lcnRpYVNjYWxlPTQsby5fbmV4dENvbGxpZGluZ0dyb3VwSWQ9MSxcbm8uX25leHROb25Db2xsaWRpbmdHcm91cElkPS0xLG8uX25leHRDYXRlZ29yeT0xLG8uY3JlYXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXtpZDphLm5leHRJZCgpLHR5cGU6XCJib2R5XCIsbGFiZWw6XCJCb2R5XCIscGFydHM6W10scGx1Z2luOnt9LGFuZ2xlOjAsdmVydGljZXM6aS5mcm9tUGF0aChcIkwgMCAwIEwgNDAgMCBMIDQwIDQwIEwgMCA0MFwiKSxwb3NpdGlvbjp7eDowLHk6MH0sZm9yY2U6e3g6MCx5OjB9LHRvcnF1ZTowLHBvc2l0aW9uSW1wdWxzZTp7eDowLHk6MH0sY29uc3RyYWludEltcHVsc2U6e3g6MCx5OjAsYW5nbGU6MH0sdG90YWxDb250YWN0czowLHNwZWVkOjAsYW5ndWxhclNwZWVkOjAsdmVsb2NpdHk6e3g6MCx5OjB9LGFuZ3VsYXJWZWxvY2l0eTowLGlzU2Vuc29yOiExLGlzU3RhdGljOiExLGlzU2xlZXBpbmc6ITEsbW90aW9uOjAsc2xlZXBUaHJlc2hvbGQ6NjAsZGVuc2l0eTouMDAxLHJlc3RpdHV0aW9uOjAsZnJpY3Rpb246LjEsZnJpY3Rpb25TdGF0aWM6LjUsZnJpY3Rpb25BaXI6LjAxLGNvbGxpc2lvbkZpbHRlcjp7Y2F0ZWdvcnk6MSxtYXNrOjQyOTQ5NjcyOTUsZ3JvdXA6MH0sc2xvcDouMDUsdGltZVNjYWxlOjEscmVuZGVyOnt2aXNpYmxlOiEwLG9wYWNpdHk6MSxzcHJpdGU6e3hTY2FsZToxLHlTY2FsZToxLHhPZmZzZXQ6MCx5T2Zmc2V0OjB9LGxpbmVXaWR0aDowfX0sbz1hLmV4dGVuZChuLHQpO3JldHVybiBlKG8sdCksb30sby5uZXh0R3JvdXA9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/by5fbmV4dE5vbkNvbGxpZGluZ0dyb3VwSWQtLTpvLl9uZXh0Q29sbGlkaW5nR3JvdXBJZCsrfSxvLm5leHRDYXRlZ29yeT1mdW5jdGlvbigpe3JldHVybiBvLl9uZXh0Q2F0ZWdvcnk9by5fbmV4dENhdGVnb3J5PDwxLG8uX25leHRDYXRlZ29yeX07dmFyIGU9ZnVuY3Rpb24oZSx0KXt0PXR8fHt9LG8uc2V0KGUse2JvdW5kczplLmJvdW5kc3x8bC5jcmVhdGUoZS52ZXJ0aWNlcykscG9zaXRpb25QcmV2OmUucG9zaXRpb25QcmV2fHxyLmNsb25lKGUucG9zaXRpb24pLFxuYW5nbGVQcmV2OmUuYW5nbGVQcmV2fHxlLmFuZ2xlLHZlcnRpY2VzOmUudmVydGljZXMscGFydHM6ZS5wYXJ0c3x8W2VdLGlzU3RhdGljOmUuaXNTdGF0aWMsaXNTbGVlcGluZzplLmlzU2xlZXBpbmcscGFyZW50OmUucGFyZW50fHxlfSksaS5yb3RhdGUoZS52ZXJ0aWNlcyxlLmFuZ2xlLGUucG9zaXRpb24pLGMucm90YXRlKGUuYXhlcyxlLmFuZ2xlKSxsLnVwZGF0ZShlLmJvdW5kcyxlLnZlcnRpY2VzLGUudmVsb2NpdHkpLG8uc2V0KGUse2F4ZXM6dC5heGVzfHxlLmF4ZXMsYXJlYTp0LmFyZWF8fGUuYXJlYSxtYXNzOnQubWFzc3x8ZS5tYXNzLGluZXJ0aWE6dC5pbmVydGlhfHxlLmluZXJ0aWF9KTt2YXIgbj1lLmlzU3RhdGljP1wiIzJlMmI0NFwiOmEuY2hvb3NlKFtcIiMwMDZCQTZcIixcIiMwNDk2RkZcIixcIiNGRkJDNDJcIixcIiNEODExNTlcIixcIiM4RjJENTZcIl0pLHM9XCIjMDAwXCI7ZS5yZW5kZXIuZmlsbFN0eWxlPWUucmVuZGVyLmZpbGxTdHlsZXx8bixlLnJlbmRlci5zdHJva2VTdHlsZT1lLnJlbmRlci5zdHJva2VTdHlsZXx8cyxlLnJlbmRlci5zcHJpdGUueE9mZnNldCs9LShlLmJvdW5kcy5taW4ueC1lLnBvc2l0aW9uLngpLyhlLmJvdW5kcy5tYXgueC1lLmJvdW5kcy5taW4ueCksZS5yZW5kZXIuc3ByaXRlLnlPZmZzZXQrPS0oZS5ib3VuZHMubWluLnktZS5wb3NpdGlvbi55KS8oZS5ib3VuZHMubWF4LnktZS5ib3VuZHMubWluLnkpfTtvLnNldD1mdW5jdGlvbihlLHQsbil7dmFyIGk7XCJzdHJpbmdcIj09dHlwZW9mIHQmJihpPXQsdD17fSx0W2ldPW4pO2ZvcihpIGluIHQpaWYobj10W2ldLHQuaGFzT3duUHJvcGVydHkoaSkpc3dpdGNoKGkpe2Nhc2VcImlzU3RhdGljXCI6by5zZXRTdGF0aWMoZSxuKTticmVhaztjYXNlXCJpc1NsZWVwaW5nXCI6cy5zZXQoZSxuKTticmVhaztjYXNlXCJtYXNzXCI6by5zZXRNYXNzKGUsbik7YnJlYWs7Y2FzZVwiZGVuc2l0eVwiOm8uc2V0RGVuc2l0eShlLG4pO2JyZWFrO2Nhc2VcImluZXJ0aWFcIjpvLnNldEluZXJ0aWEoZSxuKTticmVhaztjYXNlXCJ2ZXJ0aWNlc1wiOlxuby5zZXRWZXJ0aWNlcyhlLG4pO2JyZWFrO2Nhc2VcInBvc2l0aW9uXCI6by5zZXRQb3NpdGlvbihlLG4pO2JyZWFrO2Nhc2VcImFuZ2xlXCI6by5zZXRBbmdsZShlLG4pO2JyZWFrO2Nhc2VcInZlbG9jaXR5XCI6by5zZXRWZWxvY2l0eShlLG4pO2JyZWFrO2Nhc2VcImFuZ3VsYXJWZWxvY2l0eVwiOm8uc2V0QW5ndWxhclZlbG9jaXR5KGUsbik7YnJlYWs7Y2FzZVwicGFydHNcIjpvLnNldFBhcnRzKGUsbik7YnJlYWs7ZGVmYXVsdDplW2ldPW59fSxvLnNldFN0YXRpYz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248ZS5wYXJ0cy5sZW5ndGg7bisrKXt2YXIgbz1lLnBhcnRzW25dO28uaXNTdGF0aWM9dCx0PyhvLl9vcmlnaW5hbD17cmVzdGl0dXRpb246by5yZXN0aXR1dGlvbixmcmljdGlvbjpvLmZyaWN0aW9uLG1hc3M6by5tYXNzLGluZXJ0aWE6by5pbmVydGlhLGRlbnNpdHk6by5kZW5zaXR5LGludmVyc2VNYXNzOm8uaW52ZXJzZU1hc3MsaW52ZXJzZUluZXJ0aWE6by5pbnZlcnNlSW5lcnRpYX0sby5yZXN0aXR1dGlvbj0wLG8uZnJpY3Rpb249MSxvLm1hc3M9by5pbmVydGlhPW8uZGVuc2l0eT0xLzAsby5pbnZlcnNlTWFzcz1vLmludmVyc2VJbmVydGlhPTAsby5wb3NpdGlvblByZXYueD1vLnBvc2l0aW9uLngsby5wb3NpdGlvblByZXYueT1vLnBvc2l0aW9uLnksby5hbmdsZVByZXY9by5hbmdsZSxvLmFuZ3VsYXJWZWxvY2l0eT0wLG8uc3BlZWQ9MCxvLmFuZ3VsYXJTcGVlZD0wLG8ubW90aW9uPTApOm8uX29yaWdpbmFsJiYoby5yZXN0aXR1dGlvbj1vLl9vcmlnaW5hbC5yZXN0aXR1dGlvbixvLmZyaWN0aW9uPW8uX29yaWdpbmFsLmZyaWN0aW9uLG8ubWFzcz1vLl9vcmlnaW5hbC5tYXNzLG8uaW5lcnRpYT1vLl9vcmlnaW5hbC5pbmVydGlhLG8uZGVuc2l0eT1vLl9vcmlnaW5hbC5kZW5zaXR5LG8uaW52ZXJzZU1hc3M9by5fb3JpZ2luYWwuaW52ZXJzZU1hc3Msby5pbnZlcnNlSW5lcnRpYT1vLl9vcmlnaW5hbC5pbnZlcnNlSW5lcnRpYSxkZWxldGUgby5fb3JpZ2luYWwpO1xufX0sby5zZXRNYXNzPWZ1bmN0aW9uKGUsdCl7ZS5tYXNzPXQsZS5pbnZlcnNlTWFzcz0xL2UubWFzcyxlLmRlbnNpdHk9ZS5tYXNzL2UuYXJlYX0sby5zZXREZW5zaXR5PWZ1bmN0aW9uKGUsdCl7by5zZXRNYXNzKGUsdCplLmFyZWEpLGUuZGVuc2l0eT10fSxvLnNldEluZXJ0aWE9ZnVuY3Rpb24oZSx0KXtlLmluZXJ0aWE9dCxlLmludmVyc2VJbmVydGlhPTEvZS5pbmVydGlhfSxvLnNldFZlcnRpY2VzPWZ1bmN0aW9uKGUsdCl7dFswXS5ib2R5PT09ZT9lLnZlcnRpY2VzPXQ6ZS52ZXJ0aWNlcz1pLmNyZWF0ZSh0LGUpLGUuYXhlcz1jLmZyb21WZXJ0aWNlcyhlLnZlcnRpY2VzKSxlLmFyZWE9aS5hcmVhKGUudmVydGljZXMpLG8uc2V0TWFzcyhlLGUuZGVuc2l0eSplLmFyZWEpO3ZhciBuPWkuY2VudHJlKGUudmVydGljZXMpO2kudHJhbnNsYXRlKGUudmVydGljZXMsbiwtMSksby5zZXRJbmVydGlhKGUsby5faW5lcnRpYVNjYWxlKmkuaW5lcnRpYShlLnZlcnRpY2VzLGUubWFzcykpLGkudHJhbnNsYXRlKGUudmVydGljZXMsZS5wb3NpdGlvbiksbC51cGRhdGUoZS5ib3VuZHMsZS52ZXJ0aWNlcyxlLnZlbG9jaXR5KX0sby5zZXRQYXJ0cz1mdW5jdGlvbihlLG4scil7dmFyIHM7Zm9yKG49bi5zbGljZSgwKSxlLnBhcnRzLmxlbmd0aD0wLGUucGFydHMucHVzaChlKSxlLnBhcmVudD1lLHM9MDtzPG4ubGVuZ3RoO3MrKyl7dmFyIGE9bltzXTthIT09ZSYmKGEucGFyZW50PWUsZS5wYXJ0cy5wdXNoKGEpKX1pZigxIT09ZS5wYXJ0cy5sZW5ndGgpe2lmKHI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHJ8fHIpe3ZhciBsPVtdO2ZvcihzPTA7czxuLmxlbmd0aDtzKyspbD1sLmNvbmNhdChuW3NdLnZlcnRpY2VzKTtpLmNsb2Nrd2lzZVNvcnQobCk7dmFyIGM9aS5odWxsKGwpLGQ9aS5jZW50cmUoYyk7by5zZXRWZXJ0aWNlcyhlLGMpLGkudHJhbnNsYXRlKGUudmVydGljZXMsZCl9dmFyIHU9dChlKTtlLmFyZWE9dS5hcmVhLGUucGFyZW50PWUsZS5wb3NpdGlvbi54PXUuY2VudHJlLngsXG5lLnBvc2l0aW9uLnk9dS5jZW50cmUueSxlLnBvc2l0aW9uUHJldi54PXUuY2VudHJlLngsZS5wb3NpdGlvblByZXYueT11LmNlbnRyZS55LG8uc2V0TWFzcyhlLHUubWFzcyksby5zZXRJbmVydGlhKGUsdS5pbmVydGlhKSxvLnNldFBvc2l0aW9uKGUsdS5jZW50cmUpfX0sby5zZXRQb3NpdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBuPXIuc3ViKHQsZS5wb3NpdGlvbik7ZS5wb3NpdGlvblByZXYueCs9bi54LGUucG9zaXRpb25QcmV2LnkrPW4ueTtmb3IodmFyIG89MDtvPGUucGFydHMubGVuZ3RoO28rKyl7dmFyIHM9ZS5wYXJ0c1tvXTtzLnBvc2l0aW9uLngrPW4ueCxzLnBvc2l0aW9uLnkrPW4ueSxpLnRyYW5zbGF0ZShzLnZlcnRpY2VzLG4pLGwudXBkYXRlKHMuYm91bmRzLHMudmVydGljZXMsZS52ZWxvY2l0eSl9fSxvLnNldEFuZ2xlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC1lLmFuZ2xlO2UuYW5nbGVQcmV2Kz1uO2Zvcih2YXIgbz0wO288ZS5wYXJ0cy5sZW5ndGg7bysrKXt2YXIgcz1lLnBhcnRzW29dO3MuYW5nbGUrPW4saS5yb3RhdGUocy52ZXJ0aWNlcyxuLGUucG9zaXRpb24pLGMucm90YXRlKHMuYXhlcyxuKSxsLnVwZGF0ZShzLmJvdW5kcyxzLnZlcnRpY2VzLGUudmVsb2NpdHkpLG8+MCYmci5yb3RhdGVBYm91dChzLnBvc2l0aW9uLG4sZS5wb3NpdGlvbixzLnBvc2l0aW9uKX19LG8uc2V0VmVsb2NpdHk9ZnVuY3Rpb24oZSx0KXtlLnBvc2l0aW9uUHJldi54PWUucG9zaXRpb24ueC10LngsZS5wb3NpdGlvblByZXYueT1lLnBvc2l0aW9uLnktdC55LGUudmVsb2NpdHkueD10LngsZS52ZWxvY2l0eS55PXQueSxlLnNwZWVkPXIubWFnbml0dWRlKGUudmVsb2NpdHkpfSxvLnNldEFuZ3VsYXJWZWxvY2l0eT1mdW5jdGlvbihlLHQpe2UuYW5nbGVQcmV2PWUuYW5nbGUtdCxlLmFuZ3VsYXJWZWxvY2l0eT10LGUuYW5ndWxhclNwZWVkPU1hdGguYWJzKGUuYW5ndWxhclZlbG9jaXR5KX0sby50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0KXtvLnNldFBvc2l0aW9uKGUsci5hZGQoZS5wb3NpdGlvbix0KSk7XG59LG8ucm90YXRlPWZ1bmN0aW9uKGUsdCxuKXtpZihuKXt2YXIgaT1NYXRoLmNvcyh0KSxyPU1hdGguc2luKHQpLHM9ZS5wb3NpdGlvbi54LW4ueCxhPWUucG9zaXRpb24ueS1uLnk7by5zZXRQb3NpdGlvbihlLHt4Om4ueCsocyppLWEqcikseTpuLnkrKHMqcithKmkpfSksby5zZXRBbmdsZShlLGUuYW5nbGUrdCl9ZWxzZSBvLnNldEFuZ2xlKGUsZS5hbmdsZSt0KX0sby5zY2FsZT1mdW5jdGlvbihlLG4scixzKXtmb3IodmFyIGE9MDthPGUucGFydHMubGVuZ3RoO2ErKyl7dmFyIGQ9ZS5wYXJ0c1thXTtpLnNjYWxlKGQudmVydGljZXMsbixyLGUucG9zaXRpb24pLGQuYXhlcz1jLmZyb21WZXJ0aWNlcyhkLnZlcnRpY2VzKSxlLmlzU3RhdGljfHwoZC5hcmVhPWkuYXJlYShkLnZlcnRpY2VzKSxvLnNldE1hc3MoZCxlLmRlbnNpdHkqZC5hcmVhKSxpLnRyYW5zbGF0ZShkLnZlcnRpY2VzLHt4Oi1kLnBvc2l0aW9uLngseTotZC5wb3NpdGlvbi55fSksby5zZXRJbmVydGlhKGQsaS5pbmVydGlhKGQudmVydGljZXMsZC5tYXNzKSksaS50cmFuc2xhdGUoZC52ZXJ0aWNlcyx7eDpkLnBvc2l0aW9uLngseTpkLnBvc2l0aW9uLnl9KSksbC51cGRhdGUoZC5ib3VuZHMsZC52ZXJ0aWNlcyxlLnZlbG9jaXR5KX1pZihlLmNpcmNsZVJhZGl1cyYmKG49PT1yP2UuY2lyY2xlUmFkaXVzKj1uOmUuY2lyY2xlUmFkaXVzPW51bGwpLCFlLmlzU3RhdGljKXt2YXIgdT10KGUpO2UuYXJlYT11LmFyZWEsby5zZXRNYXNzKGUsdS5tYXNzKSxvLnNldEluZXJ0aWEoZSx1LmluZXJ0aWEpfX0sby51cGRhdGU9ZnVuY3Rpb24oZSx0LG4sbyl7dmFyIHM9TWF0aC5wb3codCpuKmUudGltZVNjYWxlLDIpLGE9MS1lLmZyaWN0aW9uQWlyKm4qZS50aW1lU2NhbGUsZD1lLnBvc2l0aW9uLngtZS5wb3NpdGlvblByZXYueCx1PWUucG9zaXRpb24ueS1lLnBvc2l0aW9uUHJldi55O2UudmVsb2NpdHkueD1kKmEqbytlLmZvcmNlLngvZS5tYXNzKnMsZS52ZWxvY2l0eS55PXUqYSpvK2UuZm9yY2UueS9lLm1hc3MqcyxcbmUucG9zaXRpb25QcmV2Lng9ZS5wb3NpdGlvbi54LGUucG9zaXRpb25QcmV2Lnk9ZS5wb3NpdGlvbi55LGUucG9zaXRpb24ueCs9ZS52ZWxvY2l0eS54LGUucG9zaXRpb24ueSs9ZS52ZWxvY2l0eS55LGUuYW5ndWxhclZlbG9jaXR5PShlLmFuZ2xlLWUuYW5nbGVQcmV2KSphKm8rZS50b3JxdWUvZS5pbmVydGlhKnMsZS5hbmdsZVByZXY9ZS5hbmdsZSxlLmFuZ2xlKz1lLmFuZ3VsYXJWZWxvY2l0eSxlLnNwZWVkPXIubWFnbml0dWRlKGUudmVsb2NpdHkpLGUuYW5ndWxhclNwZWVkPU1hdGguYWJzKGUuYW5ndWxhclZlbG9jaXR5KTtmb3IodmFyIHA9MDtwPGUucGFydHMubGVuZ3RoO3ArKyl7dmFyIGY9ZS5wYXJ0c1twXTtpLnRyYW5zbGF0ZShmLnZlcnRpY2VzLGUudmVsb2NpdHkpLHA+MCYmKGYucG9zaXRpb24ueCs9ZS52ZWxvY2l0eS54LGYucG9zaXRpb24ueSs9ZS52ZWxvY2l0eS55KSwwIT09ZS5hbmd1bGFyVmVsb2NpdHkmJihpLnJvdGF0ZShmLnZlcnRpY2VzLGUuYW5ndWxhclZlbG9jaXR5LGUucG9zaXRpb24pLGMucm90YXRlKGYuYXhlcyxlLmFuZ3VsYXJWZWxvY2l0eSkscD4wJiZyLnJvdGF0ZUFib3V0KGYucG9zaXRpb24sZS5hbmd1bGFyVmVsb2NpdHksZS5wb3NpdGlvbixmLnBvc2l0aW9uKSksbC51cGRhdGUoZi5ib3VuZHMsZi52ZXJ0aWNlcyxlLnZlbG9jaXR5KX19LG8uYXBwbHlGb3JjZT1mdW5jdGlvbihlLHQsbil7ZS5mb3JjZS54Kz1uLngsZS5mb3JjZS55Kz1uLnk7dmFyIG89e3g6dC54LWUucG9zaXRpb24ueCx5OnQueS1lLnBvc2l0aW9uLnl9O2UudG9ycXVlKz1vLngqbi55LW8ueSpuLnh9O3ZhciB0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17bWFzczowLGFyZWE6MCxpbmVydGlhOjAsY2VudHJlOnt4OjAseTowfX0sbj0xPT09ZS5wYXJ0cy5sZW5ndGg/MDoxO248ZS5wYXJ0cy5sZW5ndGg7bisrKXt2YXIgbz1lLnBhcnRzW25dO3QubWFzcys9by5tYXNzLHQuYXJlYSs9by5hcmVhLHQuaW5lcnRpYSs9by5pbmVydGlhLHQuY2VudHJlPXIuYWRkKHQuY2VudHJlLHIubXVsdChvLnBvc2l0aW9uLG8ubWFzcyE9PTEvMD9vLm1hc3M6MSkpO1xufXJldHVybiB0LmNlbnRyZT1yLmRpdih0LmNlbnRyZSx0Lm1hc3MhPT0xLzA/dC5tYXNzOmUucGFydHMubGVuZ3RoKSx0fX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvU2xlZXBpbmdcIjoyMixcIi4uL2dlb21ldHJ5L0F4ZXNcIjoyNSxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjgsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI5LFwiLi4vcmVuZGVyL1JlbmRlclwiOjMxfV0sMjpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuLi9jb3JlL0V2ZW50c1wiKSxyPWUoXCIuLi9jb3JlL0NvbW1vblwiKSxzPWUoXCIuL0JvZHlcIik7IWZ1bmN0aW9uKCl7by5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHIuZXh0ZW5kKHtpZDpyLm5leHRJZCgpLHR5cGU6XCJjb21wb3NpdGVcIixwYXJlbnQ6bnVsbCxpc01vZGlmaWVkOiExLGJvZGllczpbXSxjb25zdHJhaW50czpbXSxjb21wb3NpdGVzOltdLGxhYmVsOlwiQ29tcG9zaXRlXCIscGx1Z2luOnt9fSxlKX0sby5zZXRNb2RpZmllZD1mdW5jdGlvbihlLHQsbixpKXtpZihlLmlzTW9kaWZpZWQ9dCxuJiZlLnBhcmVudCYmby5zZXRNb2RpZmllZChlLnBhcmVudCx0LG4saSksaSlmb3IodmFyIHI9MDtyPGUuY29tcG9zaXRlcy5sZW5ndGg7cisrKXt2YXIgcz1lLmNvbXBvc2l0ZXNbcl07by5zZXRNb2RpZmllZChzLHQsbixpKX19LG8uYWRkPWZ1bmN0aW9uKGUsdCl7dmFyIG49W10uY29uY2F0KHQpO2kudHJpZ2dlcihlLFwiYmVmb3JlQWRkXCIse29iamVjdDp0fSk7Zm9yKHZhciBzPTA7czxuLmxlbmd0aDtzKyspe3ZhciBhPW5bc107c3dpdGNoKGEudHlwZSl7Y2FzZVwiYm9keVwiOmlmKGEucGFyZW50IT09YSl7ci53YXJuKFwiQ29tcG9zaXRlLmFkZDogc2tpcHBlZCBhZGRpbmcgYSBjb21wb3VuZCBib2R5IHBhcnQgKHlvdSBtdXN0IGFkZCBpdHMgcGFyZW50IGluc3RlYWQpXCIpO2JyZWFrfW8uYWRkQm9keShlLGEpO2JyZWFrO2Nhc2VcImNvbnN0cmFpbnRcIjpvLmFkZENvbnN0cmFpbnQoZSxhKTtcbmJyZWFrO2Nhc2VcImNvbXBvc2l0ZVwiOm8uYWRkQ29tcG9zaXRlKGUsYSk7YnJlYWs7Y2FzZVwibW91c2VDb25zdHJhaW50XCI6by5hZGRDb25zdHJhaW50KGUsYS5jb25zdHJhaW50KX19cmV0dXJuIGkudHJpZ2dlcihlLFwiYWZ0ZXJBZGRcIix7b2JqZWN0OnR9KSxlfSxvLnJlbW92ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9W10uY29uY2F0KHQpO2kudHJpZ2dlcihlLFwiYmVmb3JlUmVtb3ZlXCIse29iamVjdDp0fSk7Zm9yKHZhciBzPTA7czxyLmxlbmd0aDtzKyspe3ZhciBhPXJbc107c3dpdGNoKGEudHlwZSl7Y2FzZVwiYm9keVwiOm8ucmVtb3ZlQm9keShlLGEsbik7YnJlYWs7Y2FzZVwiY29uc3RyYWludFwiOm8ucmVtb3ZlQ29uc3RyYWludChlLGEsbik7YnJlYWs7Y2FzZVwiY29tcG9zaXRlXCI6by5yZW1vdmVDb21wb3NpdGUoZSxhLG4pO2JyZWFrO2Nhc2VcIm1vdXNlQ29uc3RyYWludFwiOm8ucmVtb3ZlQ29uc3RyYWludChlLGEuY29uc3RyYWludCl9fXJldHVybiBpLnRyaWdnZXIoZSxcImFmdGVyUmVtb3ZlXCIse29iamVjdDp0fSksZX0sby5hZGRDb21wb3NpdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb21wb3NpdGVzLnB1c2godCksdC5wYXJlbnQ9ZSxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8ucmVtb3ZlQ29tcG9zaXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgaT1yLmluZGV4T2YoZS5jb21wb3NpdGVzLHQpO2lmKGkhPT0tMSYmKG8ucmVtb3ZlQ29tcG9zaXRlQXQoZSxpKSxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpKSxuKWZvcih2YXIgcz0wO3M8ZS5jb21wb3NpdGVzLmxlbmd0aDtzKyspby5yZW1vdmVDb21wb3NpdGUoZS5jb21wb3NpdGVzW3NdLHQsITApO3JldHVybiBlfSxvLnJlbW92ZUNvbXBvc2l0ZUF0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29tcG9zaXRlcy5zcGxpY2UodCwxKSxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8uYWRkQm9keT1mdW5jdGlvbihlLHQpe3JldHVybiBlLmJvZGllcy5wdXNoKHQpLG8uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSksXG5lfSxvLnJlbW92ZUJvZHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXIuaW5kZXhPZihlLmJvZGllcyx0KTtpZihpIT09LTEmJihvLnJlbW92ZUJvZHlBdChlLGkpLG8uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSkpLG4pZm9yKHZhciBzPTA7czxlLmNvbXBvc2l0ZXMubGVuZ3RoO3MrKylvLnJlbW92ZUJvZHkoZS5jb21wb3NpdGVzW3NdLHQsITApO3JldHVybiBlfSxvLnJlbW92ZUJvZHlBdD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmJvZGllcy5zcGxpY2UodCwxKSxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8uYWRkQ29uc3RyYWludD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmNvbnN0cmFpbnRzLnB1c2godCksby5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfSxvLnJlbW92ZUNvbnN0cmFpbnQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXIuaW5kZXhPZihlLmNvbnN0cmFpbnRzLHQpO2lmKGkhPT0tMSYmby5yZW1vdmVDb25zdHJhaW50QXQoZSxpKSxuKWZvcih2YXIgcz0wO3M8ZS5jb21wb3NpdGVzLmxlbmd0aDtzKyspby5yZW1vdmVDb25zdHJhaW50KGUuY29tcG9zaXRlc1tzXSx0LCEwKTtyZXR1cm4gZX0sby5yZW1vdmVDb25zdHJhaW50QXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25zdHJhaW50cy5zcGxpY2UodCwxKSxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8uY2xlYXI9ZnVuY3Rpb24oZSx0LG4pe2lmKG4pZm9yKHZhciBpPTA7aTxlLmNvbXBvc2l0ZXMubGVuZ3RoO2krKylvLmNsZWFyKGUuY29tcG9zaXRlc1tpXSx0LCEwKTtyZXR1cm4gdD9lLmJvZGllcz1lLmJvZGllcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaXNTdGF0aWN9KTplLmJvZGllcy5sZW5ndGg9MCxlLmNvbnN0cmFpbnRzLmxlbmd0aD0wLGUuY29tcG9zaXRlcy5sZW5ndGg9MCxvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8uYWxsQm9kaWVzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXS5jb25jYXQoZS5ib2RpZXMpLG49MDtuPGUuY29tcG9zaXRlcy5sZW5ndGg7bisrKXQ9dC5jb25jYXQoby5hbGxCb2RpZXMoZS5jb21wb3NpdGVzW25dKSk7XG5yZXR1cm4gdH0sby5hbGxDb25zdHJhaW50cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10uY29uY2F0KGUuY29uc3RyYWludHMpLG49MDtuPGUuY29tcG9zaXRlcy5sZW5ndGg7bisrKXQ9dC5jb25jYXQoby5hbGxDb25zdHJhaW50cyhlLmNvbXBvc2l0ZXNbbl0pKTtyZXR1cm4gdH0sby5hbGxDb21wb3NpdGVzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXS5jb25jYXQoZS5jb21wb3NpdGVzKSxuPTA7bjxlLmNvbXBvc2l0ZXMubGVuZ3RoO24rKyl0PXQuY29uY2F0KG8uYWxsQ29tcG9zaXRlcyhlLmNvbXBvc2l0ZXNbbl0pKTtyZXR1cm4gdH0sby5nZXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHI7c3dpdGNoKG4pe2Nhc2VcImJvZHlcIjppPW8uYWxsQm9kaWVzKGUpO2JyZWFrO2Nhc2VcImNvbnN0cmFpbnRcIjppPW8uYWxsQ29uc3RyYWludHMoZSk7YnJlYWs7Y2FzZVwiY29tcG9zaXRlXCI6aT1vLmFsbENvbXBvc2l0ZXMoZSkuY29uY2F0KGUpfXJldHVybiBpPyhyPWkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkLnRvU3RyaW5nKCk9PT10LnRvU3RyaW5nKCl9KSwwPT09ci5sZW5ndGg/bnVsbDpyWzBdKTpudWxsfSxvLm1vdmU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBvLnJlbW92ZShlLHQpLG8uYWRkKG4sdCksZX0sby5yZWJhc2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW8uYWxsQm9kaWVzKGUpLmNvbmNhdChvLmFsbENvbnN0cmFpbnRzKGUpKS5jb25jYXQoby5hbGxDb21wb3NpdGVzKGUpKSxuPTA7bjx0Lmxlbmd0aDtuKyspdFtuXS5pZD1yLm5leHRJZCgpO3JldHVybiBvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8udHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIGk9bj9vLmFsbEJvZGllcyhlKTplLmJvZGllcyxyPTA7cjxpLmxlbmd0aDtyKyspcy50cmFuc2xhdGUoaVtyXSx0KTtyZXR1cm4gby5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfSxvLnJvdGF0ZT1mdW5jdGlvbihlLHQsbixpKXtmb3IodmFyIHI9TWF0aC5jb3ModCksYT1NYXRoLnNpbih0KSxsPWk/by5hbGxCb2RpZXMoZSk6ZS5ib2RpZXMsYz0wO2M8bC5sZW5ndGg7YysrKXtcbnZhciBkPWxbY10sdT1kLnBvc2l0aW9uLngtbi54LHA9ZC5wb3NpdGlvbi55LW4ueTtzLnNldFBvc2l0aW9uKGQse3g6bi54Kyh1KnItcCphKSx5Om4ueSsodSphK3Aqcil9KSxzLnJvdGF0ZShkLHQpfXJldHVybiBvLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG8uc2NhbGU9ZnVuY3Rpb24oZSx0LG4saSxyKXtmb3IodmFyIGE9cj9vLmFsbEJvZGllcyhlKTplLmJvZGllcyxsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciBjPWFbbF0sZD1jLnBvc2l0aW9uLngtaS54LHU9Yy5wb3NpdGlvbi55LWkueTtzLnNldFBvc2l0aW9uKGMse3g6aS54K2QqdCx5OmkueSt1Km59KSxzLnNjYWxlKGMsdCxuKX1yZXR1cm4gby5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfSxvLmJvdW5kcz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9TWF0dGVyLkNvbXBvc2l0ZS5hbGxCb2RpZXMoZSksbj1bXSxvPTA7bzx0Lmxlbmd0aDtvKz0xKXt2YXIgaT10W29dO24ucHVzaChpLmJvdW5kcy5taW4saS5ib3VuZHMubWF4KX1yZXR1cm4gTWF0dGVyLkJvdW5kcy5jcmVhdGUobil9fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4vQm9keVwiOjF9XSwzOltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4vQ29tcG9zaXRlXCIpLHI9KGUoXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIiksZShcIi4uL2NvcmUvQ29tbW9uXCIpKTshZnVuY3Rpb24oKXtvLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD1pLmNyZWF0ZSgpLG49e2xhYmVsOlwiV29ybGRcIixncmF2aXR5Ont4OjAseToxLHNjYWxlOi4wMDF9LGJvdW5kczp7bWluOnt4Oi0oMS8wKSx5Oi0oMS8wKX0sbWF4Ont4OjEvMCx5OjEvMH19fTtyZXR1cm4gci5leHRlbmQodCxuLGUpfX0oKX0se1wiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCI6MTIsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi9Db21wb3NpdGVcIjoyfV0sNDpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vLGZ1bmN0aW9uKCl7XG5vLmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm57aWQ6by5pZChlKSx2ZXJ0ZXg6ZSxub3JtYWxJbXB1bHNlOjAsdGFuZ2VudEltcHVsc2U6MH19LG8uaWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuYm9keS5pZCtcIl9cIitlLmluZGV4fX0oKX0se31dLDU6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi9TQVRcIikscj1lKFwiLi9QYWlyXCIpLHM9ZShcIi4uL2dlb21ldHJ5L0JvdW5kc1wiKTshZnVuY3Rpb24oKXtvLmNvbGxpc2lvbnM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W10sYT10LnBhaXJzLnRhYmxlLGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIGM9ZVtsXVswXSxkPWVbbF1bMV07aWYoKCFjLmlzU3RhdGljJiYhYy5pc1NsZWVwaW5nfHwhZC5pc1N0YXRpYyYmIWQuaXNTbGVlcGluZykmJm8uY2FuQ29sbGlkZShjLmNvbGxpc2lvbkZpbHRlcixkLmNvbGxpc2lvbkZpbHRlcikmJnMub3ZlcmxhcHMoYy5ib3VuZHMsZC5ib3VuZHMpKWZvcih2YXIgdT1jLnBhcnRzLmxlbmd0aD4xPzE6MDt1PGMucGFydHMubGVuZ3RoO3UrKylmb3IodmFyIHA9Yy5wYXJ0c1t1XSxmPWQucGFydHMubGVuZ3RoPjE/MTowO2Y8ZC5wYXJ0cy5sZW5ndGg7ZisrKXt2YXIgbT1kLnBhcnRzW2ZdO2lmKHA9PT1jJiZtPT09ZHx8cy5vdmVybGFwcyhwLmJvdW5kcyxtLmJvdW5kcykpe3ZhciB2LHk9ci5pZChwLG0pLGc9YVt5XTt2PWcmJmcuaXNBY3RpdmU/Zy5jb2xsaXNpb246bnVsbDt2YXIgeD1pLmNvbGxpZGVzKHAsbSx2KTt4LmNvbGxpZGVkJiZuLnB1c2goeCl9fX1yZXR1cm4gbn0sby5jYW5Db2xsaWRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ3JvdXA9PT10Lmdyb3VwJiYwIT09ZS5ncm91cD9lLmdyb3VwPjA6MCE9PShlLm1hc2smdC5jYXRlZ29yeSkmJjAhPT0odC5tYXNrJmUuY2F0ZWdvcnkpfX0oKX0se1wiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuL1BhaXJcIjo3LFwiLi9TQVRcIjoxMX1dLDY6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bztcbnZhciBpPWUoXCIuL1BhaXJcIikscj1lKFwiLi9EZXRlY3RvclwiKSxzPWUoXCIuLi9jb3JlL0NvbW1vblwiKTshZnVuY3Rpb24oKXtvLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17Y29udHJvbGxlcjpvLGRldGVjdG9yOnIuY29sbGlzaW9ucyxidWNrZXRzOnt9LHBhaXJzOnt9LHBhaXJzTGlzdDpbXSxidWNrZXRXaWR0aDo0OCxidWNrZXRIZWlnaHQ6NDh9O3JldHVybiBzLmV4dGVuZCh0LGUpfSxvLnVwZGF0ZT1mdW5jdGlvbihuLG8saSxyKXt2YXIgcyxwLGYsbSx2LHk9aS53b3JsZCxnPW4uYnVja2V0cyx4PSExO2ZvcihzPTA7czxvLmxlbmd0aDtzKyspe3ZhciBoPW9bc107aWYoKCFoLmlzU2xlZXBpbmd8fHIpJiYhKGguYm91bmRzLm1heC54PHkuYm91bmRzLm1pbi54fHxoLmJvdW5kcy5taW4ueD55LmJvdW5kcy5tYXgueHx8aC5ib3VuZHMubWF4Lnk8eS5ib3VuZHMubWluLnl8fGguYm91bmRzLm1pbi55PnkuYm91bmRzLm1heC55KSl7dmFyIGI9dChuLGgpO2lmKCFoLnJlZ2lvbnx8Yi5pZCE9PWgucmVnaW9uLmlkfHxyKXtoLnJlZ2lvbiYmIXJ8fChoLnJlZ2lvbj1iKTt2YXIgdz1lKGIsaC5yZWdpb24pO2ZvcihwPXcuc3RhcnRDb2w7cDw9dy5lbmRDb2w7cCsrKWZvcihmPXcuc3RhcnRSb3c7Zjw9dy5lbmRSb3c7ZisrKXt2PWEocCxmKSxtPWdbdl07dmFyIFM9cD49Yi5zdGFydENvbCYmcDw9Yi5lbmRDb2wmJmY+PWIuc3RhcnRSb3cmJmY8PWIuZW5kUm93LEM9cD49aC5yZWdpb24uc3RhcnRDb2wmJnA8PWgucmVnaW9uLmVuZENvbCYmZj49aC5yZWdpb24uc3RhcnRSb3cmJmY8PWgucmVnaW9uLmVuZFJvdzshUyYmQyYmQyYmbSYmZChuLG0saCksKGgucmVnaW9uPT09Ynx8UyYmIUN8fHIpJiYobXx8KG09bChnLHYpKSxjKG4sbSxoKSl9aC5yZWdpb249Yix4PSEwfX19eCYmKG4ucGFpcnNMaXN0PXUobikpfSxvLmNsZWFyPWZ1bmN0aW9uKGUpe2UuYnVja2V0cz17fSxlLnBhaXJzPXt9LGUucGFpcnNMaXN0PVtdfTt2YXIgZT1mdW5jdGlvbihlLHQpe3ZhciBvPU1hdGgubWluKGUuc3RhcnRDb2wsdC5zdGFydENvbCksaT1NYXRoLm1heChlLmVuZENvbCx0LmVuZENvbCkscj1NYXRoLm1pbihlLnN0YXJ0Um93LHQuc3RhcnRSb3cpLHM9TWF0aC5tYXgoZS5lbmRSb3csdC5lbmRSb3cpO1xucmV0dXJuIG4obyxpLHIscyl9LHQ9ZnVuY3Rpb24oZSx0KXt2YXIgbz10LmJvdW5kcyxpPU1hdGguZmxvb3Ioby5taW4ueC9lLmJ1Y2tldFdpZHRoKSxyPU1hdGguZmxvb3Ioby5tYXgueC9lLmJ1Y2tldFdpZHRoKSxzPU1hdGguZmxvb3Ioby5taW4ueS9lLmJ1Y2tldEhlaWdodCksYT1NYXRoLmZsb29yKG8ubWF4LnkvZS5idWNrZXRIZWlnaHQpO3JldHVybiBuKGkscixzLGEpfSxuPWZ1bmN0aW9uKGUsdCxuLG8pe3JldHVybntpZDplK1wiLFwiK3QrXCIsXCIrbitcIixcIitvLHN0YXJ0Q29sOmUsZW5kQ29sOnQsc3RhcnRSb3c6bixlbmRSb3c6b319LGE9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cIkNcIitlK1wiUlwiK3R9LGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lW3RdPVtdO3JldHVybiBufSxjPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIHI9dFtvXTtpZighKG4uaWQ9PT1yLmlkfHxuLmlzU3RhdGljJiZyLmlzU3RhdGljKSl7dmFyIHM9aS5pZChuLHIpLGE9ZS5wYWlyc1tzXTthP2FbMl0rPTE6ZS5wYWlyc1tzXT1bbixyLDFdfX10LnB1c2gobil9LGQ9ZnVuY3Rpb24oZSx0LG4pe3Quc3BsaWNlKHMuaW5kZXhPZih0LG4pLDEpO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKXt2YXIgcj10W29dLGE9aS5pZChuLHIpLGw9ZS5wYWlyc1thXTtsJiYobFsyXS09MSl9fSx1PWZ1bmN0aW9uKGUpe3ZhciB0LG4sbz1bXTt0PXMua2V5cyhlLnBhaXJzKTtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyluPWUucGFpcnNbdFtpXV0sblsyXT4wP28ucHVzaChuKTpkZWxldGUgZS5wYWlyc1t0W2ldXTtyZXR1cm4gb319KCl9LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuL0RldGVjdG9yXCI6NSxcIi4vUGFpclwiOjd9XSw3OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4vQ29udGFjdFwiKTshZnVuY3Rpb24oKXtvLmNyZWF0ZT1mdW5jdGlvbihlLHQpe3ZhciBuPWUuYm9keUEsaT1lLmJvZHlCLHI9ZS5wYXJlbnRBLHM9ZS5wYXJlbnRCLGE9e1xuaWQ6by5pZChuLGkpLGJvZHlBOm4sYm9keUI6aSxjb250YWN0czp7fSxhY3RpdmVDb250YWN0czpbXSxzZXBhcmF0aW9uOjAsaXNBY3RpdmU6ITAsaXNTZW5zb3I6bi5pc1NlbnNvcnx8aS5pc1NlbnNvcix0aW1lQ3JlYXRlZDp0LHRpbWVVcGRhdGVkOnQsaW52ZXJzZU1hc3M6ci5pbnZlcnNlTWFzcytzLmludmVyc2VNYXNzLGZyaWN0aW9uOk1hdGgubWluKHIuZnJpY3Rpb24scy5mcmljdGlvbiksZnJpY3Rpb25TdGF0aWM6TWF0aC5tYXgoci5mcmljdGlvblN0YXRpYyxzLmZyaWN0aW9uU3RhdGljKSxyZXN0aXR1dGlvbjpNYXRoLm1heChyLnJlc3RpdHV0aW9uLHMucmVzdGl0dXRpb24pLHNsb3A6TWF0aC5tYXgoci5zbG9wLHMuc2xvcCl9O3JldHVybiBvLnVwZGF0ZShhLGUsdCksYX0sby51cGRhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUuY29udGFjdHMscz10LnN1cHBvcnRzLGE9ZS5hY3RpdmVDb250YWN0cyxsPXQucGFyZW50QSxjPXQucGFyZW50QjtpZihlLmNvbGxpc2lvbj10LGUuaW52ZXJzZU1hc3M9bC5pbnZlcnNlTWFzcytjLmludmVyc2VNYXNzLGUuZnJpY3Rpb249TWF0aC5taW4obC5mcmljdGlvbixjLmZyaWN0aW9uKSxlLmZyaWN0aW9uU3RhdGljPU1hdGgubWF4KGwuZnJpY3Rpb25TdGF0aWMsYy5mcmljdGlvblN0YXRpYyksZS5yZXN0aXR1dGlvbj1NYXRoLm1heChsLnJlc3RpdHV0aW9uLGMucmVzdGl0dXRpb24pLGUuc2xvcD1NYXRoLm1heChsLnNsb3AsYy5zbG9wKSxhLmxlbmd0aD0wLHQuY29sbGlkZWQpe2Zvcih2YXIgZD0wO2Q8cy5sZW5ndGg7ZCsrKXt2YXIgdT1zW2RdLHA9aS5pZCh1KSxmPXJbcF07Zj9hLnB1c2goZik6YS5wdXNoKHJbcF09aS5jcmVhdGUodSkpfWUuc2VwYXJhdGlvbj10LmRlcHRoLG8uc2V0QWN0aXZlKGUsITAsbil9ZWxzZSBlLmlzQWN0aXZlPT09ITAmJm8uc2V0QWN0aXZlKGUsITEsbil9LG8uc2V0QWN0aXZlPWZ1bmN0aW9uKGUsdCxuKXt0PyhlLmlzQWN0aXZlPSEwLGUudGltZVVwZGF0ZWQ9bik6KGUuaXNBY3RpdmU9ITEsXG5lLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aD0wKX0sby5pZD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmlkPHQuaWQ/XCJBXCIrZS5pZCtcIkJcIit0LmlkOlwiQVwiK3QuaWQrXCJCXCIrZS5pZH19KCl9LHtcIi4vQ29udGFjdFwiOjR9XSw4OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4vUGFpclwiKSxyPWUoXCIuLi9jb3JlL0NvbW1vblwiKTshZnVuY3Rpb24oKXt2YXIgZT0xZTM7by5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHIuZXh0ZW5kKHt0YWJsZTp7fSxsaXN0OltdLGNvbGxpc2lvblN0YXJ0OltdLGNvbGxpc2lvbkFjdGl2ZTpbXSxjb2xsaXNpb25FbmQ6W119LGUpfSxvLnVwZGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIG8scyxhLGwsYz1lLmxpc3QsZD1lLnRhYmxlLHU9ZS5jb2xsaXNpb25TdGFydCxwPWUuY29sbGlzaW9uRW5kLGY9ZS5jb2xsaXNpb25BY3RpdmUsbT1bXTtmb3IodS5sZW5ndGg9MCxwLmxlbmd0aD0wLGYubGVuZ3RoPTAsbD0wO2w8dC5sZW5ndGg7bCsrKW89dFtsXSxvLmNvbGxpZGVkJiYocz1pLmlkKG8uYm9keUEsby5ib2R5QiksbS5wdXNoKHMpLGE9ZFtzXSxhPyhhLmlzQWN0aXZlP2YucHVzaChhKTp1LnB1c2goYSksaS51cGRhdGUoYSxvLG4pKTooYT1pLmNyZWF0ZShvLG4pLGRbc109YSx1LnB1c2goYSksYy5wdXNoKGEpKSk7Zm9yKGw9MDtsPGMubGVuZ3RoO2wrKylhPWNbbF0sYS5pc0FjdGl2ZSYmci5pbmRleE9mKG0sYS5pZCk9PT0tMSYmKGkuc2V0QWN0aXZlKGEsITEsbikscC5wdXNoKGEpKX0sby5yZW1vdmVPbGQ9ZnVuY3Rpb24odCxuKXt2YXIgbyxpLHIscyxhPXQubGlzdCxsPXQudGFibGUsYz1bXTtmb3Iocz0wO3M8YS5sZW5ndGg7cysrKW89YVtzXSxpPW8uY29sbGlzaW9uLGkuYm9keUEuaXNTbGVlcGluZ3x8aS5ib2R5Qi5pc1NsZWVwaW5nP28udGltZVVwZGF0ZWQ9bjpuLW8udGltZVVwZGF0ZWQ+ZSYmYy5wdXNoKHMpO2ZvcihzPTA7czxjLmxlbmd0aDtzKyspcj1jW3NdLXMsbz1hW3JdLGRlbGV0ZSBsW28uaWRdLFxuYS5zcGxpY2UociwxKX0sby5jbGVhcj1mdW5jdGlvbihlKXtyZXR1cm4gZS50YWJsZT17fSxlLmxpc3QubGVuZ3RoPTAsZS5jb2xsaXNpb25TdGFydC5sZW5ndGg9MCxlLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGg9MCxlLmNvbGxpc2lvbkVuZC5sZW5ndGg9MCxlfX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4vUGFpclwiOjd9XSw5OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxyPWUoXCIuL1NBVFwiKSxzPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIiksYT1lKFwiLi4vZmFjdG9yeS9Cb2RpZXNcIiksbD1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIik7IWZ1bmN0aW9uKCl7by5yYXk9ZnVuY3Rpb24oZSx0LG4sbyl7bz1vfHwxZS0xMDA7Zm9yKHZhciBsPWkuYW5nbGUodCxuKSxjPWkubWFnbml0dWRlKGkuc3ViKHQsbikpLGQ9LjUqKG4ueCt0LngpLHU9LjUqKG4ueSt0LnkpLHA9YS5yZWN0YW5nbGUoZCx1LGMsbyx7YW5nbGU6bH0pLGY9W10sbT0wO208ZS5sZW5ndGg7bSsrKXt2YXIgdj1lW21dO2lmKHMub3ZlcmxhcHModi5ib3VuZHMscC5ib3VuZHMpKWZvcih2YXIgeT0xPT09di5wYXJ0cy5sZW5ndGg/MDoxO3k8di5wYXJ0cy5sZW5ndGg7eSsrKXt2YXIgZz12LnBhcnRzW3ldO2lmKHMub3ZlcmxhcHMoZy5ib3VuZHMscC5ib3VuZHMpKXt2YXIgeD1yLmNvbGxpZGVzKGcscCk7aWYoeC5jb2xsaWRlZCl7eC5ib2R5PXguYm9keUE9eC5ib2R5Qj12LGYucHVzaCh4KTticmVha319fX1yZXR1cm4gZn0sby5yZWdpb249ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgbz1bXSxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciByPWVbaV0sYT1zLm92ZXJsYXBzKHIuYm91bmRzLHQpOyhhJiYhbnx8IWEmJm4pJiZvLnB1c2gocil9cmV0dXJuIG99LG8ucG9pbnQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W10sbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgaT1lW29dO2lmKHMuY29udGFpbnMoaS5ib3VuZHMsdCkpZm9yKHZhciByPTE9PT1pLnBhcnRzLmxlbmd0aD8wOjE7cjxpLnBhcnRzLmxlbmd0aDtyKyspe1xudmFyIGE9aS5wYXJ0c1tyXTtpZihzLmNvbnRhaW5zKGEuYm91bmRzLHQpJiZsLmNvbnRhaW5zKGEudmVydGljZXMsdCkpe24ucHVzaChpKTticmVha319fXJldHVybiBufX0oKX0se1wiLi4vZmFjdG9yeS9Cb2RpZXNcIjoyMyxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjgsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI5LFwiLi9TQVRcIjoxMX1dLDEwOltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxzPWUoXCIuLi9jb3JlL0NvbW1vblwiKSxhPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIik7IWZ1bmN0aW9uKCl7by5fcmVzdGluZ1RocmVzaD00LG8uX3Jlc3RpbmdUaHJlc2hUYW5nZW50PTYsby5fcG9zaXRpb25EYW1wZW49Ljksby5fcG9zaXRpb25XYXJtaW5nPS44LG8uX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllcj01LG8ucHJlU29sdmVQb3NpdGlvbj1mdW5jdGlvbihlKXt2YXIgdCxuLG87Zm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyluPWVbdF0sbi5pc0FjdGl2ZSYmKG89bi5hY3RpdmVDb250YWN0cy5sZW5ndGgsbi5jb2xsaXNpb24ucGFyZW50QS50b3RhbENvbnRhY3RzKz1vLG4uY29sbGlzaW9uLnBhcmVudEIudG90YWxDb250YWN0cys9byl9LG8uc29sdmVQb3NpdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBuLGkscyxhLGwsYyxkLHUscCxmPXIuX3RlbXBbMF0sbT1yLl90ZW1wWzFdLHY9ci5fdGVtcFsyXSx5PXIuX3RlbXBbM107Zm9yKG49MDtuPGUubGVuZ3RoO24rKylpPWVbbl0saS5pc0FjdGl2ZSYmIWkuaXNTZW5zb3ImJihzPWkuY29sbGlzaW9uLGE9cy5wYXJlbnRBLGw9cy5wYXJlbnRCLGM9cy5ub3JtYWwsZD1yLnN1YihyLmFkZChsLnBvc2l0aW9uSW1wdWxzZSxsLnBvc2l0aW9uLGYpLHIuYWRkKGEucG9zaXRpb25JbXB1bHNlLHIuc3ViKGwucG9zaXRpb24scy5wZW5ldHJhdGlvbixtKSx2KSx5KSxpLnNlcGFyYXRpb249ci5kb3QoYyxkKSk7XG5mb3Iobj0wO248ZS5sZW5ndGg7bisrKWk9ZVtuXSxpLmlzQWN0aXZlJiYhaS5pc1NlbnNvciYmKHM9aS5jb2xsaXNpb24sYT1zLnBhcmVudEEsbD1zLnBhcmVudEIsYz1zLm5vcm1hbCxwPShpLnNlcGFyYXRpb24taS5zbG9wKSp0LChhLmlzU3RhdGljfHxsLmlzU3RhdGljKSYmKHAqPTIpLGEuaXNTdGF0aWN8fGEuaXNTbGVlcGluZ3x8KHU9by5fcG9zaXRpb25EYW1wZW4vYS50b3RhbENvbnRhY3RzLGEucG9zaXRpb25JbXB1bHNlLngrPWMueCpwKnUsYS5wb3NpdGlvbkltcHVsc2UueSs9Yy55KnAqdSksbC5pc1N0YXRpY3x8bC5pc1NsZWVwaW5nfHwodT1vLl9wb3NpdGlvbkRhbXBlbi9sLnRvdGFsQ29udGFjdHMsbC5wb3NpdGlvbkltcHVsc2UueC09Yy54KnAqdSxsLnBvc2l0aW9uSW1wdWxzZS55LT1jLnkqcCp1KSl9LG8ucG9zdFNvbHZlUG9zaXRpb249ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBuPWVbdF07aWYobi50b3RhbENvbnRhY3RzPTAsMCE9PW4ucG9zaXRpb25JbXB1bHNlLnh8fDAhPT1uLnBvc2l0aW9uSW1wdWxzZS55KXtmb3IodmFyIHM9MDtzPG4ucGFydHMubGVuZ3RoO3MrKyl7dmFyIGw9bi5wYXJ0c1tzXTtpLnRyYW5zbGF0ZShsLnZlcnRpY2VzLG4ucG9zaXRpb25JbXB1bHNlKSxhLnVwZGF0ZShsLmJvdW5kcyxsLnZlcnRpY2VzLG4udmVsb2NpdHkpLGwucG9zaXRpb24ueCs9bi5wb3NpdGlvbkltcHVsc2UueCxsLnBvc2l0aW9uLnkrPW4ucG9zaXRpb25JbXB1bHNlLnl9bi5wb3NpdGlvblByZXYueCs9bi5wb3NpdGlvbkltcHVsc2UueCxuLnBvc2l0aW9uUHJldi55Kz1uLnBvc2l0aW9uSW1wdWxzZS55LHIuZG90KG4ucG9zaXRpb25JbXB1bHNlLG4udmVsb2NpdHkpPDA/KG4ucG9zaXRpb25JbXB1bHNlLng9MCxuLnBvc2l0aW9uSW1wdWxzZS55PTApOihuLnBvc2l0aW9uSW1wdWxzZS54Kj1vLl9wb3NpdGlvbldhcm1pbmcsbi5wb3NpdGlvbkltcHVsc2UueSo9by5fcG9zaXRpb25XYXJtaW5nKX19fSxvLnByZVNvbHZlVmVsb2NpdHk9ZnVuY3Rpb24oZSl7XG52YXIgdCxuLG8saSxzLGEsbCxjLGQsdSxwLGYsbSx2LHk9ci5fdGVtcFswXSxnPXIuX3RlbXBbMV07Zm9yKHQ9MDt0PGUubGVuZ3RoO3QrKylpZihvPWVbdF0sby5pc0FjdGl2ZSYmIW8uaXNTZW5zb3IpZm9yKGk9by5hY3RpdmVDb250YWN0cyxzPW8uY29sbGlzaW9uLGE9cy5wYXJlbnRBLGw9cy5wYXJlbnRCLGM9cy5ub3JtYWwsZD1zLnRhbmdlbnQsbj0wO248aS5sZW5ndGg7bisrKXU9aVtuXSxwPXUudmVydGV4LGY9dS5ub3JtYWxJbXB1bHNlLG09dS50YW5nZW50SW1wdWxzZSwwPT09ZiYmMD09PW18fCh5Lng9Yy54KmYrZC54Km0seS55PWMueSpmK2QueSptLGEuaXNTdGF0aWN8fGEuaXNTbGVlcGluZ3x8KHY9ci5zdWIocCxhLnBvc2l0aW9uLGcpLGEucG9zaXRpb25QcmV2LngrPXkueCphLmludmVyc2VNYXNzLGEucG9zaXRpb25QcmV2LnkrPXkueSphLmludmVyc2VNYXNzLGEuYW5nbGVQcmV2Kz1yLmNyb3NzKHYseSkqYS5pbnZlcnNlSW5lcnRpYSksbC5pc1N0YXRpY3x8bC5pc1NsZWVwaW5nfHwodj1yLnN1YihwLGwucG9zaXRpb24sZyksbC5wb3NpdGlvblByZXYueC09eS54KmwuaW52ZXJzZU1hc3MsbC5wb3NpdGlvblByZXYueS09eS55KmwuaW52ZXJzZU1hc3MsbC5hbmdsZVByZXYtPXIuY3Jvc3Modix5KSpsLmludmVyc2VJbmVydGlhKSl9LG8uc29sdmVWZWxvY2l0eT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10KnQsaT1yLl90ZW1wWzBdLGE9ci5fdGVtcFsxXSxsPXIuX3RlbXBbMl0sYz1yLl90ZW1wWzNdLGQ9ci5fdGVtcFs0XSx1PXIuX3RlbXBbNV0scD0wO3A8ZS5sZW5ndGg7cCsrKXt2YXIgZj1lW3BdO2lmKGYuaXNBY3RpdmUmJiFmLmlzU2Vuc29yKXt2YXIgbT1mLmNvbGxpc2lvbix2PW0ucGFyZW50QSx5PW0ucGFyZW50QixnPW0ubm9ybWFsLHg9bS50YW5nZW50LGg9Zi5hY3RpdmVDb250YWN0cyxiPTEvaC5sZW5ndGg7di52ZWxvY2l0eS54PXYucG9zaXRpb24ueC12LnBvc2l0aW9uUHJldi54LHYudmVsb2NpdHkueT12LnBvc2l0aW9uLnktdi5wb3NpdGlvblByZXYueSxcbnkudmVsb2NpdHkueD15LnBvc2l0aW9uLngteS5wb3NpdGlvblByZXYueCx5LnZlbG9jaXR5Lnk9eS5wb3NpdGlvbi55LXkucG9zaXRpb25QcmV2Lnksdi5hbmd1bGFyVmVsb2NpdHk9di5hbmdsZS12LmFuZ2xlUHJldix5LmFuZ3VsYXJWZWxvY2l0eT15LmFuZ2xlLXkuYW5nbGVQcmV2O2Zvcih2YXIgdz0wO3c8aC5sZW5ndGg7dysrKXt2YXIgUz1oW3ddLEM9Uy52ZXJ0ZXgsQT1yLnN1YihDLHYucG9zaXRpb24sYSksUD1yLnN1YihDLHkucG9zaXRpb24sbCksQj1yLmFkZCh2LnZlbG9jaXR5LHIubXVsdChyLnBlcnAoQSksdi5hbmd1bGFyVmVsb2NpdHkpLGMpLE09ci5hZGQoeS52ZWxvY2l0eSxyLm11bHQoci5wZXJwKFApLHkuYW5ndWxhclZlbG9jaXR5KSxkKSxrPXIuc3ViKEIsTSx1KSxJPXIuZG90KGcsayksVD1yLmRvdCh4LGspLFY9TWF0aC5hYnMoVCksXz1zLnNpZ24oVCksUj0oMStmLnJlc3RpdHV0aW9uKSpJLEU9cy5jbGFtcChmLnNlcGFyYXRpb24rSSwwLDEpKm8uX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllcixMPVQsRj0xLzA7Vj5mLmZyaWN0aW9uKmYuZnJpY3Rpb25TdGF0aWMqRSpuJiYoRj1WLEw9cy5jbGFtcChmLmZyaWN0aW9uKl8qbiwtRixGKSk7dmFyIE89ci5jcm9zcyhBLGcpLHE9ci5jcm9zcyhQLGcpLFc9Yi8odi5pbnZlcnNlTWFzcyt5LmludmVyc2VNYXNzK3YuaW52ZXJzZUluZXJ0aWEqTypPK3kuaW52ZXJzZUluZXJ0aWEqcSpxKTtpZihSKj1XLEwqPVcsSTwwJiZJKkk+by5fcmVzdGluZ1RocmVzaCpuKVMubm9ybWFsSW1wdWxzZT0wO2Vsc2V7dmFyIEQ9Uy5ub3JtYWxJbXB1bHNlO1Mubm9ybWFsSW1wdWxzZT1NYXRoLm1pbihTLm5vcm1hbEltcHVsc2UrUiwwKSxSPVMubm9ybWFsSW1wdWxzZS1EfWlmKFQqVD5vLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCpuKVMudGFuZ2VudEltcHVsc2U9MDtlbHNle3ZhciBOPVMudGFuZ2VudEltcHVsc2U7Uy50YW5nZW50SW1wdWxzZT1zLmNsYW1wKFMudGFuZ2VudEltcHVsc2UrTCwtRixGKSxMPVMudGFuZ2VudEltcHVsc2UtTjtcbn1pLng9Zy54KlIreC54KkwsaS55PWcueSpSK3gueSpMLHYuaXNTdGF0aWN8fHYuaXNTbGVlcGluZ3x8KHYucG9zaXRpb25QcmV2LngrPWkueCp2LmludmVyc2VNYXNzLHYucG9zaXRpb25QcmV2LnkrPWkueSp2LmludmVyc2VNYXNzLHYuYW5nbGVQcmV2Kz1yLmNyb3NzKEEsaSkqdi5pbnZlcnNlSW5lcnRpYSkseS5pc1N0YXRpY3x8eS5pc1NsZWVwaW5nfHwoeS5wb3NpdGlvblByZXYueC09aS54KnkuaW52ZXJzZU1hc3MseS5wb3NpdGlvblByZXYueS09aS55KnkuaW52ZXJzZU1hc3MseS5hbmdsZVByZXYtPXIuY3Jvc3MoUCxpKSp5LmludmVyc2VJbmVydGlhKX19fX19KCl9LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOX1dLDExOltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKTshZnVuY3Rpb24oKXtvLmNvbGxpZGVzPWZ1bmN0aW9uKHQsbyxzKXt2YXIgYSxsLGMsZCx1PSExO2lmKHMpe3ZhciBwPXQucGFyZW50LGY9by5wYXJlbnQsbT1wLnNwZWVkKnAuc3BlZWQrcC5hbmd1bGFyU3BlZWQqcC5hbmd1bGFyU3BlZWQrZi5zcGVlZCpmLnNwZWVkK2YuYW5ndWxhclNwZWVkKmYuYW5ndWxhclNwZWVkO3U9cyYmcy5jb2xsaWRlZCYmbTwuMixkPXN9ZWxzZSBkPXtjb2xsaWRlZDohMSxib2R5QTp0LGJvZHlCOm99O2lmKHMmJnUpe3ZhciB2PWQuYXhpc0JvZHkseT12PT09dD9vOnQsZz1bdi5heGVzW3MuYXhpc051bWJlcl1dO2lmKGM9ZSh2LnZlcnRpY2VzLHkudmVydGljZXMsZyksZC5yZXVzZWQ9ITAsYy5vdmVybGFwPD0wKXJldHVybiBkLmNvbGxpZGVkPSExLGR9ZWxzZXtpZihhPWUodC52ZXJ0aWNlcyxvLnZlcnRpY2VzLHQuYXhlcyksYS5vdmVybGFwPD0wKXJldHVybiBkLmNvbGxpZGVkPSExLGQ7aWYobD1lKG8udmVydGljZXMsdC52ZXJ0aWNlcyxvLmF4ZXMpLFxubC5vdmVybGFwPD0wKXJldHVybiBkLmNvbGxpZGVkPSExLGQ7YS5vdmVybGFwPGwub3ZlcmxhcD8oYz1hLGQuYXhpc0JvZHk9dCk6KGM9bCxkLmF4aXNCb2R5PW8pLGQuYXhpc051bWJlcj1jLmF4aXNOdW1iZXJ9ZC5ib2R5QT10LmlkPG8uaWQ/dDpvLGQuYm9keUI9dC5pZDxvLmlkP286dCxkLmNvbGxpZGVkPSEwLGQuZGVwdGg9Yy5vdmVybGFwLGQucGFyZW50QT1kLmJvZHlBLnBhcmVudCxkLnBhcmVudEI9ZC5ib2R5Qi5wYXJlbnQsdD1kLmJvZHlBLG89ZC5ib2R5QixyLmRvdChjLmF4aXMsci5zdWIoby5wb3NpdGlvbix0LnBvc2l0aW9uKSk8MD9kLm5vcm1hbD17eDpjLmF4aXMueCx5OmMuYXhpcy55fTpkLm5vcm1hbD17eDotYy5heGlzLngseTotYy5heGlzLnl9LGQudGFuZ2VudD1yLnBlcnAoZC5ub3JtYWwpLGQucGVuZXRyYXRpb249ZC5wZW5ldHJhdGlvbnx8e30sZC5wZW5ldHJhdGlvbi54PWQubm9ybWFsLngqZC5kZXB0aCxkLnBlbmV0cmF0aW9uLnk9ZC5ub3JtYWwueSpkLmRlcHRoO3ZhciB4PW4odCxvLGQubm9ybWFsKSxoPVtdO2lmKGkuY29udGFpbnModC52ZXJ0aWNlcyx4WzBdKSYmaC5wdXNoKHhbMF0pLGkuY29udGFpbnModC52ZXJ0aWNlcyx4WzFdKSYmaC5wdXNoKHhbMV0pLGgubGVuZ3RoPDIpe3ZhciBiPW4obyx0LHIubmVnKGQubm9ybWFsKSk7aS5jb250YWlucyhvLnZlcnRpY2VzLGJbMF0pJiZoLnB1c2goYlswXSksaC5sZW5ndGg8MiYmaS5jb250YWlucyhvLnZlcnRpY2VzLGJbMV0pJiZoLnB1c2goYlsxXSl9cmV0dXJuIGgubGVuZ3RoPDEmJihoPVt4WzBdXSksZC5zdXBwb3J0cz1oLGR9O3ZhciBlPWZ1bmN0aW9uKGUsbixvKXtmb3IodmFyIGkscyxhPXIuX3RlbXBbMF0sbD1yLl90ZW1wWzFdLGM9e292ZXJsYXA6TnVtYmVyLk1BWF9WQUxVRX0sZD0wO2Q8by5sZW5ndGg7ZCsrKXtpZihzPW9bZF0sdChhLGUscyksdChsLG4scyksaT1NYXRoLm1pbihhLm1heC1sLm1pbixsLm1heC1hLm1pbiksaTw9MClyZXR1cm4gYy5vdmVybGFwPWksXG5jO2k8Yy5vdmVybGFwJiYoYy5vdmVybGFwPWksYy5heGlzPXMsYy5heGlzTnVtYmVyPWQpfXJldHVybiBjfSx0PWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIG89ci5kb3QodFswXSxuKSxpPW8scz0xO3M8dC5sZW5ndGg7cys9MSl7dmFyIGE9ci5kb3QodFtzXSxuKTthPmk/aT1hOmE8byYmKG89YSl9ZS5taW49byxlLm1heD1pfSxuPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIG8saSxzLGEsbD1OdW1iZXIuTUFYX1ZBTFVFLGM9ci5fdGVtcFswXSxkPXQudmVydGljZXMsdT1lLnBvc2l0aW9uLHA9MDtwPGQubGVuZ3RoO3ArKylpPWRbcF0sYy54PWkueC11LngsYy55PWkueS11Lnksbz0tci5kb3QobixjKSxvPGwmJihsPW8scz1pKTt2YXIgZj1zLmluZGV4LTE+PTA/cy5pbmRleC0xOmQubGVuZ3RoLTE7aT1kW2ZdLGMueD1pLngtdS54LGMueT1pLnktdS55LGw9LXIuZG90KG4sYyksYT1pO3ZhciBtPShzLmluZGV4KzEpJWQubGVuZ3RoO3JldHVybiBpPWRbbV0sYy54PWkueC11LngsYy55PWkueS11Lnksbz0tci5kb3QobixjKSxvPGwmJihhPWkpLFtzLGFdfX0oKX0se1wiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjgsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI5fV0sMTI6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIikscj1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLHM9ZShcIi4uL2NvcmUvU2xlZXBpbmdcIiksYT1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLGw9ZShcIi4uL2dlb21ldHJ5L0F4ZXNcIiksYz1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7by5fd2FybWluZz0uNCxvLl90b3JxdWVEYW1wZW49MSxvLl9taW5MZW5ndGg9MWUtNixvLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD1lO3QuYm9keUEmJiF0LnBvaW50QSYmKHQucG9pbnRBPXt4OjAseTowfSksdC5ib2R5QiYmIXQucG9pbnRCJiYodC5wb2ludEI9e3g6MCx5OjB9KTt2YXIgbj10LmJvZHlBP3IuYWRkKHQuYm9keUEucG9zaXRpb24sdC5wb2ludEEpOnQucG9pbnRBLG89dC5ib2R5Qj9yLmFkZCh0LmJvZHlCLnBvc2l0aW9uLHQucG9pbnRCKTp0LnBvaW50QixpPXIubWFnbml0dWRlKHIuc3ViKG4sbykpO1xudC5sZW5ndGg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQubGVuZ3RoP3QubGVuZ3RoOmksdC5pZD10LmlkfHxjLm5leHRJZCgpLHQubGFiZWw9dC5sYWJlbHx8XCJDb25zdHJhaW50XCIsdC50eXBlPVwiY29uc3RyYWludFwiLHQuc3RpZmZuZXNzPXQuc3RpZmZuZXNzfHwodC5sZW5ndGg+MD8xOi43KSx0LmRhbXBpbmc9dC5kYW1waW5nfHwwLHQuYW5ndWxhclN0aWZmbmVzcz10LmFuZ3VsYXJTdGlmZm5lc3N8fDAsdC5hbmdsZUE9dC5ib2R5QT90LmJvZHlBLmFuZ2xlOnQuYW5nbGVBLHQuYW5nbGVCPXQuYm9keUI/dC5ib2R5Qi5hbmdsZTp0LmFuZ2xlQix0LnBsdWdpbj17fTt2YXIgcz17dmlzaWJsZTohMCxsaW5lV2lkdGg6MixzdHJva2VTdHlsZTpcIiNmZmZmZmZcIix0eXBlOlwibGluZVwiLGFuY2hvcnM6ITB9O3JldHVybiAwPT09dC5sZW5ndGgmJnQuc3RpZmZuZXNzPi4xPyhzLnR5cGU9XCJwaW5cIixzLmFuY2hvcnM9ITEpOnQuc3RpZmZuZXNzPC45JiYocy50eXBlPVwic3ByaW5nXCIpLHQucmVuZGVyPWMuZXh0ZW5kKHMsdC5yZW5kZXIpLHR9LG8ucHJlU29sdmVBbGw9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kz0xKXt2YXIgbj1lW3RdLG89bi5jb25zdHJhaW50SW1wdWxzZTtuLmlzU3RhdGljfHwwPT09by54JiYwPT09by55JiYwPT09by5hbmdsZXx8KG4ucG9zaXRpb24ueCs9by54LG4ucG9zaXRpb24ueSs9by55LG4uYW5nbGUrPW8uYW5nbGUpfX0sby5zb2x2ZUFsbD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9MSl7dmFyIGk9ZVtuXSxyPSFpLmJvZHlBfHxpLmJvZHlBJiZpLmJvZHlBLmlzU3RhdGljLHM9IWkuYm9keUJ8fGkuYm9keUImJmkuYm9keUIuaXNTdGF0aWM7KHJ8fHMpJiZvLnNvbHZlKGVbbl0sdCl9Zm9yKG49MDtuPGUubGVuZ3RoO24rPTEpaT1lW25dLHI9IWkuYm9keUF8fGkuYm9keUEmJmkuYm9keUEuaXNTdGF0aWMscz0haS5ib2R5Qnx8aS5ib2R5QiYmaS5ib2R5Qi5pc1N0YXRpYyxyfHxzfHxvLnNvbHZlKGVbbl0sdCk7XG59LG8uc29sdmU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmJvZHlBLGk9ZS5ib2R5QixzPWUucG9pbnRBLGE9ZS5wb2ludEI7aWYobnx8aSl7biYmIW4uaXNTdGF0aWMmJihyLnJvdGF0ZShzLG4uYW5nbGUtZS5hbmdsZUEscyksZS5hbmdsZUE9bi5hbmdsZSksaSYmIWkuaXNTdGF0aWMmJihyLnJvdGF0ZShhLGkuYW5nbGUtZS5hbmdsZUIsYSksZS5hbmdsZUI9aS5hbmdsZSk7dmFyIGw9cyxjPWE7aWYobiYmKGw9ci5hZGQobi5wb3NpdGlvbixzKSksaSYmKGM9ci5hZGQoaS5wb3NpdGlvbixhKSksbCYmYyl7dmFyIGQ9ci5zdWIobCxjKSx1PXIubWFnbml0dWRlKGQpO3U8by5fbWluTGVuZ3RoJiYodT1vLl9taW5MZW5ndGgpO3ZhciBwLGYsbSx2LHksZz0odS1lLmxlbmd0aCkvdSx4PWUuc3RpZmZuZXNzPDE/ZS5zdGlmZm5lc3MqdDplLnN0aWZmbmVzcyxoPXIubXVsdChkLGcqeCksYj0obj9uLmludmVyc2VNYXNzOjApKyhpP2kuaW52ZXJzZU1hc3M6MCksdz0obj9uLmludmVyc2VJbmVydGlhOjApKyhpP2kuaW52ZXJzZUluZXJ0aWE6MCksUz1iK3c7aWYoZS5kYW1waW5nKXt2YXIgQz1yLmNyZWF0ZSgpO209ci5kaXYoZCx1KSx5PXIuc3ViKGkmJnIuc3ViKGkucG9zaXRpb24saS5wb3NpdGlvblByZXYpfHxDLG4mJnIuc3ViKG4ucG9zaXRpb24sbi5wb3NpdGlvblByZXYpfHxDKSx2PXIuZG90KG0seSl9biYmIW4uaXNTdGF0aWMmJihmPW4uaW52ZXJzZU1hc3MvYixuLmNvbnN0cmFpbnRJbXB1bHNlLngtPWgueCpmLG4uY29uc3RyYWludEltcHVsc2UueS09aC55KmYsbi5wb3NpdGlvbi54LT1oLngqZixuLnBvc2l0aW9uLnktPWgueSpmLGUuZGFtcGluZyYmKG4ucG9zaXRpb25QcmV2LngtPWUuZGFtcGluZyptLngqdipmLG4ucG9zaXRpb25QcmV2LnktPWUuZGFtcGluZyptLnkqdipmKSxwPXIuY3Jvc3MocyxoKS9TKm8uX3RvcnF1ZURhbXBlbipuLmludmVyc2VJbmVydGlhKigxLWUuYW5ndWxhclN0aWZmbmVzcyksbi5jb25zdHJhaW50SW1wdWxzZS5hbmdsZS09cCxcbm4uYW5nbGUtPXApLGkmJiFpLmlzU3RhdGljJiYoZj1pLmludmVyc2VNYXNzL2IsaS5jb25zdHJhaW50SW1wdWxzZS54Kz1oLngqZixpLmNvbnN0cmFpbnRJbXB1bHNlLnkrPWgueSpmLGkucG9zaXRpb24ueCs9aC54KmYsaS5wb3NpdGlvbi55Kz1oLnkqZixlLmRhbXBpbmcmJihpLnBvc2l0aW9uUHJldi54Kz1lLmRhbXBpbmcqbS54KnYqZixpLnBvc2l0aW9uUHJldi55Kz1lLmRhbXBpbmcqbS55KnYqZikscD1yLmNyb3NzKGEsaCkvUypvLl90b3JxdWVEYW1wZW4qaS5pbnZlcnNlSW5lcnRpYSooMS1lLmFuZ3VsYXJTdGlmZm5lc3MpLGkuY29uc3RyYWludEltcHVsc2UuYW5nbGUrPXAsaS5hbmdsZSs9cCl9fX0sby5wb3N0U29sdmVBbGw9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBuPWVbdF0sYz1uLmNvbnN0cmFpbnRJbXB1bHNlO2lmKCEobi5pc1N0YXRpY3x8MD09PWMueCYmMD09PWMueSYmMD09PWMuYW5nbGUpKXtzLnNldChuLCExKTtmb3IodmFyIGQ9MDtkPG4ucGFydHMubGVuZ3RoO2QrKyl7dmFyIHU9bi5wYXJ0c1tkXTtpLnRyYW5zbGF0ZSh1LnZlcnRpY2VzLGMpLGQ+MCYmKHUucG9zaXRpb24ueCs9Yy54LHUucG9zaXRpb24ueSs9Yy55KSwwIT09Yy5hbmdsZSYmKGkucm90YXRlKHUudmVydGljZXMsYy5hbmdsZSxuLnBvc2l0aW9uKSxsLnJvdGF0ZSh1LmF4ZXMsYy5hbmdsZSksZD4wJiZyLnJvdGF0ZUFib3V0KHUucG9zaXRpb24sYy5hbmdsZSxuLnBvc2l0aW9uLHUucG9zaXRpb24pKSxhLnVwZGF0ZSh1LmJvdW5kcyx1LnZlcnRpY2VzLG4udmVsb2NpdHkpfWMuYW5nbGUqPW8uX3dhcm1pbmcsYy54Kj1vLl93YXJtaW5nLGMueSo9by5fd2FybWluZ319fX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvU2xlZXBpbmdcIjoyMixcIi4uL2dlb21ldHJ5L0F4ZXNcIjoyNSxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjgsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI5fV0sMTM6W2Z1bmN0aW9uKGUsdCxuKXtcbnZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiKSxyPWUoXCIuLi9jb3JlL1NsZWVwaW5nXCIpLHM9ZShcIi4uL2NvcmUvTW91c2VcIiksYT1lKFwiLi4vY29yZS9FdmVudHNcIiksbD1lKFwiLi4vY29sbGlzaW9uL0RldGVjdG9yXCIpLGM9ZShcIi4vQ29uc3RyYWludFwiKSxkPWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSx1PWUoXCIuLi9jb3JlL0NvbW1vblwiKSxwPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIik7IWZ1bmN0aW9uKCl7by5jcmVhdGU9ZnVuY3Rpb24odCxuKXt2YXIgaT0odD90Lm1vdXNlOm51bGwpfHwobj9uLm1vdXNlOm51bGwpO2l8fCh0JiZ0LnJlbmRlciYmdC5yZW5kZXIuY2FudmFzP2k9cy5jcmVhdGUodC5yZW5kZXIuY2FudmFzKTpuJiZuLmVsZW1lbnQ/aT1zLmNyZWF0ZShuLmVsZW1lbnQpOihpPXMuY3JlYXRlKCksdS53YXJuKFwiTW91c2VDb25zdHJhaW50LmNyZWF0ZTogb3B0aW9ucy5tb3VzZSB3YXMgdW5kZWZpbmVkLCBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgbWF5IG5vdCBmdW5jdGlvbiBhcyBleHBlY3RlZFwiKSkpO3ZhciByPWMuY3JlYXRlKHtsYWJlbDpcIk1vdXNlIENvbnN0cmFpbnRcIixwb2ludEE6aS5wb3NpdGlvbixwb2ludEI6e3g6MCx5OjB9LGxlbmd0aDouMDEsc3RpZmZuZXNzOi4xLGFuZ3VsYXJTdGlmZm5lc3M6MSxyZW5kZXI6e3N0cm9rZVN0eWxlOlwiIzkwRUU5MFwiLGxpbmVXaWR0aDozfX0pLGw9e3R5cGU6XCJtb3VzZUNvbnN0cmFpbnRcIixtb3VzZTppLGVsZW1lbnQ6bnVsbCxib2R5Om51bGwsY29uc3RyYWludDpyLGNvbGxpc2lvbkZpbHRlcjp7Y2F0ZWdvcnk6MSxtYXNrOjQyOTQ5NjcyOTUsZ3JvdXA6MH19LHA9dS5leHRlbmQobCxuKTtyZXR1cm4gYS5vbih0LFwiYmVmb3JlVXBkYXRlXCIsZnVuY3Rpb24oKXt2YXIgbj1kLmFsbEJvZGllcyh0LndvcmxkKTtvLnVwZGF0ZShwLG4pLGUocCl9KSxwfSxvLnVwZGF0ZT1mdW5jdGlvbihlLHQpe3ZhciBuPWUubW91c2Usbz1lLmNvbnN0cmFpbnQscz1lLmJvZHk7XG5pZigwPT09bi5idXR0b24pe2lmKG8uYm9keUIpci5zZXQoby5ib2R5QiwhMSksby5wb2ludEE9bi5wb3NpdGlvbjtlbHNlIGZvcih2YXIgYz0wO2M8dC5sZW5ndGg7YysrKWlmKHM9dFtjXSxwLmNvbnRhaW5zKHMuYm91bmRzLG4ucG9zaXRpb24pJiZsLmNhbkNvbGxpZGUocy5jb2xsaXNpb25GaWx0ZXIsZS5jb2xsaXNpb25GaWx0ZXIpKWZvcih2YXIgZD1zLnBhcnRzLmxlbmd0aD4xPzE6MDtkPHMucGFydHMubGVuZ3RoO2QrKyl7dmFyIHU9cy5wYXJ0c1tkXTtpZihpLmNvbnRhaW5zKHUudmVydGljZXMsbi5wb3NpdGlvbikpe28ucG9pbnRBPW4ucG9zaXRpb24sby5ib2R5Qj1lLmJvZHk9cyxvLnBvaW50Qj17eDpuLnBvc2l0aW9uLngtcy5wb3NpdGlvbi54LHk6bi5wb3NpdGlvbi55LXMucG9zaXRpb24ueX0sby5hbmdsZUI9cy5hbmdsZSxyLnNldChzLCExKSxhLnRyaWdnZXIoZSxcInN0YXJ0ZHJhZ1wiLHttb3VzZTpuLGJvZHk6c30pO2JyZWFrfX19ZWxzZSBvLmJvZHlCPWUuYm9keT1udWxsLG8ucG9pbnRCPW51bGwscyYmYS50cmlnZ2VyKGUsXCJlbmRkcmFnXCIse21vdXNlOm4sYm9keTpzfSl9O3ZhciBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUubW91c2Usbj10LnNvdXJjZUV2ZW50cztuLm1vdXNlbW92ZSYmYS50cmlnZ2VyKGUsXCJtb3VzZW1vdmVcIix7bW91c2U6dH0pLG4ubW91c2Vkb3duJiZhLnRyaWdnZXIoZSxcIm1vdXNlZG93blwiLHttb3VzZTp0fSksbi5tb3VzZXVwJiZhLnRyaWdnZXIoZSxcIm1vdXNldXBcIix7bW91c2U6dH0pLHMuY2xlYXJTb3VyY2VFdmVudHModCl9fSgpfSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuLi9jb2xsaXNpb24vRGV0ZWN0b3JcIjo1LFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9jb3JlL01vdXNlXCI6MTksXCIuLi9jb3JlL1NsZWVwaW5nXCI6MjIsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6MjksXCIuL0NvbnN0cmFpbnRcIjoxMn1dLDE0OltmdW5jdGlvbihlLHQsbil7XG52YXIgbz17fTt0LmV4cG9ydHM9byxmdW5jdGlvbigpe28uX25leHRJZD0wLG8uX3NlZWQ9MCxvLl9ub3dTdGFydFRpbWU9K25ldyBEYXRlLG8uZXh0ZW5kPWZ1bmN0aW9uKGUsdCl7dmFyIG4saTtcImJvb2xlYW5cIj09dHlwZW9mIHQ/KG49MixpPXQpOihuPTEsaT0hMCk7Zm9yKHZhciByPW47cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIHM9YXJndW1lbnRzW3JdO2lmKHMpZm9yKHZhciBhIGluIHMpaSYmc1thXSYmc1thXS5jb25zdHJ1Y3Rvcj09PU9iamVjdD9lW2FdJiZlW2FdLmNvbnN0cnVjdG9yIT09T2JqZWN0P2VbYV09c1thXTooZVthXT1lW2FdfHx7fSxvLmV4dGVuZChlW2FdLGksc1thXSkpOmVbYV09c1thXX1yZXR1cm4gZX0sby5jbG9uZT1mdW5jdGlvbihlLHQpe3JldHVybiBvLmV4dGVuZCh7fSx0LGUpfSxvLmtleXM9ZnVuY3Rpb24oZSl7aWYoT2JqZWN0LmtleXMpcmV0dXJuIE9iamVjdC5rZXlzKGUpO3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKXQucHVzaChuKTtyZXR1cm4gdH0sby52YWx1ZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9W107aWYoT2JqZWN0LmtleXMpe2Zvcih2YXIgbj1PYmplY3Qua2V5cyhlKSxvPTA7bzxuLmxlbmd0aDtvKyspdC5wdXNoKGVbbltvXV0pO3JldHVybiB0fWZvcih2YXIgaSBpbiBlKXQucHVzaChlW2ldKTtyZXR1cm4gdH0sby5nZXQ9ZnVuY3Rpb24oZSx0LG4sbyl7dD10LnNwbGl0KFwiLlwiKS5zbGljZShuLG8pO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSs9MSllPWVbdFtpXV07cmV0dXJuIGV9LG8uc2V0PWZ1bmN0aW9uKGUsdCxuLGkscil7dmFyIHM9dC5zcGxpdChcIi5cIikuc2xpY2UoaSxyKTtyZXR1cm4gby5nZXQoZSx0LDAsLTEpW3Nbcy5sZW5ndGgtMV1dPW4sbn0sby5zaHVmZmxlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aC0xO3Q+MDt0LS0pe3ZhciBuPU1hdGguZmxvb3Ioby5yYW5kb20oKSoodCsxKSksaT1lW3RdO2VbdF09ZVtuXSxlW25dPWl9cmV0dXJuIGV9LG8uY2hvb3NlPWZ1bmN0aW9uKGUpe1xucmV0dXJuIGVbTWF0aC5mbG9vcihvLnJhbmRvbSgpKmUubGVuZ3RoKV19LG8uaXNFbGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnR9LG8uaXNBcnJheT1mdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LG8uaXNGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfSxvLmlzUGxhaW5PYmplY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJmUuY29uc3RydWN0b3I9PT1PYmplY3R9LG8uaXNTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IFN0cmluZ11cIj09PXRvU3RyaW5nLmNhbGwoZSl9LG8uY2xhbXA9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPHQ/dDplPm4/bjplfSxvLnNpZ249ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MD8tMToxfSxvLm5vdz1mdW5jdGlvbigpe2lmKHdpbmRvdy5wZXJmb3JtYW5jZSl7aWYod2luZG93LnBlcmZvcm1hbmNlLm5vdylyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO2lmKHdpbmRvdy5wZXJmb3JtYW5jZS53ZWJraXROb3cpcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS53ZWJraXROb3coKX1yZXR1cm4gbmV3IERhdGUtby5fbm93U3RhcnRUaW1lfSxvLnJhbmRvbT1mdW5jdGlvbih0LG4pe3JldHVybiB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB0P3Q6MCxuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuP246MSx0K2UoKSoobi10KX07dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4gby5fc2VlZD0oOTMwMSpvLl9zZWVkKzQ5Mjk3KSUyMzMyODAsby5fc2VlZC8yMzMyODB9O28uY29sb3JUb051bWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLnJlcGxhY2UoXCIjXCIsXCJcIiksMz09ZS5sZW5ndGgmJihlPWUuY2hhckF0KDApK2UuY2hhckF0KDApK2UuY2hhckF0KDEpK2UuY2hhckF0KDEpK2UuY2hhckF0KDIpK2UuY2hhckF0KDIpKSxwYXJzZUludChlLDE2KX0sby5sb2dMZXZlbD0xLFxuby5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlJiZvLmxvZ0xldmVsPjAmJm8ubG9nTGV2ZWw8PTMmJmNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsW1wibWF0dGVyLWpzOlwiXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpfSxvLmluZm89ZnVuY3Rpb24oKXtjb25zb2xlJiZvLmxvZ0xldmVsPjAmJm8ubG9nTGV2ZWw8PTImJmNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLFtcIm1hdHRlci1qczpcIl0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKX0sby53YXJuPWZ1bmN0aW9uKCl7Y29uc29sZSYmby5sb2dMZXZlbD4wJiZvLmxvZ0xldmVsPD0zJiZjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSxbXCJtYXR0ZXItanM6XCJdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9LG8ubmV4dElkPWZ1bmN0aW9uKCl7cmV0dXJuIG8uX25leHRJZCsrfSxvLmluZGV4T2Y9ZnVuY3Rpb24oZSx0KXtpZihlLmluZGV4T2YpcmV0dXJuIGUuaW5kZXhPZih0KTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dPT09dClyZXR1cm4gbjtyZXR1cm4tMX0sby5tYXA9ZnVuY3Rpb24oZSx0KXtpZihlLm1hcClyZXR1cm4gZS5tYXAodCk7Zm9yKHZhciBuPVtdLG89MDtvPGUubGVuZ3RoO28rPTEpbi5wdXNoKHQoZVtvXSkpO3JldHVybiBufSxvLnRvcG9sb2dpY2FsU29ydD1mdW5jdGlvbihlKXt2YXIgbj1bXSxvPVtdLGk9W107Zm9yKHZhciByIGluIGUpb1tyXXx8aVtyXXx8dChyLG8saSxlLG4pO3JldHVybiBufTt2YXIgdD1mdW5jdGlvbihlLG4sbyxpLHIpe3ZhciBzPWlbZV18fFtdO29bZV09ITA7Zm9yKHZhciBhPTA7YTxzLmxlbmd0aDthKz0xKXt2YXIgbD1zW2FdO29bbF18fG5bbF18fHQobCxuLG8saSxyKX1vW2VdPSExLG5bZV09ITAsci5wdXNoKGUpfTtvLmNoYWluPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCs9MSl7dmFyIG49YXJndW1lbnRzW3RdO1xubi5fY2hhaW5lZD9lLnB1c2guYXBwbHkoZSxuLl9jaGFpbmVkKTplLnB1c2gobil9dmFyIG89ZnVuY3Rpb24oKXtmb3IodmFyIHQsbj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksbz0wLGk9YXJndW1lbnRzLmxlbmd0aDtvPGk7bysrKW5bb109YXJndW1lbnRzW29dO2ZvcihvPTA7bzxlLmxlbmd0aDtvKz0xKXt2YXIgcj1lW29dLmFwcGx5KHQsbik7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHImJih0PXIpfXJldHVybiB0fTtyZXR1cm4gby5fY2hhaW5lZD1lLG99LG8uY2hhaW5QYXRoQmVmb3JlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gby5zZXQoZSx0LG8uY2hhaW4obixvLmdldChlLHQpKSl9LG8uY2hhaW5QYXRoQWZ0ZXI9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBvLnNldChlLHQsby5jaGFpbihvLmdldChlLHQpLG4pKX19KCl9LHt9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuLi9ib2R5L1dvcmxkXCIpLHI9ZShcIi4vU2xlZXBpbmdcIikscz1lKFwiLi4vY29sbGlzaW9uL1Jlc29sdmVyXCIpLGE9ZShcIi4uL3JlbmRlci9SZW5kZXJcIiksbD1lKFwiLi4vY29sbGlzaW9uL1BhaXJzXCIpLGM9KGUoXCIuL01ldHJpY3NcIiksZShcIi4uL2NvbGxpc2lvbi9HcmlkXCIpKSxkPWUoXCIuL0V2ZW50c1wiKSx1PWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSxwPWUoXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIiksZj1lKFwiLi9Db21tb25cIiksbT1lKFwiLi4vYm9keS9Cb2R5XCIpOyFmdW5jdGlvbigpe28uY3JlYXRlPWZ1bmN0aW9uKGUsdCl7dD1mLmlzRWxlbWVudChlKT90OmUsZT1mLmlzRWxlbWVudChlKT9lOm51bGwsdD10fHx7fSwoZXx8dC5yZW5kZXIpJiZmLndhcm4oXCJFbmdpbmUuY3JlYXRlOiBlbmdpbmUucmVuZGVyIGlzIGRlcHJlY2F0ZWQgKHNlZSBkb2NzKVwiKTt2YXIgbj17cG9zaXRpb25JdGVyYXRpb25zOjYsdmVsb2NpdHlJdGVyYXRpb25zOjQsY29uc3RyYWludEl0ZXJhdGlvbnM6MixlbmFibGVTbGVlcGluZzohMSxldmVudHM6W10sXG5wbHVnaW46e30sdGltaW5nOnt0aW1lc3RhbXA6MCx0aW1lU2NhbGU6MX0sYnJvYWRwaGFzZTp7Y29udHJvbGxlcjpjfX0sbz1mLmV4dGVuZChuLHQpO2lmKGV8fG8ucmVuZGVyKXt2YXIgcj17ZWxlbWVudDplLGNvbnRyb2xsZXI6YX07by5yZW5kZXI9Zi5leHRlbmQocixvLnJlbmRlcil9cmV0dXJuIG8ucmVuZGVyJiZvLnJlbmRlci5jb250cm9sbGVyJiYoby5yZW5kZXI9by5yZW5kZXIuY29udHJvbGxlci5jcmVhdGUoby5yZW5kZXIpKSxvLnJlbmRlciYmKG8ucmVuZGVyLmVuZ2luZT1vKSxvLndvcmxkPXQud29ybGR8fGkuY3JlYXRlKG8ud29ybGQpLG8ucGFpcnM9bC5jcmVhdGUoKSxvLmJyb2FkcGhhc2U9by5icm9hZHBoYXNlLmNvbnRyb2xsZXIuY3JlYXRlKG8uYnJvYWRwaGFzZSksby5tZXRyaWNzPW8ubWV0cmljc3x8e2V4dGVuZGVkOiExfSxvfSxvLnVwZGF0ZT1mdW5jdGlvbihvLGksYSl7aT1pfHwxZTMvNjAsYT1hfHwxO3ZhciBjLGY9by53b3JsZCxtPW8udGltaW5nLHY9by5icm9hZHBoYXNlLHk9W107bS50aW1lc3RhbXArPWkqbS50aW1lU2NhbGU7dmFyIGc9e3RpbWVzdGFtcDptLnRpbWVzdGFtcH07ZC50cmlnZ2VyKG8sXCJiZWZvcmVVcGRhdGVcIixnKTt2YXIgeD11LmFsbEJvZGllcyhmKSxoPXUuYWxsQ29uc3RyYWludHMoZik7Zm9yKG8uZW5hYmxlU2xlZXBpbmcmJnIudXBkYXRlKHgsbS50aW1lU2NhbGUpLHQoeCxmLmdyYXZpdHkpLG4oeCxpLG0udGltZVNjYWxlLGEsZi5ib3VuZHMpLHAucHJlU29sdmVBbGwoeCksYz0wO2M8by5jb25zdHJhaW50SXRlcmF0aW9ucztjKyspcC5zb2x2ZUFsbChoLG0udGltZVNjYWxlKTtwLnBvc3RTb2x2ZUFsbCh4KSx2LmNvbnRyb2xsZXI/KGYuaXNNb2RpZmllZCYmdi5jb250cm9sbGVyLmNsZWFyKHYpLHYuY29udHJvbGxlci51cGRhdGUodix4LG8sZi5pc01vZGlmaWVkKSx5PXYucGFpcnNMaXN0KTp5PXgsZi5pc01vZGlmaWVkJiZ1LnNldE1vZGlmaWVkKGYsITEsITEsITApO3ZhciBiPXYuZGV0ZWN0b3IoeSxvKSx3PW8ucGFpcnMsUz1tLnRpbWVzdGFtcDtcbmZvcihsLnVwZGF0ZSh3LGIsUyksbC5yZW1vdmVPbGQodyxTKSxvLmVuYWJsZVNsZWVwaW5nJiZyLmFmdGVyQ29sbGlzaW9ucyh3Lmxpc3QsbS50aW1lU2NhbGUpLHcuY29sbGlzaW9uU3RhcnQubGVuZ3RoPjAmJmQudHJpZ2dlcihvLFwiY29sbGlzaW9uU3RhcnRcIix7cGFpcnM6dy5jb2xsaXNpb25TdGFydH0pLHMucHJlU29sdmVQb3NpdGlvbih3Lmxpc3QpLGM9MDtjPG8ucG9zaXRpb25JdGVyYXRpb25zO2MrKylzLnNvbHZlUG9zaXRpb24ody5saXN0LG0udGltZVNjYWxlKTtmb3Iocy5wb3N0U29sdmVQb3NpdGlvbih4KSxwLnByZVNvbHZlQWxsKHgpLGM9MDtjPG8uY29uc3RyYWludEl0ZXJhdGlvbnM7YysrKXAuc29sdmVBbGwoaCxtLnRpbWVTY2FsZSk7Zm9yKHAucG9zdFNvbHZlQWxsKHgpLHMucHJlU29sdmVWZWxvY2l0eSh3Lmxpc3QpLGM9MDtjPG8udmVsb2NpdHlJdGVyYXRpb25zO2MrKylzLnNvbHZlVmVsb2NpdHkody5saXN0LG0udGltZVNjYWxlKTtyZXR1cm4gdy5jb2xsaXNpb25BY3RpdmUubGVuZ3RoPjAmJmQudHJpZ2dlcihvLFwiY29sbGlzaW9uQWN0aXZlXCIse3BhaXJzOncuY29sbGlzaW9uQWN0aXZlfSksdy5jb2xsaXNpb25FbmQubGVuZ3RoPjAmJmQudHJpZ2dlcihvLFwiY29sbGlzaW9uRW5kXCIse3BhaXJzOncuY29sbGlzaW9uRW5kfSksZSh4KSxkLnRyaWdnZXIobyxcImFmdGVyVXBkYXRlXCIsZyksb30sby5tZXJnZT1mdW5jdGlvbihlLHQpe2lmKGYuZXh0ZW5kKGUsdCksdC53b3JsZCl7ZS53b3JsZD10LndvcmxkLG8uY2xlYXIoZSk7Zm9yKHZhciBuPXUuYWxsQm9kaWVzKGUud29ybGQpLGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIHM9bltpXTtyLnNldChzLCExKSxzLmlkPWYubmV4dElkKCl9fX0sby5jbGVhcj1mdW5jdGlvbihlKXt2YXIgdD1lLndvcmxkO2wuY2xlYXIoZS5wYWlycyk7dmFyIG49ZS5icm9hZHBoYXNlO2lmKG4uY29udHJvbGxlcil7dmFyIG89dS5hbGxCb2RpZXModCk7bi5jb250cm9sbGVyLmNsZWFyKG4pLG4uY29udHJvbGxlci51cGRhdGUobixvLGUsITApO1xufX07dmFyIGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBuPWVbdF07bi5mb3JjZS54PTAsbi5mb3JjZS55PTAsbi50b3JxdWU9MH19LHQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgdC5zY2FsZT90LnNjYWxlOi4wMDE7aWYoKDAhPT10Lnh8fDAhPT10LnkpJiYwIT09bilmb3IodmFyIG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIGk9ZVtvXTtpLmlzU3RhdGljfHxpLmlzU2xlZXBpbmd8fChpLmZvcmNlLnkrPWkubWFzcyp0LnkqbixpLmZvcmNlLngrPWkubWFzcyp0Lngqbil9fSxuPWZ1bmN0aW9uKGUsdCxuLG8saSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBzPWVbcl07cy5pc1N0YXRpY3x8cy5pc1NsZWVwaW5nfHxtLnVwZGF0ZShzLHQsbixvKX19fSgpfSx7XCIuLi9ib2R5L0JvZHlcIjoxLFwiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vYm9keS9Xb3JsZFwiOjMsXCIuLi9jb2xsaXNpb24vR3JpZFwiOjYsXCIuLi9jb2xsaXNpb24vUGFpcnNcIjo4LFwiLi4vY29sbGlzaW9uL1Jlc29sdmVyXCI6MTAsXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIjoxMixcIi4uL3JlbmRlci9SZW5kZXJcIjozMSxcIi4vQ29tbW9uXCI6MTQsXCIuL0V2ZW50c1wiOjE2LFwiLi9NZXRyaWNzXCI6MTgsXCIuL1NsZWVwaW5nXCI6MjJ9XSwxNjpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuL0NvbW1vblwiKTshZnVuY3Rpb24oKXtvLm9uPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIG8saT10LnNwbGl0KFwiIFwiKSxyPTA7cjxpLmxlbmd0aDtyKyspbz1pW3JdLGUuZXZlbnRzPWUuZXZlbnRzfHx7fSxlLmV2ZW50c1tvXT1lLmV2ZW50c1tvXXx8W10sZS5ldmVudHNbb10ucHVzaChuKTtyZXR1cm4gbn0sby5vZmY9ZnVuY3Rpb24oZSx0LG4pe2lmKCF0KXJldHVybiB2b2lkKGUuZXZlbnRzPXt9KTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9aS5rZXlzKGUuZXZlbnRzKS5qb2luKFwiIFwiKSk7Zm9yKHZhciBvPXQuc3BsaXQoXCIgXCIpLHI9MDtyPG8ubGVuZ3RoO3IrKyl7XG52YXIgcz1lLmV2ZW50c1tvW3JdXSxhPVtdO2lmKG4mJnMpZm9yKHZhciBsPTA7bDxzLmxlbmd0aDtsKyspc1tsXSE9PW4mJmEucHVzaChzW2xdKTtlLmV2ZW50c1tvW3JdXT1hfX0sby50cmlnZ2VyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbyxyLHMsYTtpZihlLmV2ZW50cyl7bnx8KG49e30pLG89dC5zcGxpdChcIiBcIik7Zm9yKHZhciBsPTA7bDxvLmxlbmd0aDtsKyspaWYocj1vW2xdLHM9ZS5ldmVudHNbcl0pe2E9aS5jbG9uZShuLCExKSxhLm5hbWU9cixhLnNvdXJjZT1lO2Zvcih2YXIgYz0wO2M8cy5sZW5ndGg7YysrKXNbY10uYXBwbHkoZSxbYV0pfX19fSgpfSx7XCIuL0NvbW1vblwiOjE0fV0sMTc6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi9QbHVnaW5cIikscj1lKFwiLi9Db21tb25cIik7IWZ1bmN0aW9uKCl7by5uYW1lPVwibWF0dGVyLWpzXCIsby52ZXJzaW9uPVwiMC4xMy4wXCIsby51c2VzPVtdLG8udXNlZD1bXSxvLnVzZT1mdW5jdGlvbigpe2kudXNlKG8sQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9LG8uYmVmb3JlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9ZS5yZXBsYWNlKC9eTWF0dGVyLi8sXCJcIiksci5jaGFpblBhdGhCZWZvcmUobyxlLHQpfSxvLmFmdGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9ZS5yZXBsYWNlKC9eTWF0dGVyLi8sXCJcIiksci5jaGFpblBhdGhBZnRlcihvLGUsdCl9fSgpfSx7XCIuL0NvbW1vblwiOjE0LFwiLi9QbHVnaW5cIjoyMH1dLDE4OltmdW5jdGlvbihlLHQsbil7fSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuL0NvbW1vblwiOjE0fV0sMTk6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7by5jcmVhdGU9ZnVuY3Rpb24odCl7dmFyIG49e307cmV0dXJuIHR8fGkubG9nKFwiTW91c2UuY3JlYXRlOiBlbGVtZW50IHdhcyB1bmRlZmluZWQsIGRlZmF1bHRpbmcgdG8gZG9jdW1lbnQuYm9keVwiLFwid2FyblwiKSxcbm4uZWxlbWVudD10fHxkb2N1bWVudC5ib2R5LG4uYWJzb2x1dGU9e3g6MCx5OjB9LG4ucG9zaXRpb249e3g6MCx5OjB9LG4ubW91c2Vkb3duUG9zaXRpb249e3g6MCx5OjB9LG4ubW91c2V1cFBvc2l0aW9uPXt4OjAseTowfSxuLm9mZnNldD17eDowLHk6MH0sbi5zY2FsZT17eDoxLHk6MX0sbi53aGVlbERlbHRhPTAsbi5idXR0b249LTEsbi5waXhlbFJhdGlvPW4uZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBpeGVsLXJhdGlvXCIpfHwxLG4uc291cmNlRXZlbnRzPXttb3VzZW1vdmU6bnVsbCxtb3VzZWRvd246bnVsbCxtb3VzZXVwOm51bGwsbW91c2V3aGVlbDpudWxsfSxuLm1vdXNlbW92ZT1mdW5jdGlvbih0KXt2YXIgbz1lKHQsbi5lbGVtZW50LG4ucGl4ZWxSYXRpbyksaT10LmNoYW5nZWRUb3VjaGVzO2kmJihuLmJ1dHRvbj0wLHQucHJldmVudERlZmF1bHQoKSksbi5hYnNvbHV0ZS54PW8ueCxuLmFic29sdXRlLnk9by55LG4ucG9zaXRpb24ueD1uLmFic29sdXRlLngqbi5zY2FsZS54K24ub2Zmc2V0Lngsbi5wb3NpdGlvbi55PW4uYWJzb2x1dGUueSpuLnNjYWxlLnkrbi5vZmZzZXQueSxuLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmU9dH0sbi5tb3VzZWRvd249ZnVuY3Rpb24odCl7dmFyIG89ZSh0LG4uZWxlbWVudCxuLnBpeGVsUmF0aW8pLGk9dC5jaGFuZ2VkVG91Y2hlcztpPyhuLmJ1dHRvbj0wLHQucHJldmVudERlZmF1bHQoKSk6bi5idXR0b249dC5idXR0b24sbi5hYnNvbHV0ZS54PW8ueCxuLmFic29sdXRlLnk9by55LG4ucG9zaXRpb24ueD1uLmFic29sdXRlLngqbi5zY2FsZS54K24ub2Zmc2V0Lngsbi5wb3NpdGlvbi55PW4uYWJzb2x1dGUueSpuLnNjYWxlLnkrbi5vZmZzZXQueSxuLm1vdXNlZG93blBvc2l0aW9uLng9bi5wb3NpdGlvbi54LG4ubW91c2Vkb3duUG9zaXRpb24ueT1uLnBvc2l0aW9uLnksbi5zb3VyY2VFdmVudHMubW91c2Vkb3duPXR9LG4ubW91c2V1cD1mdW5jdGlvbih0KXt2YXIgbz1lKHQsbi5lbGVtZW50LG4ucGl4ZWxSYXRpbyksaT10LmNoYW5nZWRUb3VjaGVzO1xuaSYmdC5wcmV2ZW50RGVmYXVsdCgpLG4uYnV0dG9uPS0xLG4uYWJzb2x1dGUueD1vLngsbi5hYnNvbHV0ZS55PW8ueSxuLnBvc2l0aW9uLng9bi5hYnNvbHV0ZS54Km4uc2NhbGUueCtuLm9mZnNldC54LG4ucG9zaXRpb24ueT1uLmFic29sdXRlLnkqbi5zY2FsZS55K24ub2Zmc2V0Lnksbi5tb3VzZXVwUG9zaXRpb24ueD1uLnBvc2l0aW9uLngsbi5tb3VzZXVwUG9zaXRpb24ueT1uLnBvc2l0aW9uLnksbi5zb3VyY2VFdmVudHMubW91c2V1cD10fSxuLm1vdXNld2hlZWw9ZnVuY3Rpb24oZSl7bi53aGVlbERlbHRhPU1hdGgubWF4KC0xLE1hdGgubWluKDEsZS53aGVlbERlbHRhfHwtZS5kZXRhaWwpKSxlLnByZXZlbnREZWZhdWx0KCl9LG8uc2V0RWxlbWVudChuLG4uZWxlbWVudCksbn0sby5zZXRFbGVtZW50PWZ1bmN0aW9uKGUsdCl7ZS5lbGVtZW50PXQsdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsZS5tb3VzZW1vdmUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGUubW91c2Vkb3duKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsZS5tb3VzZXVwKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsZS5tb3VzZXdoZWVsKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLGUubW91c2V3aGVlbCksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZS5tb3VzZW1vdmUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixlLm1vdXNlZG93biksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixlLm1vdXNldXApfSxvLmNsZWFyU291cmNlRXZlbnRzPWZ1bmN0aW9uKGUpe2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZT1udWxsLGUuc291cmNlRXZlbnRzLm1vdXNlZG93bj1udWxsLGUuc291cmNlRXZlbnRzLm1vdXNldXA9bnVsbCxlLnNvdXJjZUV2ZW50cy5tb3VzZXdoZWVsPW51bGwsZS53aGVlbERlbHRhPTB9LG8uc2V0T2Zmc2V0PWZ1bmN0aW9uKGUsdCl7ZS5vZmZzZXQueD10LngsZS5vZmZzZXQueT10LnksXG5lLnBvc2l0aW9uLng9ZS5hYnNvbHV0ZS54KmUuc2NhbGUueCtlLm9mZnNldC54LGUucG9zaXRpb24ueT1lLmFic29sdXRlLnkqZS5zY2FsZS55K2Uub2Zmc2V0Lnl9LG8uc2V0U2NhbGU9ZnVuY3Rpb24oZSx0KXtlLnNjYWxlLng9dC54LGUuc2NhbGUueT10LnksZS5wb3NpdGlvbi54PWUuYWJzb2x1dGUueCplLnNjYWxlLngrZS5vZmZzZXQueCxlLnBvc2l0aW9uLnk9ZS5hYnNvbHV0ZS55KmUuc2NhbGUueStlLm9mZnNldC55fTt2YXIgZT1mdW5jdGlvbihlLHQsbil7dmFyIG8saSxyPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZXx8ZG9jdW1lbnQuYm9keSxhPXZvaWQgMCE9PXdpbmRvdy5wYWdlWE9mZnNldD93aW5kb3cucGFnZVhPZmZzZXQ6cy5zY3JvbGxMZWZ0LGw9dm9pZCAwIT09d2luZG93LnBhZ2VZT2Zmc2V0P3dpbmRvdy5wYWdlWU9mZnNldDpzLnNjcm9sbFRvcCxjPWUuY2hhbmdlZFRvdWNoZXM7cmV0dXJuIGM/KG89Y1swXS5wYWdlWC1yLmxlZnQtYSxpPWNbMF0ucGFnZVktci50b3AtbCk6KG89ZS5wYWdlWC1yLmxlZnQtYSxpPWUucGFnZVktci50b3AtbCkse3g6by8odC5jbGllbnRXaWR0aC8odC53aWR0aHx8dC5jbGllbnRXaWR0aCkqbikseTppLyh0LmNsaWVudEhlaWdodC8odC5oZWlnaHR8fHQuY2xpZW50SGVpZ2h0KSpuKX19fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0fV0sMjA6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi9Db21tb25cIik7IWZ1bmN0aW9uKCl7by5fcmVnaXN0cnk9e30sby5yZWdpc3Rlcj1mdW5jdGlvbihlKXtpZihvLmlzUGx1Z2luKGUpfHxpLndhcm4oXCJQbHVnaW4ucmVnaXN0ZXI6XCIsby50b1N0cmluZyhlKSxcImRvZXMgbm90IGltcGxlbWVudCBhbGwgcmVxdWlyZWQgZmllbGRzLlwiKSxlLm5hbWUgaW4gby5fcmVnaXN0cnkpe3ZhciB0PW8uX3JlZ2lzdHJ5W2UubmFtZV0sbj1vLnZlcnNpb25QYXJzZShlLnZlcnNpb24pLm51bWJlcixyPW8udmVyc2lvblBhcnNlKHQudmVyc2lvbikubnVtYmVyO1xubj5yPyhpLndhcm4oXCJQbHVnaW4ucmVnaXN0ZXI6XCIsby50b1N0cmluZyh0KSxcIndhcyB1cGdyYWRlZCB0b1wiLG8udG9TdHJpbmcoZSkpLG8uX3JlZ2lzdHJ5W2UubmFtZV09ZSk6bjxyP2kud2FybihcIlBsdWdpbi5yZWdpc3RlcjpcIixvLnRvU3RyaW5nKHQpLFwiY2FuIG5vdCBiZSBkb3duZ3JhZGVkIHRvXCIsby50b1N0cmluZyhlKSk6ZSE9PXQmJmkud2FybihcIlBsdWdpbi5yZWdpc3RlcjpcIixvLnRvU3RyaW5nKGUpLFwiaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvIGRpZmZlcmVudCBwbHVnaW4gb2JqZWN0XCIpfWVsc2Ugby5fcmVnaXN0cnlbZS5uYW1lXT1lO3JldHVybiBlfSxvLnJlc29sdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIG8uX3JlZ2lzdHJ5W28uZGVwZW5kZW5jeVBhcnNlKGUpLm5hbWVdfSxvLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP2U6KGUubmFtZXx8XCJhbm9ueW1vdXNcIikrXCJAXCIrKGUudmVyc2lvbnx8ZS5yYW5nZXx8XCIwLjAuMFwiKX0sby5pc1BsdWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5uYW1lJiZlLnZlcnNpb24mJmUuaW5zdGFsbH0sby5pc1VzZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS51c2VkLmluZGV4T2YodCk+LTF9LG8uaXNGb3I9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmZvciYmby5kZXBlbmRlbmN5UGFyc2UoZS5mb3IpO3JldHVybiFlLmZvcnx8dC5uYW1lPT09bi5uYW1lJiZvLnZlcnNpb25TYXRpc2ZpZXModC52ZXJzaW9uLG4ucmFuZ2UpfSxvLnVzZT1mdW5jdGlvbihlLHQpe2lmKGUudXNlcz0oZS51c2VzfHxbXSkuY29uY2F0KHR8fFtdKSwwPT09ZS51c2VzLmxlbmd0aClyZXR1cm4gdm9pZCBpLndhcm4oXCJQbHVnaW4udXNlOlwiLG8udG9TdHJpbmcoZSksXCJkb2VzIG5vdCBzcGVjaWZ5IGFueSBkZXBlbmRlbmNpZXMgdG8gaW5zdGFsbC5cIik7Zm9yKHZhciBuPW8uZGVwZW5kZW5jaWVzKGUpLHI9aS50b3BvbG9naWNhbFNvcnQobikscz1bXSxhPTA7YTxyLmxlbmd0aDthKz0xKWlmKHJbYV0hPT1lLm5hbWUpe1xudmFyIGw9by5yZXNvbHZlKHJbYV0pO2w/by5pc1VzZWQoZSxsLm5hbWUpfHwoby5pc0ZvcihsLGUpfHwoaS53YXJuKFwiUGx1Z2luLnVzZTpcIixvLnRvU3RyaW5nKGwpLFwiaXMgZm9yXCIsbC5mb3IsXCJidXQgaW5zdGFsbGVkIG9uXCIsby50b1N0cmluZyhlKStcIi5cIiksbC5fd2FybmVkPSEwKSxsLmluc3RhbGw/bC5pbnN0YWxsKGUpOihpLndhcm4oXCJQbHVnaW4udXNlOlwiLG8udG9TdHJpbmcobCksXCJkb2VzIG5vdCBzcGVjaWZ5IGFuIGluc3RhbGwgZnVuY3Rpb24uXCIpLGwuX3dhcm5lZD0hMCksbC5fd2FybmVkPyhzLnB1c2goXCLwn5S2IFwiK28udG9TdHJpbmcobCkpLGRlbGV0ZSBsLl93YXJuZWQpOnMucHVzaChcIuKchSBcIitvLnRvU3RyaW5nKGwpKSxlLnVzZWQucHVzaChsLm5hbWUpKTpzLnB1c2goXCLinYwgXCIrclthXSl9cy5sZW5ndGg+MCYmaS5pbmZvKHMuam9pbihcIiAgXCIpKX0sby5kZXBlbmRlbmNpZXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1vLmRlcGVuZGVuY3lQYXJzZShlKSxyPW4ubmFtZTtpZih0PXR8fHt9LCEociBpbiB0KSl7ZT1vLnJlc29sdmUoZSl8fGUsdFtyXT1pLm1hcChlLnVzZXN8fFtdLGZ1bmN0aW9uKHQpe28uaXNQbHVnaW4odCkmJm8ucmVnaXN0ZXIodCk7dmFyIHI9by5kZXBlbmRlbmN5UGFyc2UodCkscz1vLnJlc29sdmUodCk7cmV0dXJuIHMmJiFvLnZlcnNpb25TYXRpc2ZpZXMocy52ZXJzaW9uLHIucmFuZ2UpPyhpLndhcm4oXCJQbHVnaW4uZGVwZW5kZW5jaWVzOlwiLG8udG9TdHJpbmcocyksXCJkb2VzIG5vdCBzYXRpc2Z5XCIsby50b1N0cmluZyhyKSxcInVzZWQgYnlcIixvLnRvU3RyaW5nKG4pK1wiLlwiKSxzLl93YXJuZWQ9ITAsZS5fd2FybmVkPSEwKTpzfHwoaS53YXJuKFwiUGx1Z2luLmRlcGVuZGVuY2llczpcIixvLnRvU3RyaW5nKHQpLFwidXNlZCBieVwiLG8udG9TdHJpbmcobiksXCJjb3VsZCBub3QgYmUgcmVzb2x2ZWQuXCIpLGUuX3dhcm5lZD0hMCksci5uYW1lfSk7Zm9yKHZhciBzPTA7czx0W3JdLmxlbmd0aDtzKz0xKW8uZGVwZW5kZW5jaWVzKHRbcl1bc10sdCk7XG5yZXR1cm4gdH19LG8uZGVwZW5kZW5jeVBhcnNlPWZ1bmN0aW9uKGUpe2lmKGkuaXNTdHJpbmcoZSkpe3ZhciB0PS9eW1xcdy1dKyhAKFxcKnxbXFxefl0/XFxkK1xcLlxcZCtcXC5cXGQrKC1bMC05QS1aYS16LV0rKT8pKT8kLztyZXR1cm4gdC50ZXN0KGUpfHxpLndhcm4oXCJQbHVnaW4uZGVwZW5kZW5jeVBhcnNlOlwiLGUsXCJpcyBub3QgYSB2YWxpZCBkZXBlbmRlbmN5IHN0cmluZy5cIikse25hbWU6ZS5zcGxpdChcIkBcIilbMF0scmFuZ2U6ZS5zcGxpdChcIkBcIilbMV18fFwiKlwifX1yZXR1cm57bmFtZTplLm5hbWUscmFuZ2U6ZS5yYW5nZXx8ZS52ZXJzaW9ufX0sby52ZXJzaW9uUGFyc2U9ZnVuY3Rpb24oZSl7dmFyIHQ9L15cXCp8W1xcXn5dP1xcZCtcXC5cXGQrXFwuXFxkKygtWzAtOUEtWmEtei1dKyk/JC87dC50ZXN0KGUpfHxpLndhcm4oXCJQbHVnaW4udmVyc2lvblBhcnNlOlwiLGUsXCJpcyBub3QgYSB2YWxpZCB2ZXJzaW9uIG9yIHJhbmdlLlwiKTt2YXIgbj1lLnNwbGl0KFwiLVwiKTtlPW5bMF07dmFyIG89aXNOYU4oTnVtYmVyKGVbMF0pKSxyPW8/ZS5zdWJzdHIoMSk6ZSxzPWkubWFwKHIuc3BsaXQoXCIuXCIpLGZ1bmN0aW9uKGUpe3JldHVybiBOdW1iZXIoZSl9KTtyZXR1cm57aXNSYW5nZTpvLHZlcnNpb246cixyYW5nZTplLG9wZXJhdG9yOm8/ZVswXTpcIlwiLHBhcnRzOnMscHJlcmVsZWFzZTpuWzFdLG51bWJlcjoxZTgqc1swXSsxZTQqc1sxXStzWzJdfX0sby52ZXJzaW9uU2F0aXNmaWVzPWZ1bmN0aW9uKGUsdCl7dD10fHxcIipcIjt2YXIgbj1vLnZlcnNpb25QYXJzZSh0KSxpPW4ucGFydHMscj1vLnZlcnNpb25QYXJzZShlKSxzPXIucGFydHM7aWYobi5pc1JhbmdlKXtpZihcIipcIj09PW4ub3BlcmF0b3J8fFwiKlwiPT09ZSlyZXR1cm4hMDtpZihcIn5cIj09PW4ub3BlcmF0b3IpcmV0dXJuIHNbMF09PT1pWzBdJiZzWzFdPT09aVsxXSYmc1syXT49aVsyXTtpZihcIl5cIj09PW4ub3BlcmF0b3IpcmV0dXJuIGlbMF0+MD9zWzBdPT09aVswXSYmci5udW1iZXI+PW4ubnVtYmVyOmlbMV0+MD9zWzFdPT09aVsxXSYmc1syXT49aVsyXTpzWzJdPT09aVsyXTtcbn1yZXR1cm4gZT09PXR8fFwiKlwiPT09ZX19KCl9LHtcIi4vQ29tbW9uXCI6MTR9XSwyMTpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuL0V2ZW50c1wiKSxyPWUoXCIuL0VuZ2luZVwiKSxzPWUoXCIuL0NvbW1vblwiKTshZnVuY3Rpb24oKXt2YXIgZSx0O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSx0PXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKSwhZSl7dmFyIG47ZT1mdW5jdGlvbihlKXtuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKHMubm93KCkpfSwxZTMvNjApfSx0PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KG4pfX1vLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17ZnBzOjYwLGNvcnJlY3Rpb246MSxkZWx0YVNhbXBsZVNpemU6NjAsY291bnRlclRpbWVzdGFtcDowLGZyYW1lQ291bnRlcjowLGRlbHRhSGlzdG9yeTpbXSx0aW1lUHJldjpudWxsLHRpbWVTY2FsZVByZXY6MSxmcmFtZVJlcXVlc3RJZDpudWxsLGlzRml4ZWQ6ITEsZW5hYmxlZDohMH0sbj1zLmV4dGVuZCh0LGUpO3JldHVybiBuLmRlbHRhPW4uZGVsdGF8fDFlMy9uLmZwcyxuLmRlbHRhTWluPW4uZGVsdGFNaW58fDFlMy9uLmZwcyxuLmRlbHRhTWF4PW4uZGVsdGFNYXh8fDFlMy8oLjUqbi5mcHMpLG4uZnBzPTFlMy9uLmRlbHRhLG59LG8ucnVuPWZ1bmN0aW9uKHQsbil7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQucG9zaXRpb25JdGVyYXRpb25zJiYobj10LHQ9by5jcmVhdGUoKSksZnVuY3Rpb24gaShyKXt0LmZyYW1lUmVxdWVzdElkPWUoaSksXG5yJiZ0LmVuYWJsZWQmJm8udGljayh0LG4scil9KCksdH0sby50aWNrPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbyxzPXQudGltaW5nLGE9MSxsPXt0aW1lc3RhbXA6cy50aW1lc3RhbXB9O2kudHJpZ2dlcihlLFwiYmVmb3JlVGlja1wiLGwpLGkudHJpZ2dlcih0LFwiYmVmb3JlVGlja1wiLGwpLGUuaXNGaXhlZD9vPWUuZGVsdGE6KG89bi1lLnRpbWVQcmV2fHxlLmRlbHRhLGUudGltZVByZXY9bixlLmRlbHRhSGlzdG9yeS5wdXNoKG8pLGUuZGVsdGFIaXN0b3J5PWUuZGVsdGFIaXN0b3J5LnNsaWNlKC1lLmRlbHRhU2FtcGxlU2l6ZSksbz1NYXRoLm1pbi5hcHBseShudWxsLGUuZGVsdGFIaXN0b3J5KSxvPW88ZS5kZWx0YU1pbj9lLmRlbHRhTWluOm8sbz1vPmUuZGVsdGFNYXg/ZS5kZWx0YU1heDpvLGE9by9lLmRlbHRhLGUuZGVsdGE9byksMCE9PWUudGltZVNjYWxlUHJldiYmKGEqPXMudGltZVNjYWxlL2UudGltZVNjYWxlUHJldiksMD09PXMudGltZVNjYWxlJiYoYT0wKSxlLnRpbWVTY2FsZVByZXY9cy50aW1lU2NhbGUsZS5jb3JyZWN0aW9uPWEsZS5mcmFtZUNvdW50ZXIrPTEsbi1lLmNvdW50ZXJUaW1lc3RhbXA+PTFlMyYmKGUuZnBzPWUuZnJhbWVDb3VudGVyKigobi1lLmNvdW50ZXJUaW1lc3RhbXApLzFlMyksZS5jb3VudGVyVGltZXN0YW1wPW4sZS5mcmFtZUNvdW50ZXI9MCksaS50cmlnZ2VyKGUsXCJ0aWNrXCIsbCksaS50cmlnZ2VyKHQsXCJ0aWNrXCIsbCksdC53b3JsZC5pc01vZGlmaWVkJiZ0LnJlbmRlciYmdC5yZW5kZXIuY29udHJvbGxlciYmdC5yZW5kZXIuY29udHJvbGxlci5jbGVhciYmdC5yZW5kZXIuY29udHJvbGxlci5jbGVhcih0LnJlbmRlciksaS50cmlnZ2VyKGUsXCJiZWZvcmVVcGRhdGVcIixsKSxyLnVwZGF0ZSh0LG8sYSksaS50cmlnZ2VyKGUsXCJhZnRlclVwZGF0ZVwiLGwpLHQucmVuZGVyJiZ0LnJlbmRlci5jb250cm9sbGVyJiYoaS50cmlnZ2VyKGUsXCJiZWZvcmVSZW5kZXJcIixsKSxpLnRyaWdnZXIodCxcImJlZm9yZVJlbmRlclwiLGwpLHQucmVuZGVyLmNvbnRyb2xsZXIud29ybGQodC5yZW5kZXIpLFxuaS50cmlnZ2VyKGUsXCJhZnRlclJlbmRlclwiLGwpLGkudHJpZ2dlcih0LFwiYWZ0ZXJSZW5kZXJcIixsKSksaS50cmlnZ2VyKGUsXCJhZnRlclRpY2tcIixsKSxpLnRyaWdnZXIodCxcImFmdGVyVGlja1wiLGwpfSxvLnN0b3A9ZnVuY3Rpb24oZSl7dChlLmZyYW1lUmVxdWVzdElkKX0sby5zdGFydD1mdW5jdGlvbihlLHQpe28ucnVuKGUsdCl9fSgpfSx7XCIuL0NvbW1vblwiOjE0LFwiLi9FbmdpbmVcIjoxNSxcIi4vRXZlbnRzXCI6MTZ9XSwyMjpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuL0V2ZW50c1wiKTshZnVuY3Rpb24oKXtvLl9tb3Rpb25XYWtlVGhyZXNob2xkPS4xOCxvLl9tb3Rpb25TbGVlcFRocmVzaG9sZD0uMDgsby5fbWluQmlhcz0uOSxvLnVwZGF0ZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10KnQqdCxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciByPWVbaV0scz1yLnNwZWVkKnIuc3BlZWQrci5hbmd1bGFyU3BlZWQqci5hbmd1bGFyU3BlZWQ7aWYoMD09PXIuZm9yY2UueCYmMD09PXIuZm9yY2UueSl7dmFyIGE9TWF0aC5taW4oci5tb3Rpb24scyksbD1NYXRoLm1heChyLm1vdGlvbixzKTtyLm1vdGlvbj1vLl9taW5CaWFzKmErKDEtby5fbWluQmlhcykqbCxyLnNsZWVwVGhyZXNob2xkPjAmJnIubW90aW9uPG8uX21vdGlvblNsZWVwVGhyZXNob2xkKm4/KHIuc2xlZXBDb3VudGVyKz0xLHIuc2xlZXBDb3VudGVyPj1yLnNsZWVwVGhyZXNob2xkJiZvLnNldChyLCEwKSk6ci5zbGVlcENvdW50ZXI+MCYmKHIuc2xlZXBDb3VudGVyLT0xKX1lbHNlIG8uc2V0KHIsITEpfX0sby5hZnRlckNvbGxpc2lvbnM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dCp0KnQsaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgcj1lW2ldO2lmKHIuaXNBY3RpdmUpe3ZhciBzPXIuY29sbGlzaW9uLGE9cy5ib2R5QS5wYXJlbnQsbD1zLmJvZHlCLnBhcmVudDtpZighKGEuaXNTbGVlcGluZyYmbC5pc1NsZWVwaW5nfHxhLmlzU3RhdGljfHxsLmlzU3RhdGljKSYmKGEuaXNTbGVlcGluZ3x8bC5pc1NsZWVwaW5nKSl7XG52YXIgYz1hLmlzU2xlZXBpbmcmJiFhLmlzU3RhdGljP2E6bCxkPWM9PT1hP2w6YTshYy5pc1N0YXRpYyYmZC5tb3Rpb24+by5fbW90aW9uV2FrZVRocmVzaG9sZCpuJiZvLnNldChjLCExKX19fX0sby5zZXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmlzU2xlZXBpbmc7dD8oZS5pc1NsZWVwaW5nPSEwLGUuc2xlZXBDb3VudGVyPWUuc2xlZXBUaHJlc2hvbGQsZS5wb3NpdGlvbkltcHVsc2UueD0wLGUucG9zaXRpb25JbXB1bHNlLnk9MCxlLnBvc2l0aW9uUHJldi54PWUucG9zaXRpb24ueCxlLnBvc2l0aW9uUHJldi55PWUucG9zaXRpb24ueSxlLmFuZ2xlUHJldj1lLmFuZ2xlLGUuc3BlZWQ9MCxlLmFuZ3VsYXJTcGVlZD0wLGUubW90aW9uPTAsbnx8aS50cmlnZ2VyKGUsXCJzbGVlcFN0YXJ0XCIpKTooZS5pc1NsZWVwaW5nPSExLGUuc2xlZXBDb3VudGVyPTAsbiYmaS50cmlnZ2VyKGUsXCJzbGVlcEVuZFwiKSl9fSgpfSx7XCIuL0V2ZW50c1wiOjE2fV0sMjM6W2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24obil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2NvcmUvQ29tbW9uXCIpLHM9ZShcIi4uL2JvZHkvQm9keVwiKSxhPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIiksbD1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLGM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cuZGVjb21wOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBuP24uZGVjb21wOm51bGw7IWZ1bmN0aW9uKCl7by5yZWN0YW5nbGU9ZnVuY3Rpb24oZSx0LG4sbyxhKXthPWF8fHt9O3ZhciBsPXtsYWJlbDpcIlJlY3RhbmdsZSBCb2R5XCIscG9zaXRpb246e3g6ZSx5OnR9LHZlcnRpY2VzOmkuZnJvbVBhdGgoXCJMIDAgMCBMIFwiK24rXCIgMCBMIFwiK24rXCIgXCIrbytcIiBMIDAgXCIrbyl9O2lmKGEuY2hhbWZlcil7dmFyIGM9YS5jaGFtZmVyO2wudmVydGljZXM9aS5jaGFtZmVyKGwudmVydGljZXMsYy5yYWRpdXMsYy5xdWFsaXR5LGMucXVhbGl0eU1pbixjLnF1YWxpdHlNYXgpLFxuZGVsZXRlIGEuY2hhbWZlcn1yZXR1cm4gcy5jcmVhdGUoci5leHRlbmQoe30sbCxhKSl9LG8udHJhcGV6b2lkPWZ1bmN0aW9uKGUsdCxuLG8sYSxsKXtsPWx8fHt9LGEqPS41O3ZhciBjLGQ9KDEtMiphKSpuLHU9biphLHA9dStkLGY9cCt1O2M9YTwuNT9cIkwgMCAwIEwgXCIrdStcIiBcIistbytcIiBMIFwiK3ArXCIgXCIrLW8rXCIgTCBcIitmK1wiIDBcIjpcIkwgMCAwIEwgXCIrcCtcIiBcIistbytcIiBMIFwiK2YrXCIgMFwiO3ZhciBtPXtsYWJlbDpcIlRyYXBlem9pZCBCb2R5XCIscG9zaXRpb246e3g6ZSx5OnR9LHZlcnRpY2VzOmkuZnJvbVBhdGgoYyl9O2lmKGwuY2hhbWZlcil7dmFyIHY9bC5jaGFtZmVyO20udmVydGljZXM9aS5jaGFtZmVyKG0udmVydGljZXMsdi5yYWRpdXMsdi5xdWFsaXR5LHYucXVhbGl0eU1pbix2LnF1YWxpdHlNYXgpLGRlbGV0ZSBsLmNoYW1mZXJ9cmV0dXJuIHMuY3JlYXRlKHIuZXh0ZW5kKHt9LG0sbCkpfSxvLmNpcmNsZT1mdW5jdGlvbihlLHQsbixpLHMpe2k9aXx8e307dmFyIGE9e2xhYmVsOlwiQ2lyY2xlIEJvZHlcIixjaXJjbGVSYWRpdXM6bn07cz1zfHwyNTt2YXIgbD1NYXRoLmNlaWwoTWF0aC5tYXgoMTAsTWF0aC5taW4ocyxuKSkpO3JldHVybiBsJTI9PT0xJiYobCs9MSksby5wb2x5Z29uKGUsdCxsLG4sci5leHRlbmQoe30sYSxpKSl9LG8ucG9seWdvbj1mdW5jdGlvbihlLHQsbixhLGwpe2lmKGw9bHx8e30sbjwzKXJldHVybiBvLmNpcmNsZShlLHQsYSxsKTtmb3IodmFyIGM9MipNYXRoLlBJL24sZD1cIlwiLHU9LjUqYyxwPTA7cDxuO3ArPTEpe3ZhciBmPXUrcCpjLG09TWF0aC5jb3MoZikqYSx2PU1hdGguc2luKGYpKmE7ZCs9XCJMIFwiK20udG9GaXhlZCgzKStcIiBcIit2LnRvRml4ZWQoMykrXCIgXCJ9dmFyIHk9e2xhYmVsOlwiUG9seWdvbiBCb2R5XCIscG9zaXRpb246e3g6ZSx5OnR9LHZlcnRpY2VzOmkuZnJvbVBhdGgoZCl9O2lmKGwuY2hhbWZlcil7dmFyIGc9bC5jaGFtZmVyO3kudmVydGljZXM9aS5jaGFtZmVyKHkudmVydGljZXMsZy5yYWRpdXMsZy5xdWFsaXR5LGcucXVhbGl0eU1pbixnLnF1YWxpdHlNYXgpLFxuZGVsZXRlIGwuY2hhbWZlcn1yZXR1cm4gcy5jcmVhdGUoci5leHRlbmQoe30seSxsKSl9LG8uZnJvbVZlcnRpY2VzPWZ1bmN0aW9uKGUsdCxuLG8sZCx1LHApe3ZhciBmLG0sdix5LGcseCxoLGIsdztmb3Iobz1vfHx7fSxtPVtdLGQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGQmJmQsdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgdT91Oi4wMSxwPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwP3A6MTAsY3x8ci53YXJuKFwiQm9kaWVzLmZyb21WZXJ0aWNlczogcG9seS1kZWNvbXAuanMgcmVxdWlyZWQuIENvdWxkIG5vdCBkZWNvbXBvc2UgdmVydGljZXMuIEZhbGxiYWNrIHRvIGNvbnZleCBodWxsLlwiKSxyLmlzQXJyYXkoblswXSl8fChuPVtuXSksYj0wO2I8bi5sZW5ndGg7Yis9MSlpZih5PW5bYl0sdj1pLmlzQ29udmV4KHkpLHZ8fCFjKXk9dj9pLmNsb2Nrd2lzZVNvcnQoeSk6aS5odWxsKHkpLG0ucHVzaCh7cG9zaXRpb246e3g6ZSx5OnR9LHZlcnRpY2VzOnl9KTtlbHNle3ZhciBTPXkubWFwKGZ1bmN0aW9uKGUpe3JldHVybltlLngsZS55XX0pO2MubWFrZUNDVyhTKSx1IT09ITEmJmMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKFMsdSk7dmFyIEM9Yy5xdWlja0RlY29tcChTKTtmb3IoZz0wO2c8Qy5sZW5ndGg7ZysrKXt2YXIgQT1DW2ddLFA9QS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue3g6ZVswXSx5OmVbMV19fSk7cD4wJiZpLmFyZWEoUCk8cHx8bS5wdXNoKHtwb3NpdGlvbjppLmNlbnRyZShQKSx2ZXJ0aWNlczpQfSl9fWZvcihnPTA7ZzxtLmxlbmd0aDtnKyspbVtnXT1zLmNyZWF0ZShyLmV4dGVuZChtW2ddLG8pKTtpZihkKXt2YXIgQj01O2ZvcihnPTA7ZzxtLmxlbmd0aDtnKyspe3ZhciBNPW1bZ107Zm9yKHg9ZysxO3g8bS5sZW5ndGg7eCsrKXt2YXIgaz1tW3hdO2lmKGEub3ZlcmxhcHMoTS5ib3VuZHMsay5ib3VuZHMpKXt2YXIgST1NLnZlcnRpY2VzLFQ9ay52ZXJ0aWNlcztmb3IoaD0wO2g8TS52ZXJ0aWNlcy5sZW5ndGg7aCsrKWZvcih3PTA7dzxrLnZlcnRpY2VzLmxlbmd0aDt3Kyspe1xudmFyIFY9bC5tYWduaXR1ZGVTcXVhcmVkKGwuc3ViKElbKGgrMSklSS5sZW5ndGhdLFRbd10pKSxfPWwubWFnbml0dWRlU3F1YXJlZChsLnN1YihJW2hdLFRbKHcrMSklVC5sZW5ndGhdKSk7VjxCJiZfPEImJihJW2hdLmlzSW50ZXJuYWw9ITAsVFt3XS5pc0ludGVybmFsPSEwKX19fX19cmV0dXJuIG0ubGVuZ3RoPjE/KGY9cy5jcmVhdGUoci5leHRlbmQoe3BhcnRzOm0uc2xpY2UoMCl9LG8pKSxzLnNldFBvc2l0aW9uKGYse3g6ZSx5OnR9KSxmKTptWzBdfX0oKX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se1wiLi4vYm9keS9Cb2R5XCI6MSxcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOX1dLDI0OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87dmFyIGk9ZShcIi4uL2JvZHkvQ29tcG9zaXRlXCIpLHI9ZShcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiKSxzPWUoXCIuLi9jb3JlL0NvbW1vblwiKSxhPWUoXCIuLi9ib2R5L0JvZHlcIiksbD1lKFwiLi9Cb2RpZXNcIik7IWZ1bmN0aW9uKCl7by5zdGFjaz1mdW5jdGlvbihlLHQsbixvLHIscyxsKXtmb3IodmFyIGMsZD1pLmNyZWF0ZSh7bGFiZWw6XCJTdGFja1wifSksdT1lLHA9dCxmPTAsbT0wO208bzttKyspe2Zvcih2YXIgdj0wLHk9MDt5PG47eSsrKXt2YXIgZz1sKHUscCx5LG0sYyxmKTtpZihnKXt2YXIgeD1nLmJvdW5kcy5tYXgueS1nLmJvdW5kcy5taW4ueSxoPWcuYm91bmRzLm1heC54LWcuYm91bmRzLm1pbi54O3g+diYmKHY9eCksYS50cmFuc2xhdGUoZyx7eDouNSpoLHk6LjUqeH0pLHU9Zy5ib3VuZHMubWF4LngrcixpLmFkZEJvZHkoZCxnKSxjPWcsZis9MX1lbHNlIHUrPXJ9cCs9ditzLHU9ZX1yZXR1cm4gZH0sby5jaGFpbj1mdW5jdGlvbihlLHQsbixvLGEsbCl7XG5mb3IodmFyIGM9ZS5ib2RpZXMsZD0xO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgdT1jW2QtMV0scD1jW2RdLGY9dS5ib3VuZHMubWF4LnktdS5ib3VuZHMubWluLnksbT11LmJvdW5kcy5tYXgueC11LmJvdW5kcy5taW4ueCx2PXAuYm91bmRzLm1heC55LXAuYm91bmRzLm1pbi55LHk9cC5ib3VuZHMubWF4LngtcC5ib3VuZHMubWluLngsZz17Ym9keUE6dSxwb2ludEE6e3g6bSp0LHk6ZipufSxib2R5QjpwLHBvaW50Qjp7eDp5Km8seTp2KmF9fSx4PXMuZXh0ZW5kKGcsbCk7aS5hZGRDb25zdHJhaW50KGUsci5jcmVhdGUoeCkpfXJldHVybiBlLmxhYmVsKz1cIiBDaGFpblwiLGV9LG8ubWVzaD1mdW5jdGlvbihlLHQsbixvLGEpe3ZhciBsLGMsZCx1LHAsZj1lLmJvZGllcztmb3IobD0wO2w8bjtsKyspe2ZvcihjPTE7Yzx0O2MrKylkPWZbYy0xK2wqdF0sdT1mW2MrbCp0XSxpLmFkZENvbnN0cmFpbnQoZSxyLmNyZWF0ZShzLmV4dGVuZCh7Ym9keUE6ZCxib2R5Qjp1fSxhKSkpO2lmKGw+MClmb3IoYz0wO2M8dDtjKyspZD1mW2MrKGwtMSkqdF0sdT1mW2MrbCp0XSxpLmFkZENvbnN0cmFpbnQoZSxyLmNyZWF0ZShzLmV4dGVuZCh7Ym9keUE6ZCxib2R5Qjp1fSxhKSkpLG8mJmM+MCYmKHA9ZltjLTErKGwtMSkqdF0saS5hZGRDb25zdHJhaW50KGUsci5jcmVhdGUocy5leHRlbmQoe2JvZHlBOnAsYm9keUI6dX0sYSkpKSksbyYmYzx0LTEmJihwPWZbYysxKyhsLTEpKnRdLGkuYWRkQ29uc3RyYWludChlLHIuY3JlYXRlKHMuZXh0ZW5kKHtib2R5QTpwLGJvZHlCOnV9LGEpKSkpfXJldHVybiBlLmxhYmVsKz1cIiBNZXNoXCIsZX0sby5weXJhbWlkPWZ1bmN0aW9uKGUsdCxuLGkscixzLGwpe3JldHVybiBvLnN0YWNrKGUsdCxuLGkscixzLGZ1bmN0aW9uKHQsbyxzLGMsZCx1KXt2YXIgcD1NYXRoLm1pbihpLE1hdGguY2VpbChuLzIpKSxmPWQ/ZC5ib3VuZHMubWF4LngtZC5ib3VuZHMubWluLng6MDtpZighKGM+cCkpe2M9cC1jO3ZhciBtPWMsdj1uLTEtYztpZighKHM8bXx8cz52KSl7XG4xPT09dSYmYS50cmFuc2xhdGUoZCx7eDoocysobiUyPT09MT8xOi0xKSkqZix5OjB9KTt2YXIgeT1kP3MqZjowO3JldHVybiBsKGUreStzKnIsbyxzLGMsZCx1KX19fSl9LG8ubmV3dG9uc0NyYWRsZT1mdW5jdGlvbihlLHQsbixvLHMpe2Zvcih2YXIgYT1pLmNyZWF0ZSh7bGFiZWw6XCJOZXd0b25zIENyYWRsZVwifSksYz0wO2M8bjtjKyspe3ZhciBkPTEuOSx1PWwuY2lyY2xlKGUrYyoobypkKSx0K3Msbyx7aW5lcnRpYToxLzAscmVzdGl0dXRpb246MSxmcmljdGlvbjowLGZyaWN0aW9uQWlyOjFlLTQsc2xvcDoxfSkscD1yLmNyZWF0ZSh7cG9pbnRBOnt4OmUrYyoobypkKSx5OnR9LGJvZHlCOnV9KTtpLmFkZEJvZHkoYSx1KSxpLmFkZENvbnN0cmFpbnQoYSxwKX1yZXR1cm4gYX0sby5jYXI9ZnVuY3Rpb24oZSx0LG4sbyxzKXt2YXIgYz1hLm5leHRHcm91cCghMCksZD0yMCx1PS41Ki1uK2QscD0uNSpuLWQsZj0wLG09aS5jcmVhdGUoe2xhYmVsOlwiQ2FyXCJ9KSx2PWwucmVjdGFuZ2xlKGUsdCxuLG8se2NvbGxpc2lvbkZpbHRlcjp7Z3JvdXA6Y30sY2hhbWZlcjp7cmFkaXVzOi41Km99LGRlbnNpdHk6MmUtNH0pLHk9bC5jaXJjbGUoZSt1LHQrZixzLHtjb2xsaXNpb25GaWx0ZXI6e2dyb3VwOmN9LGZyaWN0aW9uOi44fSksZz1sLmNpcmNsZShlK3AsdCtmLHMse2NvbGxpc2lvbkZpbHRlcjp7Z3JvdXA6Y30sZnJpY3Rpb246Ljh9KSx4PXIuY3JlYXRlKHtib2R5Qjp2LHBvaW50Qjp7eDp1LHk6Zn0sYm9keUE6eSxzdGlmZm5lc3M6MSxsZW5ndGg6MH0pLGg9ci5jcmVhdGUoe2JvZHlCOnYscG9pbnRCOnt4OnAseTpmfSxib2R5QTpnLHN0aWZmbmVzczoxLGxlbmd0aDowfSk7cmV0dXJuIGkuYWRkQm9keShtLHYpLGkuYWRkQm9keShtLHkpLGkuYWRkQm9keShtLGcpLGkuYWRkQ29uc3RyYWludChtLHgpLGkuYWRkQ29uc3RyYWludChtLGgpLG19LG8uc29mdEJvZHk9ZnVuY3Rpb24oZSx0LG4saSxyLGEsYyxkLHUscCl7dT1zLmV4dGVuZCh7aW5lcnRpYToxLzB9LHUpLHA9cy5leHRlbmQoe1xuc3RpZmZuZXNzOi4yLHJlbmRlcjp7dHlwZTpcImxpbmVcIixhbmNob3JzOiExfX0scCk7dmFyIGY9by5zdGFjayhlLHQsbixpLHIsYSxmdW5jdGlvbihlLHQpe3JldHVybiBsLmNpcmNsZShlLHQsZCx1KX0pO3JldHVybiBvLm1lc2goZixuLGksYyxwKSxmLmxhYmVsPVwiU29mdCBCb2R5XCIsZn19KCl9LHtcIi4uL2JvZHkvQm9keVwiOjEsXCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIjoxMixcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuL0JvZGllc1wiOjIzfV0sMjU6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLHI9ZShcIi4uL2NvcmUvQ29tbW9uXCIpOyFmdW5jdGlvbigpe28uZnJvbVZlcnRpY2VzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBvPShuKzEpJWUubGVuZ3RoLHM9aS5ub3JtYWxpc2Uoe3g6ZVtvXS55LWVbbl0ueSx5OmVbbl0ueC1lW29dLnh9KSxhPTA9PT1zLnk/MS8wOnMueC9zLnk7YT1hLnRvRml4ZWQoMykudG9TdHJpbmcoKSx0W2FdPXN9cmV0dXJuIHIudmFsdWVzKHQpfSxvLnJvdGF0ZT1mdW5jdGlvbihlLHQpe2lmKDAhPT10KWZvcih2YXIgbj1NYXRoLmNvcyh0KSxvPU1hdGguc2luKHQpLGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIHIscz1lW2ldO3I9cy54Km4tcy55Km8scy55PXMueCpvK3MueSpuLHMueD1yfX19KCl9LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOH1dLDI2OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW8sZnVuY3Rpb24oKXtvLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17bWluOnt4OjAseTowfSxtYXg6e3g6MCx5OjB9fTtyZXR1cm4gZSYmby51cGRhdGUodCxlKSx0fSxvLnVwZGF0ZT1mdW5jdGlvbihlLHQsbil7ZS5taW4ueD0xLzAsZS5tYXgueD0tKDEvMCksZS5taW4ueT0xLzAsZS5tYXgueT0tKDEvMCk7Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspe1xudmFyIGk9dFtvXTtpLng+ZS5tYXgueCYmKGUubWF4Lng9aS54KSxpLng8ZS5taW4ueCYmKGUubWluLng9aS54KSxpLnk+ZS5tYXgueSYmKGUubWF4Lnk9aS55KSxpLnk8ZS5taW4ueSYmKGUubWluLnk9aS55KX1uJiYobi54PjA/ZS5tYXgueCs9bi54OmUubWluLngrPW4ueCxuLnk+MD9lLm1heC55Kz1uLnk6ZS5taW4ueSs9bi55KX0sby5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybiB0Lng+PWUubWluLngmJnQueDw9ZS5tYXgueCYmdC55Pj1lLm1pbi55JiZ0Lnk8PWUubWF4Lnl9LG8ub3ZlcmxhcHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5taW4ueDw9dC5tYXgueCYmZS5tYXgueD49dC5taW4ueCYmZS5tYXgueT49dC5taW4ueSYmZS5taW4ueTw9dC5tYXgueX0sby50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0KXtlLm1pbi54Kz10LngsZS5tYXgueCs9dC54LGUubWluLnkrPXQueSxlLm1heC55Kz10Lnl9LG8uc2hpZnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLm1heC54LWUubWluLngsbz1lLm1heC55LWUubWluLnk7ZS5taW4ueD10LngsZS5tYXgueD10LngrbixlLm1pbi55PXQueSxlLm1heC55PXQueStvfX0oKX0se31dLDI3OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW87ZShcIi4uL2dlb21ldHJ5L0JvdW5kc1wiKTshZnVuY3Rpb24oKXtvLnBhdGhUb1ZlcnRpY2VzPWZ1bmN0aW9uKHQsbil7dmFyIG8saSxyLHMsYSxsLGMsZCx1LHAsZixtLHY9W10seT0wLGc9MCx4PTA7bj1ufHwxNTt2YXIgaD1mdW5jdGlvbihlLHQsbil7dmFyIG89biUyPT09MSYmbj4xO2lmKCF1fHxlIT11Lnh8fHQhPXUueSl7dSYmbz8oZj11LngsbT11LnkpOihmPTAsbT0wKTt2YXIgaT17eDpmK2UseTptK3R9OyFvJiZ1fHwodT1pKSx2LnB1c2goaSksZz1mK2UseD1tK3R9fSxiPWZ1bmN0aW9uKGUpe3ZhciB0PWUucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpO2lmKFwiWlwiIT09dCl7c3dpdGNoKHQpe2Nhc2VcIk1cIjpjYXNlXCJMXCI6Y2FzZVwiVFwiOmNhc2VcIkNcIjpcbmNhc2VcIlNcIjpjYXNlXCJRXCI6Zz1lLngseD1lLnk7YnJlYWs7Y2FzZVwiSFwiOmc9ZS54O2JyZWFrO2Nhc2VcIlZcIjp4PWUueX1oKGcseCxlLnBhdGhTZWdUeXBlKX19O2ZvcihlKHQpLHI9dC5nZXRUb3RhbExlbmd0aCgpLGw9W10sbz0wO288dC5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zO28rPTEpbC5wdXNoKHQucGF0aFNlZ0xpc3QuZ2V0SXRlbShvKSk7Zm9yKGM9bC5jb25jYXQoKTt5PHI7KXtpZihwPXQuZ2V0UGF0aFNlZ0F0TGVuZ3RoKHkpLGE9bFtwXSxhIT1kKXtmb3IoO2MubGVuZ3RoJiZjWzBdIT1hOyliKGMuc2hpZnQoKSk7ZD1hfXN3aXRjaChhLnBhdGhTZWdUeXBlQXNMZXR0ZXIudG9VcHBlckNhc2UoKSl7Y2FzZVwiQ1wiOmNhc2VcIlRcIjpjYXNlXCJTXCI6Y2FzZVwiUVwiOmNhc2VcIkFcIjpzPXQuZ2V0UG9pbnRBdExlbmd0aCh5KSxoKHMueCxzLnksMCl9eSs9bn1mb3Iobz0wLGk9Yy5sZW5ndGg7bzxpOysrbyliKGNbb10pO3JldHVybiB2fTt2YXIgZT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbixvLGkscixzLGE9ZS5wYXRoU2VnTGlzdCxsPTAsYz0wLGQ9YS5udW1iZXJPZkl0ZW1zLHU9MDt1PGQ7Kyt1KXt2YXIgcD1hLmdldEl0ZW0odSksZj1wLnBhdGhTZWdUeXBlQXNMZXR0ZXI7aWYoL1tNTEhWQ1NRVEFdLy50ZXN0KGYpKVwieFwiaW4gcCYmKGw9cC54KSxcInlcImluIHAmJihjPXAueSk7ZWxzZSBzd2l0Y2goXCJ4MVwiaW4gcCYmKG89bCtwLngxKSxcIngyXCJpbiBwJiYocj1sK3AueDIpLFwieTFcImluIHAmJihpPWMrcC55MSksXCJ5MlwiaW4gcCYmKHM9YytwLnkyKSxcInhcImluIHAmJihsKz1wLngpLFwieVwiaW4gcCYmKGMrPXAueSksZil7Y2FzZVwibVwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKGwsYyksdSk7YnJlYWs7Y2FzZVwibFwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzKGwsYyksdSk7YnJlYWs7Y2FzZVwiaFwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyhsKSx1KTticmVhaztcbmNhc2VcInZcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKGMpLHUpO2JyZWFrO2Nhc2VcImNcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FicyhsLGMsbyxpLHIscyksdSk7YnJlYWs7Y2FzZVwic1wiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzKGwsYyxyLHMpLHUpO2JyZWFrO2Nhc2VcInFcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNBYnMobCxjLG8saSksdSk7YnJlYWs7Y2FzZVwidFwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicyhsLGMpLHUpO2JyZWFrO2Nhc2VcImFcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0FyY0FicyhsLGMscC5yMSxwLnIyLHAuYW5nbGUscC5sYXJnZUFyY0ZsYWcscC5zd2VlcEZsYWcpLHUpO2JyZWFrO2Nhc2VcInpcIjpjYXNlXCJaXCI6bD10LGM9bn1cIk1cIiE9ZiYmXCJtXCIhPWZ8fCh0PWwsbj1jKX19fSgpfSx7XCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNn1dLDI4OltmdW5jdGlvbihlLHQsbil7dmFyIG89e307dC5leHBvcnRzPW8sZnVuY3Rpb24oKXtvLmNyZWF0ZT1mdW5jdGlvbihlLHQpe3JldHVybnt4OmV8fDAseTp0fHwwfX0sby5jbG9uZT1mdW5jdGlvbihlKXtyZXR1cm57eDplLngseTplLnl9fSxvLm1hZ25pdHVkZT1mdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5zcXJ0KGUueCplLngrZS55KmUueSl9LG8ubWFnbml0dWRlU3F1YXJlZD1mdW5jdGlvbihlKXtyZXR1cm4gZS54KmUueCtlLnkqZS55fSxvLnJvdGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIG89TWF0aC5jb3ModCksaT1NYXRoLnNpbih0KTtufHwobj17fSk7dmFyIHI9ZS54Km8tZS55Kmk7cmV0dXJuIG4ueT1lLngqaStlLnkqbyxuLng9cixufSxvLnJvdGF0ZUFib3V0PWZ1bmN0aW9uKGUsdCxuLG8pe3ZhciBpPU1hdGguY29zKHQpLHI9TWF0aC5zaW4odCk7XG5vfHwobz17fSk7dmFyIHM9bi54KygoZS54LW4ueCkqaS0oZS55LW4ueSkqcik7cmV0dXJuIG8ueT1uLnkrKChlLngtbi54KSpyKyhlLnktbi55KSppKSxvLng9cyxvfSxvLm5vcm1hbGlzZT1mdW5jdGlvbihlKXt2YXIgdD1vLm1hZ25pdHVkZShlKTtyZXR1cm4gMD09PXQ/e3g6MCx5OjB9Ont4OmUueC90LHk6ZS55L3R9fSxvLmRvdD1mdW5jdGlvbihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9LG8uY3Jvc3M9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS54KnQueS1lLnkqdC54fSxvLmNyb3NzMz1mdW5jdGlvbihlLHQsbil7cmV0dXJuKHQueC1lLngpKihuLnktZS55KS0odC55LWUueSkqKG4ueC1lLngpfSxvLmFkZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIG58fChuPXt9KSxuLng9ZS54K3QueCxuLnk9ZS55K3QueSxufSxvLnN1Yj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIG58fChuPXt9KSxuLng9ZS54LXQueCxuLnk9ZS55LXQueSxufSxvLm11bHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm57eDplLngqdCx5OmUueSp0fX0sby5kaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm57eDplLngvdCx5OmUueS90fX0sby5wZXJwPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dD09PSEwPy0xOjEse3g6dCotZS55LHk6dCplLnh9fSxvLm5lZz1mdW5jdGlvbihlKXtyZXR1cm57eDotZS54LHk6LWUueX19LG8uYW5nbGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfSxvLl90ZW1wPVtvLmNyZWF0ZSgpLG8uY3JlYXRlKCksby5jcmVhdGUoKSxvLmNyZWF0ZSgpLG8uY3JlYXRlKCksby5jcmVhdGUoKV19KCl9LHt9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuLi9nZW9tZXRyeS9WZWN0b3JcIikscj1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7by5jcmVhdGU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W10sbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgaT1lW29dLHI9e3g6aS54LHk6aS55LGluZGV4Om8sXG5ib2R5OnQsaXNJbnRlcm5hbDohMX07bi5wdXNoKHIpfXJldHVybiBufSxvLmZyb21QYXRoPWZ1bmN0aW9uKGUsdCl7dmFyIG49L0w/XFxzKihbXFwtXFxkXFwuZV0rKVtcXHMsXSooW1xcLVxcZFxcLmVdKykqL2dpLGk9W107cmV0dXJuIGUucmVwbGFjZShuLGZ1bmN0aW9uKGUsdCxuKXtpLnB1c2goe3g6cGFyc2VGbG9hdCh0KSx5OnBhcnNlRmxvYXQobil9KX0pLG8uY3JlYXRlKGksdCl9LG8uY2VudHJlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuLHIscz1vLmFyZWEoZSwhMCksYT17eDowLHk6MH0sbD0wO2w8ZS5sZW5ndGg7bCsrKXI9KGwrMSklZS5sZW5ndGgsdD1pLmNyb3NzKGVbbF0sZVtyXSksbj1pLm11bHQoaS5hZGQoZVtsXSxlW3JdKSx0KSxhPWkuYWRkKGEsbik7cmV0dXJuIGkuZGl2KGEsNipzKX0sby5tZWFuPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17eDowLHk6MH0sbj0wO248ZS5sZW5ndGg7bisrKXQueCs9ZVtuXS54LHQueSs9ZVtuXS55O3JldHVybiBpLmRpdih0LGUubGVuZ3RoKX0sby5hcmVhPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTAsbz1lLmxlbmd0aC0xLGk9MDtpPGUubGVuZ3RoO2krKyluKz0oZVtvXS54LWVbaV0ueCkqKGVbb10ueStlW2ldLnkpLG89aTtyZXR1cm4gdD9uLzI6TWF0aC5hYnMobikvMn0sby5pbmVydGlhPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuLG8scj0wLHM9MCxhPWUsbD0wO2w8YS5sZW5ndGg7bCsrKW89KGwrMSklYS5sZW5ndGgsbj1NYXRoLmFicyhpLmNyb3NzKGFbb10sYVtsXSkpLHIrPW4qKGkuZG90KGFbb10sYVtvXSkraS5kb3QoYVtvXSxhW2xdKStpLmRvdChhW2xdLGFbbF0pKSxzKz1uO3JldHVybiB0LzYqKHIvcyl9LG8udHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbztpZihuKWZvcihvPTA7bzxlLmxlbmd0aDtvKyspZVtvXS54Kz10LngqbixlW29dLnkrPXQueSpuO2Vsc2UgZm9yKG89MDtvPGUubGVuZ3RoO28rKyllW29dLngrPXQueCxlW29dLnkrPXQueTtyZXR1cm4gZX0sby5yb3RhdGU9ZnVuY3Rpb24oZSx0LG4pe1xuaWYoMCE9PXQpe2Zvcih2YXIgbz1NYXRoLmNvcyh0KSxpPU1hdGguc2luKHQpLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIHM9ZVtyXSxhPXMueC1uLngsbD1zLnktbi55O3MueD1uLngrKGEqby1sKmkpLHMueT1uLnkrKGEqaStsKm8pfXJldHVybiBlfX0sby5jb250YWlucz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgbz1lW25dLGk9ZVsobisxKSVlLmxlbmd0aF07aWYoKHQueC1vLngpKihpLnktby55KSsodC55LW8ueSkqKG8ueC1pLngpPjApcmV0dXJuITF9cmV0dXJuITB9LG8uc2NhbGU9ZnVuY3Rpb24oZSx0LG4scil7aWYoMT09PXQmJjE9PT1uKXJldHVybiBlO3I9cnx8by5jZW50cmUoZSk7Zm9yKHZhciBzLGEsbD0wO2w8ZS5sZW5ndGg7bCsrKXM9ZVtsXSxhPWkuc3ViKHMsciksZVtsXS54PXIueCthLngqdCxlW2xdLnk9ci55K2EueSpuO3JldHVybiBlfSxvLmNoYW1mZXI9ZnVuY3Rpb24oZSx0LG4sbyxzKXt0PXR8fFs4XSx0Lmxlbmd0aHx8KHQ9W3RdKSxuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuP246LTEsbz1vfHwyLHM9c3x8MTQ7Zm9yKHZhciBhPVtdLGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIGM9ZVtsLTE+PTA/bC0xOmUubGVuZ3RoLTFdLGQ9ZVtsXSx1PWVbKGwrMSklZS5sZW5ndGhdLHA9dFtsPHQubGVuZ3RoP2w6dC5sZW5ndGgtMV07aWYoMCE9PXApe3ZhciBmPWkubm9ybWFsaXNlKHt4OmQueS1jLnkseTpjLngtZC54fSksbT1pLm5vcm1hbGlzZSh7eDp1LnktZC55LHk6ZC54LXUueH0pLHY9TWF0aC5zcXJ0KDIqTWF0aC5wb3cocCwyKSkseT1pLm11bHQoci5jbG9uZShmKSxwKSxnPWkubm9ybWFsaXNlKGkubXVsdChpLmFkZChmLG0pLC41KSkseD1pLnN1YihkLGkubXVsdChnLHYpKSxoPW47bj09PS0xJiYoaD0xLjc1Kk1hdGgucG93KHAsLjMyKSksaD1yLmNsYW1wKGgsbyxzKSxoJTI9PT0xJiYoaCs9MSk7Zm9yKHZhciBiPU1hdGguYWNvcyhpLmRvdChmLG0pKSx3PWIvaCxTPTA7UzxoO1MrKylhLnB1c2goaS5hZGQoaS5yb3RhdGUoeSx3KlMpLHgpKTtcbn1lbHNlIGEucHVzaChkKX1yZXR1cm4gYX0sby5jbG9ja3dpc2VTb3J0PWZ1bmN0aW9uKGUpe3ZhciB0PW8ubWVhbihlKTtyZXR1cm4gZS5zb3J0KGZ1bmN0aW9uKGUsbil7cmV0dXJuIGkuYW5nbGUodCxlKS1pLmFuZ2xlKHQsbil9KSxlfSxvLmlzQ29udmV4PWZ1bmN0aW9uKGUpe3ZhciB0LG4sbyxpLHI9MCxzPWUubGVuZ3RoO2lmKHM8MylyZXR1cm4gbnVsbDtmb3IodD0wO3Q8czt0KyspaWYobj0odCsxKSVzLG89KHQrMiklcyxpPShlW25dLngtZVt0XS54KSooZVtvXS55LWVbbl0ueSksaS09KGVbbl0ueS1lW3RdLnkpKihlW29dLngtZVtuXS54KSxpPDA/cnw9MTppPjAmJihyfD0yKSwzPT09cilyZXR1cm4hMTtyZXR1cm4gMCE9PXJ8fG51bGx9LG8uaHVsbD1mdW5jdGlvbihlKXt2YXIgdCxuLG89W10scj1bXTtmb3IoZT1lLnNsaWNlKDApLGUuc29ydChmdW5jdGlvbihlLHQpe3ZhciBuPWUueC10Lng7cmV0dXJuIDAhPT1uP246ZS55LXQueX0pLG49MDtuPGUubGVuZ3RoO24rPTEpe2Zvcih0PWVbbl07ci5sZW5ndGg+PTImJmkuY3Jvc3MzKHJbci5sZW5ndGgtMl0scltyLmxlbmd0aC0xXSx0KTw9MDspci5wb3AoKTtyLnB1c2godCl9Zm9yKG49ZS5sZW5ndGgtMTtuPj0wO24tPTEpe2Zvcih0PWVbbl07by5sZW5ndGg+PTImJmkuY3Jvc3MzKG9bby5sZW5ndGgtMl0sb1tvLmxlbmd0aC0xXSx0KTw9MDspby5wb3AoKTtvLnB1c2godCl9cmV0dXJuIG8ucG9wKCksci5wb3AoKSxvLmNvbmNhdChyKX19KCl9LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOH1dLDMwOltmdW5jdGlvbihlLHQsbil7dmFyIG89dC5leHBvcnRzPWUoXCIuLi9jb3JlL01hdHRlclwiKTtvLkJvZHk9ZShcIi4uL2JvZHkvQm9keVwiKSxvLkNvbXBvc2l0ZT1lKFwiLi4vYm9keS9Db21wb3NpdGVcIiksby5Xb3JsZD1lKFwiLi4vYm9keS9Xb3JsZFwiKSxvLkNvbnRhY3Q9ZShcIi4uL2NvbGxpc2lvbi9Db250YWN0XCIpLG8uRGV0ZWN0b3I9ZShcIi4uL2NvbGxpc2lvbi9EZXRlY3RvclwiKSxcbm8uR3JpZD1lKFwiLi4vY29sbGlzaW9uL0dyaWRcIiksby5QYWlycz1lKFwiLi4vY29sbGlzaW9uL1BhaXJzXCIpLG8uUGFpcj1lKFwiLi4vY29sbGlzaW9uL1BhaXJcIiksby5RdWVyeT1lKFwiLi4vY29sbGlzaW9uL1F1ZXJ5XCIpLG8uUmVzb2x2ZXI9ZShcIi4uL2NvbGxpc2lvbi9SZXNvbHZlclwiKSxvLlNBVD1lKFwiLi4vY29sbGlzaW9uL1NBVFwiKSxvLkNvbnN0cmFpbnQ9ZShcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiKSxvLk1vdXNlQ29uc3RyYWludD1lKFwiLi4vY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnRcIiksby5Db21tb249ZShcIi4uL2NvcmUvQ29tbW9uXCIpLG8uRW5naW5lPWUoXCIuLi9jb3JlL0VuZ2luZVwiKSxvLkV2ZW50cz1lKFwiLi4vY29yZS9FdmVudHNcIiksby5Nb3VzZT1lKFwiLi4vY29yZS9Nb3VzZVwiKSxvLlJ1bm5lcj1lKFwiLi4vY29yZS9SdW5uZXJcIiksby5TbGVlcGluZz1lKFwiLi4vY29yZS9TbGVlcGluZ1wiKSxvLlBsdWdpbj1lKFwiLi4vY29yZS9QbHVnaW5cIiksby5Cb2RpZXM9ZShcIi4uL2ZhY3RvcnkvQm9kaWVzXCIpLG8uQ29tcG9zaXRlcz1lKFwiLi4vZmFjdG9yeS9Db21wb3NpdGVzXCIpLG8uQXhlcz1lKFwiLi4vZ2VvbWV0cnkvQXhlc1wiKSxvLkJvdW5kcz1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLG8uU3ZnPWUoXCIuLi9nZW9tZXRyeS9TdmdcIiksby5WZWN0b3I9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxvLlZlcnRpY2VzPWUoXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiKSxvLlJlbmRlcj1lKFwiLi4vcmVuZGVyL1JlbmRlclwiKSxvLlJlbmRlclBpeGk9ZShcIi4uL3JlbmRlci9SZW5kZXJQaXhpXCIpLG8uV29ybGQuYWRkPW8uQ29tcG9zaXRlLmFkZCxvLldvcmxkLnJlbW92ZT1vLkNvbXBvc2l0ZS5yZW1vdmUsby5Xb3JsZC5hZGRDb21wb3NpdGU9by5Db21wb3NpdGUuYWRkQ29tcG9zaXRlLG8uV29ybGQuYWRkQm9keT1vLkNvbXBvc2l0ZS5hZGRCb2R5LG8uV29ybGQuYWRkQ29uc3RyYWludD1vLkNvbXBvc2l0ZS5hZGRDb25zdHJhaW50LG8uV29ybGQuY2xlYXI9by5Db21wb3NpdGUuY2xlYXIsXG5vLkVuZ2luZS5ydW49by5SdW5uZXIucnVufSx7XCIuLi9ib2R5L0JvZHlcIjoxLFwiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vYm9keS9Xb3JsZFwiOjMsXCIuLi9jb2xsaXNpb24vQ29udGFjdFwiOjQsXCIuLi9jb2xsaXNpb24vRGV0ZWN0b3JcIjo1LFwiLi4vY29sbGlzaW9uL0dyaWRcIjo2LFwiLi4vY29sbGlzaW9uL1BhaXJcIjo3LFwiLi4vY29sbGlzaW9uL1BhaXJzXCI6OCxcIi4uL2NvbGxpc2lvbi9RdWVyeVwiOjksXCIuLi9jb2xsaXNpb24vUmVzb2x2ZXJcIjoxMCxcIi4uL2NvbGxpc2lvbi9TQVRcIjoxMSxcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiOjEyLFwiLi4vY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnRcIjoxMyxcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9jb3JlL0VuZ2luZVwiOjE1LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4uL2NvcmUvTWF0dGVyXCI6MTcsXCIuLi9jb3JlL01ldHJpY3NcIjoxOCxcIi4uL2NvcmUvTW91c2VcIjoxOSxcIi4uL2NvcmUvUGx1Z2luXCI6MjAsXCIuLi9jb3JlL1J1bm5lclwiOjIxLFwiLi4vY29yZS9TbGVlcGluZ1wiOjIyLFwiLi4vZmFjdG9yeS9Cb2RpZXNcIjoyMyxcIi4uL2ZhY3RvcnkvQ29tcG9zaXRlc1wiOjI0LFwiLi4vZ2VvbWV0cnkvQXhlc1wiOjI1LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9TdmdcIjoyNyxcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOSxcIi4uL3JlbmRlci9SZW5kZXJcIjozMSxcIi4uL3JlbmRlci9SZW5kZXJQaXhpXCI6MzJ9XSwzMTpbZnVuY3Rpb24oZSx0LG4pe3ZhciBvPXt9O3QuZXhwb3J0cz1vO3ZhciBpPWUoXCIuLi9jb3JlL0NvbW1vblwiKSxyPWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSxzPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIiksYT1lKFwiLi4vY29yZS9FdmVudHNcIiksbD1lKFwiLi4vY29sbGlzaW9uL0dyaWRcIiksYz1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLGQ9ZShcIi4uL2NvcmUvTW91c2VcIik7IWZ1bmN0aW9uKCl7dmFyIGUsdDtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYoZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUpe1xud2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGkubm93KCkpfSwxZTMvNjApfSx0PXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKSxvLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17Y29udHJvbGxlcjpvLGVuZ2luZTpudWxsLGVsZW1lbnQ6bnVsbCxjYW52YXM6bnVsbCxtb3VzZTpudWxsLGZyYW1lUmVxdWVzdElkOm51bGwsb3B0aW9uczp7d2lkdGg6ODAwLGhlaWdodDo2MDAscGl4ZWxSYXRpbzoxLGJhY2tncm91bmQ6XCIjMTgxODFkXCIsd2lyZWZyYW1lQmFja2dyb3VuZDpcIiMwZjBmMTNcIixoYXNCb3VuZHM6ISFlLmJvdW5kcyxlbmFibGVkOiEwLHdpcmVmcmFtZXM6ITAsc2hvd1NsZWVwaW5nOiEwLHNob3dEZWJ1ZzohMSxzaG93QnJvYWRwaGFzZTohMSxzaG93Qm91bmRzOiExLHNob3dWZWxvY2l0eTohMSxzaG93Q29sbGlzaW9uczohMSxzaG93U2VwYXJhdGlvbnM6ITEsc2hvd0F4ZXM6ITEsc2hvd1Bvc2l0aW9uczohMSxzaG93QW5nbGVJbmRpY2F0b3I6ITEsc2hvd0lkczohMSxzaG93U2hhZG93czohMSxzaG93VmVydGV4TnVtYmVyczohMSxzaG93Q29udmV4SHVsbHM6ITEsc2hvd0ludGVybmFsRWRnZXM6ITEsc2hvd01vdXNlUG9zaXRpb246ITF9fSxyPWkuZXh0ZW5kKHQsZSk7cmV0dXJuIHIuY2FudmFzJiYoci5jYW52YXMud2lkdGg9ci5vcHRpb25zLndpZHRofHxyLmNhbnZhcy53aWR0aCxyLmNhbnZhcy5oZWlnaHQ9ci5vcHRpb25zLmhlaWdodHx8ci5jYW52YXMuaGVpZ2h0KSxyLm1vdXNlPWUubW91c2Usci5lbmdpbmU9ZS5lbmdpbmUsci5jYW52YXM9ci5jYW52YXN8fG4oci5vcHRpb25zLndpZHRoLHIub3B0aW9ucy5oZWlnaHQpLHIuY29udGV4dD1yLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksci50ZXh0dXJlcz17fSxyLmJvdW5kcz1yLmJvdW5kc3x8e21pbjp7eDowLFxueTowfSxtYXg6e3g6ci5jYW52YXMud2lkdGgseTpyLmNhbnZhcy5oZWlnaHR9fSwxIT09ci5vcHRpb25zLnBpeGVsUmF0aW8mJm8uc2V0UGl4ZWxSYXRpbyhyLHIub3B0aW9ucy5waXhlbFJhdGlvKSxpLmlzRWxlbWVudChyLmVsZW1lbnQpP3IuZWxlbWVudC5hcHBlbmRDaGlsZChyLmNhbnZhcyk6aS5sb2coXCJSZW5kZXIuY3JlYXRlOiBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgcmVuZGVyLmNhbnZhcyB3YXMgY3JlYXRlZCBidXQgbm90IGFwcGVuZGVkXCIsXCJ3YXJuXCIpLHJ9LG8ucnVuPWZ1bmN0aW9uKHQpeyFmdW5jdGlvbiBuKGkpe3QuZnJhbWVSZXF1ZXN0SWQ9ZShuKSxvLndvcmxkKHQpfSgpfSxvLnN0b3A9ZnVuY3Rpb24oZSl7dChlLmZyYW1lUmVxdWVzdElkKX0sby5zZXRQaXhlbFJhdGlvPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5vcHRpb25zLG89ZS5jYW52YXM7XCJhdXRvXCI9PT10JiYodD11KG8pKSxuLnBpeGVsUmF0aW89dCxvLnNldEF0dHJpYnV0ZShcImRhdGEtcGl4ZWwtcmF0aW9cIix0KSxvLndpZHRoPW4ud2lkdGgqdCxvLmhlaWdodD1uLmhlaWdodCp0LG8uc3R5bGUud2lkdGg9bi53aWR0aCtcInB4XCIsby5zdHlsZS5oZWlnaHQ9bi5oZWlnaHQrXCJweFwiLGUuY29udGV4dC5zY2FsZSh0LHQpfSxvLmxvb2tBdD1mdW5jdGlvbihlLHQsbixvKXtvPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBvfHxvLHQ9aS5pc0FycmF5KHQpP3Q6W3RdLG49bnx8e3g6MCx5OjB9O2Zvcih2YXIgcj17bWluOnt4OjEvMCx5OjEvMH0sbWF4Ont4Oi0oMS8wKSx5Oi0oMS8wKX19LHM9MDtzPHQubGVuZ3RoO3MrPTEpe3ZhciBhPXRbc10sbD1hLmJvdW5kcz9hLmJvdW5kcy5taW46YS5taW58fGEucG9zaXRpb258fGEsYz1hLmJvdW5kcz9hLmJvdW5kcy5tYXg6YS5tYXh8fGEucG9zaXRpb258fGE7bCYmYyYmKGwueDxyLm1pbi54JiYoci5taW4ueD1sLngpLGMueD5yLm1heC54JiYoci5tYXgueD1jLngpLGwueTxyLm1pbi55JiYoci5taW4ueT1sLnkpLGMueT5yLm1heC55JiYoci5tYXgueT1jLnkpKTtcbn12YXIgdT1yLm1heC54LXIubWluLngrMipuLngscD1yLm1heC55LXIubWluLnkrMipuLnksZj1lLmNhbnZhcy5oZWlnaHQsbT1lLmNhbnZhcy53aWR0aCx2PW0vZix5PXUvcCxnPTEseD0xO3k+dj94PXkvdjpnPXYveSxlLm9wdGlvbnMuaGFzQm91bmRzPSEwLGUuYm91bmRzLm1pbi54PXIubWluLngsZS5ib3VuZHMubWF4Lng9ci5taW4ueCt1KmcsZS5ib3VuZHMubWluLnk9ci5taW4ueSxlLmJvdW5kcy5tYXgueT1yLm1pbi55K3AqeCxvJiYoZS5ib3VuZHMubWluLngrPS41KnUtdSpnKi41LGUuYm91bmRzLm1heC54Kz0uNSp1LXUqZyouNSxlLmJvdW5kcy5taW4ueSs9LjUqcC1wKngqLjUsZS5ib3VuZHMubWF4LnkrPS41KnAtcCp4Ki41KSxlLmJvdW5kcy5taW4ueC09bi54LGUuYm91bmRzLm1heC54LT1uLngsZS5ib3VuZHMubWluLnktPW4ueSxlLmJvdW5kcy5tYXgueS09bi55LGUubW91c2UmJihkLnNldFNjYWxlKGUubW91c2Use3g6KGUuYm91bmRzLm1heC54LWUuYm91bmRzLm1pbi54KS9lLmNhbnZhcy53aWR0aCx5OihlLmJvdW5kcy5tYXgueS1lLmJvdW5kcy5taW4ueSkvZS5jYW52YXMuaGVpZ2h0fSksZC5zZXRPZmZzZXQoZS5tb3VzZSxlLmJvdW5kcy5taW4pKX0sby5zdGFydFZpZXdUcmFuc2Zvcm09ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ib3VuZHMubWF4LngtZS5ib3VuZHMubWluLngsbj1lLmJvdW5kcy5tYXgueS1lLmJvdW5kcy5taW4ueSxvPXQvZS5vcHRpb25zLndpZHRoLGk9bi9lLm9wdGlvbnMuaGVpZ2h0O2UuY29udGV4dC5zY2FsZSgxL28sMS9pKSxlLmNvbnRleHQudHJhbnNsYXRlKC1lLmJvdW5kcy5taW4ueCwtZS5ib3VuZHMubWluLnkpfSxvLmVuZFZpZXdUcmFuc2Zvcm09ZnVuY3Rpb24oZSl7ZS5jb250ZXh0LnNldFRyYW5zZm9ybShlLm9wdGlvbnMucGl4ZWxSYXRpbywwLDAsZS5vcHRpb25zLnBpeGVsUmF0aW8sMCwwKX0sby53b3JsZD1mdW5jdGlvbihlKXt2YXIgdCxuPWUuZW5naW5lLGk9bi53b3JsZCx1PWUuY2FudmFzLHA9ZS5jb250ZXh0LG09ZS5vcHRpb25zLHY9ci5hbGxCb2RpZXMoaSkseT1yLmFsbENvbnN0cmFpbnRzKGkpLGc9bS53aXJlZnJhbWVzP20ud2lyZWZyYW1lQmFja2dyb3VuZDptLmJhY2tncm91bmQseD1bXSxoPVtdLGI9e1xudGltZXN0YW1wOm4udGltaW5nLnRpbWVzdGFtcH07aWYoYS50cmlnZ2VyKGUsXCJiZWZvcmVSZW5kZXJcIixiKSxlLmN1cnJlbnRCYWNrZ3JvdW5kIT09ZyYmZihlLGcpLHAuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWluXCIscC5maWxsU3R5bGU9XCJ0cmFuc3BhcmVudFwiLHAuZmlsbFJlY3QoMCwwLHUud2lkdGgsdS5oZWlnaHQpLHAuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLW92ZXJcIixtLmhhc0JvdW5kcyl7Zm9yKHQ9MDt0PHYubGVuZ3RoO3QrKyl7dmFyIHc9dlt0XTtzLm92ZXJsYXBzKHcuYm91bmRzLGUuYm91bmRzKSYmeC5wdXNoKHcpfWZvcih0PTA7dDx5Lmxlbmd0aDt0Kyspe3ZhciBTPXlbdF0sQz1TLmJvZHlBLEE9Uy5ib2R5QixQPVMucG9pbnRBLEI9Uy5wb2ludEI7QyYmKFA9Yy5hZGQoQy5wb3NpdGlvbixTLnBvaW50QSkpLEEmJihCPWMuYWRkKEEucG9zaXRpb24sUy5wb2ludEIpKSxQJiZCJiYocy5jb250YWlucyhlLmJvdW5kcyxQKXx8cy5jb250YWlucyhlLmJvdW5kcyxCKSkmJmgucHVzaChTKX1vLnN0YXJ0Vmlld1RyYW5zZm9ybShlKSxlLm1vdXNlJiYoZC5zZXRTY2FsZShlLm1vdXNlLHt4OihlLmJvdW5kcy5tYXgueC1lLmJvdW5kcy5taW4ueCkvZS5jYW52YXMud2lkdGgseTooZS5ib3VuZHMubWF4LnktZS5ib3VuZHMubWluLnkpL2UuY2FudmFzLmhlaWdodH0pLGQuc2V0T2Zmc2V0KGUubW91c2UsZS5ib3VuZHMubWluKSl9ZWxzZSBoPXkseD12OyFtLndpcmVmcmFtZXN8fG4uZW5hYmxlU2xlZXBpbmcmJm0uc2hvd1NsZWVwaW5nP28uYm9kaWVzKGUseCxwKToobS5zaG93Q29udmV4SHVsbHMmJm8uYm9keUNvbnZleEh1bGxzKGUseCxwKSxvLmJvZHlXaXJlZnJhbWVzKGUseCxwKSksbS5zaG93Qm91bmRzJiZvLmJvZHlCb3VuZHMoZSx4LHApLChtLnNob3dBeGVzfHxtLnNob3dBbmdsZUluZGljYXRvcikmJm8uYm9keUF4ZXMoZSx4LHApLG0uc2hvd1Bvc2l0aW9ucyYmby5ib2R5UG9zaXRpb25zKGUseCxwKSxtLnNob3dWZWxvY2l0eSYmby5ib2R5VmVsb2NpdHkoZSx4LHApLFxubS5zaG93SWRzJiZvLmJvZHlJZHMoZSx4LHApLG0uc2hvd1NlcGFyYXRpb25zJiZvLnNlcGFyYXRpb25zKGUsbi5wYWlycy5saXN0LHApLG0uc2hvd0NvbGxpc2lvbnMmJm8uY29sbGlzaW9ucyhlLG4ucGFpcnMubGlzdCxwKSxtLnNob3dWZXJ0ZXhOdW1iZXJzJiZvLnZlcnRleE51bWJlcnMoZSx4LHApLG0uc2hvd01vdXNlUG9zaXRpb24mJm8ubW91c2VQb3NpdGlvbihlLGUubW91c2UscCksby5jb25zdHJhaW50cyhoLHApLG0uc2hvd0Jyb2FkcGhhc2UmJm4uYnJvYWRwaGFzZS5jb250cm9sbGVyPT09bCYmby5ncmlkKGUsbi5icm9hZHBoYXNlLHApLG0uc2hvd0RlYnVnJiZvLmRlYnVnKGUscCksbS5oYXNCb3VuZHMmJm8uZW5kVmlld1RyYW5zZm9ybShlKSxhLnRyaWdnZXIoZSxcImFmdGVyUmVuZGVyXCIsYil9LG8uZGVidWc9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LG89ZS5lbmdpbmUsaT1vLndvcmxkLHM9by5tZXRyaWNzLGE9ZS5vcHRpb25zLGw9KHIuYWxsQm9kaWVzKGkpLFwiICAgIFwiKTtpZihvLnRpbWluZy50aW1lc3RhbXAtKGUuZGVidWdUaW1lc3RhbXB8fDApPj01MDApe3ZhciBjPVwiXCI7cy50aW1pbmcmJihjKz1cImZwczogXCIrTWF0aC5yb3VuZChzLnRpbWluZy5mcHMpK2wpLGUuZGVidWdTdHJpbmc9YyxlLmRlYnVnVGltZXN0YW1wPW8udGltaW5nLnRpbWVzdGFtcH1pZihlLmRlYnVnU3RyaW5nKXtuLmZvbnQ9XCIxMnB4IEFyaWFsXCIsYS53aXJlZnJhbWVzP24uZmlsbFN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjUpXCI6bi5maWxsU3R5bGU9XCJyZ2JhKDAsMCwwLDAuNSlcIjtmb3IodmFyIGQ9ZS5kZWJ1Z1N0cmluZy5zcGxpdChcIlxcblwiKSx1PTA7dTxkLmxlbmd0aDt1Kyspbi5maWxsVGV4dChkW3VdLDUwLDUwKzE4KnUpfX0sby5jb25zdHJhaW50cz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10LG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIHI9ZVtvXTtpZihyLnJlbmRlci52aXNpYmxlJiZyLnBvaW50QSYmci5wb2ludEIpe3ZhciBzLGEsbD1yLmJvZHlBLGQ9ci5ib2R5QjtcbmlmKHM9bD9jLmFkZChsLnBvc2l0aW9uLHIucG9pbnRBKTpyLnBvaW50QSxcInBpblwiPT09ci5yZW5kZXIudHlwZSluLmJlZ2luUGF0aCgpLG4uYXJjKHMueCxzLnksMywwLDIqTWF0aC5QSSksbi5jbG9zZVBhdGgoKTtlbHNle2lmKGE9ZD9jLmFkZChkLnBvc2l0aW9uLHIucG9pbnRCKTpyLnBvaW50QixuLmJlZ2luUGF0aCgpLG4ubW92ZVRvKHMueCxzLnkpLFwic3ByaW5nXCI9PT1yLnJlbmRlci50eXBlKWZvcih2YXIgdSxwPWMuc3ViKGEscyksZj1jLnBlcnAoYy5ub3JtYWxpc2UocCkpLG09TWF0aC5jZWlsKGkuY2xhbXAoci5sZW5ndGgvNSwxMiwyMCkpLHY9MTt2PG07dis9MSl1PXYlMj09PTA/MTotMSxuLmxpbmVUbyhzLngrcC54Kih2L20pK2YueCp1KjQscy55K3AueSoodi9tKStmLnkqdSo0KTtuLmxpbmVUbyhhLngsYS55KX1yLnJlbmRlci5saW5lV2lkdGgmJihuLmxpbmVXaWR0aD1yLnJlbmRlci5saW5lV2lkdGgsbi5zdHJva2VTdHlsZT1yLnJlbmRlci5zdHJva2VTdHlsZSxuLnN0cm9rZSgpKSxyLnJlbmRlci5hbmNob3JzJiYobi5maWxsU3R5bGU9ci5yZW5kZXIuc3Ryb2tlU3R5bGUsbi5iZWdpblBhdGgoKSxuLmFyYyhzLngscy55LDMsMCwyKk1hdGguUEkpLG4uYXJjKGEueCxhLnksMywwLDIqTWF0aC5QSSksbi5jbG9zZVBhdGgoKSxuLmZpbGwoKSl9fX0sby5ib2R5U2hhZG93cz1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciBvPW4saT0oZS5lbmdpbmUsMCk7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07aWYoci5yZW5kZXIudmlzaWJsZSl7aWYoci5jaXJjbGVSYWRpdXMpby5iZWdpblBhdGgoKSxvLmFyYyhyLnBvc2l0aW9uLngsci5wb3NpdGlvbi55LHIuY2lyY2xlUmFkaXVzLDAsMipNYXRoLlBJKSxvLmNsb3NlUGF0aCgpO2Vsc2V7by5iZWdpblBhdGgoKSxvLm1vdmVUbyhyLnZlcnRpY2VzWzBdLngsci52ZXJ0aWNlc1swXS55KTtmb3IodmFyIHM9MTtzPHIudmVydGljZXMubGVuZ3RoO3MrKylvLmxpbmVUbyhyLnZlcnRpY2VzW3NdLngsci52ZXJ0aWNlc1tzXS55KTtcbm8uY2xvc2VQYXRoKCl9dmFyIGE9ci5wb3NpdGlvbi54LS41KmUub3B0aW9ucy53aWR0aCxsPXIucG9zaXRpb24ueS0uMiplLm9wdGlvbnMuaGVpZ2h0LGM9TWF0aC5hYnMoYSkrTWF0aC5hYnMobCk7by5zaGFkb3dDb2xvcj1cInJnYmEoMCwwLDAsMC4xNSlcIixvLnNoYWRvd09mZnNldFg9LjA1KmEsby5zaGFkb3dPZmZzZXRZPS4wNSpsLG8uc2hhZG93Qmx1cj0xKzEyKk1hdGgubWluKDEsYy8xZTMpLG8uZmlsbCgpLG8uc2hhZG93Q29sb3I9bnVsbCxvLnNoYWRvd09mZnNldFg9bnVsbCxvLnNoYWRvd09mZnNldFk9bnVsbCxvLnNoYWRvd0JsdXI9bnVsbH19fSxvLmJvZGllcz1mdW5jdGlvbihlLHQsbil7dmFyIG8saSxyLHMsYT1uLGw9KGUuZW5naW5lLGUub3B0aW9ucyksYz1sLnNob3dJbnRlcm5hbEVkZ2VzfHwhbC53aXJlZnJhbWVzO2ZvcihyPTA7cjx0Lmxlbmd0aDtyKyspaWYobz10W3JdLG8ucmVuZGVyLnZpc2libGUpZm9yKHM9by5wYXJ0cy5sZW5ndGg+MT8xOjA7czxvLnBhcnRzLmxlbmd0aDtzKyspaWYoaT1vLnBhcnRzW3NdLGkucmVuZGVyLnZpc2libGUpe2lmKGwuc2hvd1NsZWVwaW5nJiZvLmlzU2xlZXBpbmc/YS5nbG9iYWxBbHBoYT0uNSppLnJlbmRlci5vcGFjaXR5OjEhPT1pLnJlbmRlci5vcGFjaXR5JiYoYS5nbG9iYWxBbHBoYT1pLnJlbmRlci5vcGFjaXR5KSxpLnJlbmRlci5zcHJpdGUmJmkucmVuZGVyLnNwcml0ZS50ZXh0dXJlJiYhbC53aXJlZnJhbWVzKXt2YXIgZD1pLnJlbmRlci5zcHJpdGUsdT1wKGUsZC50ZXh0dXJlKTthLnRyYW5zbGF0ZShpLnBvc2l0aW9uLngsaS5wb3NpdGlvbi55KSxhLnJvdGF0ZShpLmFuZ2xlKSxhLmRyYXdJbWFnZSh1LHUud2lkdGgqLWQueE9mZnNldCpkLnhTY2FsZSx1LmhlaWdodCotZC55T2Zmc2V0KmQueVNjYWxlLHUud2lkdGgqZC54U2NhbGUsdS5oZWlnaHQqZC55U2NhbGUpLGEucm90YXRlKC1pLmFuZ2xlKSxhLnRyYW5zbGF0ZSgtaS5wb3NpdGlvbi54LC1pLnBvc2l0aW9uLnkpfWVsc2V7aWYoaS5jaXJjbGVSYWRpdXMpYS5iZWdpblBhdGgoKSxcbmEuYXJjKGkucG9zaXRpb24ueCxpLnBvc2l0aW9uLnksaS5jaXJjbGVSYWRpdXMsMCwyKk1hdGguUEkpO2Vsc2V7YS5iZWdpblBhdGgoKSxhLm1vdmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KTtmb3IodmFyIGY9MTtmPGkudmVydGljZXMubGVuZ3RoO2YrKykhaS52ZXJ0aWNlc1tmLTFdLmlzSW50ZXJuYWx8fGM/YS5saW5lVG8oaS52ZXJ0aWNlc1tmXS54LGkudmVydGljZXNbZl0ueSk6YS5tb3ZlVG8oaS52ZXJ0aWNlc1tmXS54LGkudmVydGljZXNbZl0ueSksaS52ZXJ0aWNlc1tmXS5pc0ludGVybmFsJiYhYyYmYS5tb3ZlVG8oaS52ZXJ0aWNlc1soZisxKSVpLnZlcnRpY2VzLmxlbmd0aF0ueCxpLnZlcnRpY2VzWyhmKzEpJWkudmVydGljZXMubGVuZ3RoXS55KTthLmxpbmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KSxhLmNsb3NlUGF0aCgpfWwud2lyZWZyYW1lcz8oYS5saW5lV2lkdGg9MSxhLnN0cm9rZVN0eWxlPVwiI2JiYlwiLGEuc3Ryb2tlKCkpOihhLmZpbGxTdHlsZT1pLnJlbmRlci5maWxsU3R5bGUsaS5yZW5kZXIubGluZVdpZHRoJiYoYS5saW5lV2lkdGg9aS5yZW5kZXIubGluZVdpZHRoLGEuc3Ryb2tlU3R5bGU9aS5yZW5kZXIuc3Ryb2tlU3R5bGUsYS5zdHJva2UoKSksYS5maWxsKCkpfWEuZ2xvYmFsQWxwaGE9MX19LG8uYm9keVdpcmVmcmFtZXM9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvLGkscixzLGEsbD1uLGM9ZS5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzO2ZvcihsLmJlZ2luUGF0aCgpLHI9MDtyPHQubGVuZ3RoO3IrKylpZihvPXRbcl0sby5yZW5kZXIudmlzaWJsZSlmb3IoYT1vLnBhcnRzLmxlbmd0aD4xPzE6MDthPG8ucGFydHMubGVuZ3RoO2ErKyl7Zm9yKGk9by5wYXJ0c1thXSxsLm1vdmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KSxzPTE7czxpLnZlcnRpY2VzLmxlbmd0aDtzKyspIWkudmVydGljZXNbcy0xXS5pc0ludGVybmFsfHxjP2wubGluZVRvKGkudmVydGljZXNbc10ueCxpLnZlcnRpY2VzW3NdLnkpOmwubW92ZVRvKGkudmVydGljZXNbc10ueCxpLnZlcnRpY2VzW3NdLnkpLFxuaS52ZXJ0aWNlc1tzXS5pc0ludGVybmFsJiYhYyYmbC5tb3ZlVG8oaS52ZXJ0aWNlc1socysxKSVpLnZlcnRpY2VzLmxlbmd0aF0ueCxpLnZlcnRpY2VzWyhzKzEpJWkudmVydGljZXMubGVuZ3RoXS55KTtsLmxpbmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KX1sLmxpbmVXaWR0aD0xLGwuc3Ryb2tlU3R5bGU9XCIjYmJiXCIsbC5zdHJva2UoKX0sby5ib2R5Q29udmV4SHVsbHM9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvLGkscixzPW47Zm9yKHMuYmVnaW5QYXRoKCksaT0wO2k8dC5sZW5ndGg7aSsrKWlmKG89dFtpXSxvLnJlbmRlci52aXNpYmxlJiYxIT09by5wYXJ0cy5sZW5ndGgpe2ZvcihzLm1vdmVUbyhvLnZlcnRpY2VzWzBdLngsby52ZXJ0aWNlc1swXS55KSxyPTE7cjxvLnZlcnRpY2VzLmxlbmd0aDtyKyspcy5saW5lVG8oby52ZXJ0aWNlc1tyXS54LG8udmVydGljZXNbcl0ueSk7cy5saW5lVG8oby52ZXJ0aWNlc1swXS54LG8udmVydGljZXNbMF0ueSl9cy5saW5lV2lkdGg9MSxzLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIscy5zdHJva2UoKX0sby52ZXJ0ZXhOdW1iZXJzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbyxpLHIscz1uO2ZvcihvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBhPXRbb10ucGFydHM7Zm9yKHI9YS5sZW5ndGg+MT8xOjA7cjxhLmxlbmd0aDtyKyspe3ZhciBsPWFbcl07Zm9yKGk9MDtpPGwudmVydGljZXMubGVuZ3RoO2krKylzLmZpbGxTdHlsZT1cInJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLHMuZmlsbFRleHQobytcIl9cIitpLGwucG9zaXRpb24ueCsuOCoobC52ZXJ0aWNlc1tpXS54LWwucG9zaXRpb24ueCksbC5wb3NpdGlvbi55Ky44KihsLnZlcnRpY2VzW2ldLnktbC5wb3NpdGlvbi55KSl9fX0sby5tb3VzZVBvc2l0aW9uPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbz1uO28uZmlsbFN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjgpXCIsby5maWxsVGV4dCh0LnBvc2l0aW9uLngrXCIgIFwiK3QucG9zaXRpb24ueSx0LnBvc2l0aW9uLngrNSx0LnBvc2l0aW9uLnktNSk7XG59LG8uYm9keUJvdW5kcz1mdW5jdGlvbihlLHQsbil7dmFyIG89bixpPShlLmVuZ2luZSxlLm9wdGlvbnMpO28uYmVnaW5QYXRoKCk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPXRbcl07aWYocy5yZW5kZXIudmlzaWJsZSlmb3IodmFyIGE9dFtyXS5wYXJ0cyxsPWEubGVuZ3RoPjE/MTowO2w8YS5sZW5ndGg7bCsrKXt2YXIgYz1hW2xdO28ucmVjdChjLmJvdW5kcy5taW4ueCxjLmJvdW5kcy5taW4ueSxjLmJvdW5kcy5tYXgueC1jLmJvdW5kcy5taW4ueCxjLmJvdW5kcy5tYXgueS1jLmJvdW5kcy5taW4ueSl9fWkud2lyZWZyYW1lcz9vLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjA4KVwiOm8uc3Ryb2tlU3R5bGU9XCJyZ2JhKDAsMCwwLDAuMSlcIixvLmxpbmVXaWR0aD0xLG8uc3Ryb2tlKCl9LG8uYm9keUF4ZXM9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvLGkscixzLGE9bixsPShlLmVuZ2luZSxlLm9wdGlvbnMpO2ZvcihhLmJlZ2luUGF0aCgpLGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIGM9dFtpXSxkPWMucGFydHM7aWYoYy5yZW5kZXIudmlzaWJsZSlpZihsLnNob3dBeGVzKWZvcihyPWQubGVuZ3RoPjE/MTowO3I8ZC5sZW5ndGg7cisrKWZvcihvPWRbcl0scz0wO3M8by5heGVzLmxlbmd0aDtzKyspe3ZhciB1PW8uYXhlc1tzXTthLm1vdmVUbyhvLnBvc2l0aW9uLngsby5wb3NpdGlvbi55KSxhLmxpbmVUbyhvLnBvc2l0aW9uLngrMjAqdS54LG8ucG9zaXRpb24ueSsyMCp1LnkpfWVsc2UgZm9yKHI9ZC5sZW5ndGg+MT8xOjA7cjxkLmxlbmd0aDtyKyspZm9yKG89ZFtyXSxzPTA7czxvLmF4ZXMubGVuZ3RoO3MrKylhLm1vdmVUbyhvLnBvc2l0aW9uLngsby5wb3NpdGlvbi55KSxhLmxpbmVUbygoby52ZXJ0aWNlc1swXS54K28udmVydGljZXNbby52ZXJ0aWNlcy5sZW5ndGgtMV0ueCkvMiwoby52ZXJ0aWNlc1swXS55K28udmVydGljZXNbby52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkvMil9bC53aXJlZnJhbWVzPyhhLnN0cm9rZVN0eWxlPVwiaW5kaWFucmVkXCIsXG5hLmxpbmVXaWR0aD0xKTooYS5zdHJva2VTdHlsZT1cInJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KVwiLGEuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwib3ZlcmxheVwiLGEubGluZVdpZHRoPTIpLGEuc3Ryb2tlKCksYS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2Utb3ZlclwifSxvLmJvZHlQb3NpdGlvbnM9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvLGkscixzLGE9bixsPShlLmVuZ2luZSxlLm9wdGlvbnMpO2ZvcihhLmJlZ2luUGF0aCgpLHI9MDtyPHQubGVuZ3RoO3IrKylpZihvPXRbcl0sby5yZW5kZXIudmlzaWJsZSlmb3Iocz0wO3M8by5wYXJ0cy5sZW5ndGg7cysrKWk9by5wYXJ0c1tzXSxhLmFyYyhpLnBvc2l0aW9uLngsaS5wb3NpdGlvbi55LDMsMCwyKk1hdGguUEksITEpLGEuY2xvc2VQYXRoKCk7Zm9yKGwud2lyZWZyYW1lcz9hLmZpbGxTdHlsZT1cImluZGlhbnJlZFwiOmEuZmlsbFN0eWxlPVwicmdiYSgwLDAsMCwwLjUpXCIsYS5maWxsKCksYS5iZWdpblBhdGgoKSxyPTA7cjx0Lmxlbmd0aDtyKyspbz10W3JdLG8ucmVuZGVyLnZpc2libGUmJihhLmFyYyhvLnBvc2l0aW9uUHJldi54LG8ucG9zaXRpb25QcmV2LnksMiwwLDIqTWF0aC5QSSwhMSksYS5jbG9zZVBhdGgoKSk7YS5maWxsU3R5bGU9XCJyZ2JhKDI1NSwxNjUsMCwwLjgpXCIsYS5maWxsKCl9LG8uYm9keVZlbG9jaXR5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgbz1uO28uYmVnaW5QYXRoKCk7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07ci5yZW5kZXIudmlzaWJsZSYmKG8ubW92ZVRvKHIucG9zaXRpb24ueCxyLnBvc2l0aW9uLnkpLG8ubGluZVRvKHIucG9zaXRpb24ueCsyKihyLnBvc2l0aW9uLngtci5wb3NpdGlvblByZXYueCksci5wb3NpdGlvbi55KzIqKHIucG9zaXRpb24ueS1yLnBvc2l0aW9uUHJldi55KSkpfW8ubGluZVdpZHRoPTMsby5zdHJva2VTdHlsZT1cImNvcm5mbG93ZXJibHVlXCIsby5zdHJva2UoKX0sby5ib2R5SWRzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbyxpLHI9bjtcbmZvcihvPTA7bzx0Lmxlbmd0aDtvKyspaWYodFtvXS5yZW5kZXIudmlzaWJsZSl7dmFyIHM9dFtvXS5wYXJ0cztmb3IoaT1zLmxlbmd0aD4xPzE6MDtpPHMubGVuZ3RoO2krKyl7dmFyIGE9c1tpXTtyLmZvbnQ9XCIxMnB4IEFyaWFsXCIsci5maWxsU3R5bGU9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIixyLmZpbGxUZXh0KGEuaWQsYS5wb3NpdGlvbi54KzEwLGEucG9zaXRpb24ueS0xMCl9fX0sby5jb2xsaXNpb25zPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbyxpLHIscyxhPW4sbD1lLm9wdGlvbnM7Zm9yKGEuYmVnaW5QYXRoKCkscj0wO3I8dC5sZW5ndGg7cisrKWlmKG89dFtyXSxvLmlzQWN0aXZlKWZvcihpPW8uY29sbGlzaW9uLHM9MDtzPG8uYWN0aXZlQ29udGFjdHMubGVuZ3RoO3MrKyl7dmFyIGM9by5hY3RpdmVDb250YWN0c1tzXSxkPWMudmVydGV4O2EucmVjdChkLngtMS41LGQueS0xLjUsMy41LDMuNSl9Zm9yKGwud2lyZWZyYW1lcz9hLmZpbGxTdHlsZT1cInJnYmEoMjU1LDI1NSwyNTUsMC43KVwiOmEuZmlsbFN0eWxlPVwib3JhbmdlXCIsYS5maWxsKCksYS5iZWdpblBhdGgoKSxyPTA7cjx0Lmxlbmd0aDtyKyspaWYobz10W3JdLG8uaXNBY3RpdmUmJihpPW8uY29sbGlzaW9uLG8uYWN0aXZlQ29udGFjdHMubGVuZ3RoPjApKXt2YXIgdT1vLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC54LHA9by5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueTsyPT09by5hY3RpdmVDb250YWN0cy5sZW5ndGgmJih1PShvLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC54K28uYWN0aXZlQ29udGFjdHNbMV0udmVydGV4LngpLzIscD0oby5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueStvLmFjdGl2ZUNvbnRhY3RzWzFdLnZlcnRleC55KS8yKSxpLmJvZHlCPT09aS5zdXBwb3J0c1swXS5ib2R5fHxpLmJvZHlBLmlzU3RhdGljPT09ITA/YS5tb3ZlVG8odS04Kmkubm9ybWFsLngscC04Kmkubm9ybWFsLnkpOmEubW92ZVRvKHUrOCppLm5vcm1hbC54LHArOCppLm5vcm1hbC55KSxhLmxpbmVUbyh1LHApO1xufWwud2lyZWZyYW1lcz9hLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMTY1LDAsMC43KVwiOmEuc3Ryb2tlU3R5bGU9XCJvcmFuZ2VcIixhLmxpbmVXaWR0aD0xLGEuc3Ryb2tlKCl9LG8uc2VwYXJhdGlvbnM9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvLGkscixzLGEsbD1uLGM9ZS5vcHRpb25zO2ZvcihsLmJlZ2luUGF0aCgpLGE9MDthPHQubGVuZ3RoO2ErKylpZihvPXRbYV0sby5pc0FjdGl2ZSl7aT1vLmNvbGxpc2lvbixyPWkuYm9keUEscz1pLmJvZHlCO3ZhciBkPTE7cy5pc1N0YXRpY3x8ci5pc1N0YXRpY3x8KGQ9LjUpLHMuaXNTdGF0aWMmJihkPTApLGwubW92ZVRvKHMucG9zaXRpb24ueCxzLnBvc2l0aW9uLnkpLGwubGluZVRvKHMucG9zaXRpb24ueC1pLnBlbmV0cmF0aW9uLngqZCxzLnBvc2l0aW9uLnktaS5wZW5ldHJhdGlvbi55KmQpLGQ9MSxzLmlzU3RhdGljfHxyLmlzU3RhdGljfHwoZD0uNSksci5pc1N0YXRpYyYmKGQ9MCksbC5tb3ZlVG8oci5wb3NpdGlvbi54LHIucG9zaXRpb24ueSksbC5saW5lVG8oci5wb3NpdGlvbi54K2kucGVuZXRyYXRpb24ueCpkLHIucG9zaXRpb24ueStpLnBlbmV0cmF0aW9uLnkqZCl9Yy53aXJlZnJhbWVzP2wuc3Ryb2tlU3R5bGU9XCJyZ2JhKDI1NSwxNjUsMCwwLjUpXCI6bC5zdHJva2VTdHlsZT1cIm9yYW5nZVwiLGwuc3Ryb2tlKCl9LG8uZ3JpZD1mdW5jdGlvbihlLHQsbil7dmFyIG89bixyPWUub3B0aW9ucztyLndpcmVmcmFtZXM/by5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE4MCwwLDAuMSlcIjpvLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMTgwLDAsMC41KVwiLG8uYmVnaW5QYXRoKCk7Zm9yKHZhciBzPWkua2V5cyh0LmJ1Y2tldHMpLGE9MDthPHMubGVuZ3RoO2ErKyl7dmFyIGw9c1thXTtpZighKHQuYnVja2V0c1tsXS5sZW5ndGg8Mikpe3ZhciBjPWwuc3BsaXQoL0N8Ui8pO28ucmVjdCguNStwYXJzZUludChjWzFdLDEwKSp0LmJ1Y2tldFdpZHRoLC41K3BhcnNlSW50KGNbMl0sMTApKnQuYnVja2V0SGVpZ2h0LHQuYnVja2V0V2lkdGgsdC5idWNrZXRIZWlnaHQpO1xufX1vLmxpbmVXaWR0aD0xLG8uc3Ryb2tlKCl9LG8uaW5zcGVjdG9yPWZ1bmN0aW9uKGUsdCl7dmFyIG4sbz0oZS5lbmdpbmUsZS5zZWxlY3RlZCksaT1lLnJlbmRlcixyPWkub3B0aW9ucztpZihyLmhhc0JvdW5kcyl7dmFyIHM9aS5ib3VuZHMubWF4LngtaS5ib3VuZHMubWluLngsYT1pLmJvdW5kcy5tYXgueS1pLmJvdW5kcy5taW4ueSxsPXMvaS5vcHRpb25zLndpZHRoLGM9YS9pLm9wdGlvbnMuaGVpZ2h0O3Quc2NhbGUoMS9sLDEvYyksdC50cmFuc2xhdGUoLWkuYm91bmRzLm1pbi54LC1pLmJvdW5kcy5taW4ueSl9Zm9yKHZhciBkPTA7ZDxvLmxlbmd0aDtkKyspe3ZhciB1PW9bZF0uZGF0YTtzd2l0Y2godC50cmFuc2xhdGUoLjUsLjUpLHQubGluZVdpZHRoPTEsdC5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE2NSwwLDAuOSlcIix0LnNldExpbmVEYXNoKFsxLDJdKSx1LnR5cGUpe2Nhc2VcImJvZHlcIjpuPXUuYm91bmRzLHQuYmVnaW5QYXRoKCksdC5yZWN0KE1hdGguZmxvb3Iobi5taW4ueC0zKSxNYXRoLmZsb29yKG4ubWluLnktMyksTWF0aC5mbG9vcihuLm1heC54LW4ubWluLngrNiksTWF0aC5mbG9vcihuLm1heC55LW4ubWluLnkrNikpLHQuY2xvc2VQYXRoKCksdC5zdHJva2UoKTticmVhaztjYXNlXCJjb25zdHJhaW50XCI6dmFyIHA9dS5wb2ludEE7dS5ib2R5QSYmKHA9dS5wb2ludEIpLHQuYmVnaW5QYXRoKCksdC5hcmMocC54LHAueSwxMCwwLDIqTWF0aC5QSSksdC5jbG9zZVBhdGgoKSx0LnN0cm9rZSgpfXQuc2V0TGluZURhc2goW10pLHQudHJhbnNsYXRlKC0uNSwtLjUpfW51bGwhPT1lLnNlbGVjdFN0YXJ0JiYodC50cmFuc2xhdGUoLjUsLjUpLHQubGluZVdpZHRoPTEsdC5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE2NSwwLDAuNilcIix0LmZpbGxTdHlsZT1cInJnYmEoMjU1LDE2NSwwLDAuMSlcIixuPWUuc2VsZWN0Qm91bmRzLHQuYmVnaW5QYXRoKCksdC5yZWN0KE1hdGguZmxvb3Iobi5taW4ueCksTWF0aC5mbG9vcihuLm1pbi55KSxNYXRoLmZsb29yKG4ubWF4Lngtbi5taW4ueCksTWF0aC5mbG9vcihuLm1heC55LW4ubWluLnkpKSxcbnQuY2xvc2VQYXRoKCksdC5zdHJva2UoKSx0LmZpbGwoKSx0LnRyYW5zbGF0ZSgtLjUsLS41KSksci5oYXNCb3VuZHMmJnQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKX07dmFyIG49ZnVuY3Rpb24oZSx0KXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3JldHVybiBuLndpZHRoPWUsbi5oZWlnaHQ9dCxuLm9uY29udGV4dG1lbnU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbi5vbnNlbGVjdHN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuITF9LG59LHU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRDb250ZXh0KFwiMmRcIiksbj13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSxvPXQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxO3JldHVybiBuL299LHA9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLnRleHR1cmVzW3RdO3JldHVybiBuP246KG49ZS50ZXh0dXJlc1t0XT1uZXcgSW1hZ2Usbi5zcmM9dCxuKX0sZj1mdW5jdGlvbihlLHQpe3ZhciBuPXQ7LyhqcGd8Z2lmfHBuZykkLy50ZXN0KHQpJiYobj1cInVybChcIit0K1wiKVwiKSxlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kPW4sZS5jYW52YXMuc3R5bGUuYmFja2dyb3VuZFNpemU9XCJjb250YWluXCIsZS5jdXJyZW50QmFja2dyb3VuZD10fX0oKX0se1wiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vY29sbGlzaW9uL0dyaWRcIjo2LFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9jb3JlL01vdXNlXCI6MTksXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4fV0sMzI6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgbz17fTt0LmV4cG9ydHM9bzt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLHI9ZShcIi4uL2JvZHkvQ29tcG9zaXRlXCIpLHM9ZShcIi4uL2NvcmUvQ29tbW9uXCIpLGE9ZShcIi4uL2NvcmUvRXZlbnRzXCIpLGw9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKTtcbiFmdW5jdGlvbigpe3ZhciBlLHQ7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2Uocy5ub3coKSl9LDFlMy82MCl9LHQ9d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUpLG8uY3JlYXRlPWZ1bmN0aW9uKGUpe3Mud2FybihcIlJlbmRlclBpeGkuY3JlYXRlOiBNYXR0ZXIuUmVuZGVyUGl4aSBpcyBkZXByZWNhdGVkIChzZWUgZG9jcylcIik7dmFyIHQ9e2NvbnRyb2xsZXI6byxlbmdpbmU6bnVsbCxlbGVtZW50Om51bGwsZnJhbWVSZXF1ZXN0SWQ6bnVsbCxjYW52YXM6bnVsbCxyZW5kZXJlcjpudWxsLGNvbnRhaW5lcjpudWxsLHNwcml0ZUNvbnRhaW5lcjpudWxsLHBpeGlPcHRpb25zOm51bGwsb3B0aW9uczp7d2lkdGg6ODAwLGhlaWdodDo2MDAsYmFja2dyb3VuZDpcIiNmYWZhZmFcIix3aXJlZnJhbWVCYWNrZ3JvdW5kOlwiIzIyMlwiLGhhc0JvdW5kczohMSxlbmFibGVkOiEwLHdpcmVmcmFtZXM6ITAsc2hvd1NsZWVwaW5nOiEwLHNob3dEZWJ1ZzohMSxzaG93QnJvYWRwaGFzZTohMSxzaG93Qm91bmRzOiExLHNob3dWZWxvY2l0eTohMSxzaG93Q29sbGlzaW9uczohMSxzaG93QXhlczohMSxzaG93UG9zaXRpb25zOiExLHNob3dBbmdsZUluZGljYXRvcjohMSxzaG93SWRzOiExLHNob3dTaGFkb3dzOiExfX0sbj1zLmV4dGVuZCh0LGUpLGk9IW4ub3B0aW9ucy53aXJlZnJhbWVzJiZcInRyYW5zcGFyZW50XCI9PT1uLm9wdGlvbnMuYmFja2dyb3VuZDtyZXR1cm4gbi5waXhpT3B0aW9ucz1uLnBpeGlPcHRpb25zfHx7XG52aWV3Om4uY2FudmFzLHRyYW5zcGFyZW50OmksYW50aWFsaWFzOiEwLGJhY2tncm91bmRDb2xvcjplLmJhY2tncm91bmR9LG4ubW91c2U9ZS5tb3VzZSxuLmVuZ2luZT1lLmVuZ2luZSxuLnJlbmRlcmVyPW4ucmVuZGVyZXJ8fG5ldyBQSVhJLldlYkdMUmVuZGVyZXIobi5vcHRpb25zLndpZHRoLG4ub3B0aW9ucy5oZWlnaHQsbi5waXhpT3B0aW9ucyksbi5jb250YWluZXI9bi5jb250YWluZXJ8fG5ldyBQSVhJLkNvbnRhaW5lcixuLnNwcml0ZUNvbnRhaW5lcj1uLnNwcml0ZUNvbnRhaW5lcnx8bmV3IFBJWEkuQ29udGFpbmVyLG4uY2FudmFzPW4uY2FudmFzfHxuLnJlbmRlcmVyLnZpZXcsbi5ib3VuZHM9bi5ib3VuZHN8fHttaW46e3g6MCx5OjB9LG1heDp7eDpuLm9wdGlvbnMud2lkdGgseTpuLm9wdGlvbnMuaGVpZ2h0fX0sYS5vbihuLmVuZ2luZSxcImJlZm9yZVVwZGF0ZVwiLGZ1bmN0aW9uKCl7by5jbGVhcihuKX0pLG4udGV4dHVyZXM9e30sbi5zcHJpdGVzPXt9LG4ucHJpbWl0aXZlcz17fSxuLmNvbnRhaW5lci5hZGRDaGlsZChuLnNwcml0ZUNvbnRhaW5lcikscy5pc0VsZW1lbnQobi5lbGVtZW50KT9uLmVsZW1lbnQuYXBwZW5kQ2hpbGQobi5jYW52YXMpOnMud2FybignTm8gXCJyZW5kZXIuZWxlbWVudFwiIHBhc3NlZCwgXCJyZW5kZXIuY2FudmFzXCIgd2FzIG5vdCBpbnNlcnRlZCBpbnRvIGRvY3VtZW50LicpLG4uY2FudmFzLm9uY29udGV4dG1lbnU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbi5jYW52YXMub25zZWxlY3RzdGFydD1mdW5jdGlvbigpe3JldHVybiExfSxufSxvLnJ1bj1mdW5jdGlvbih0KXshZnVuY3Rpb24gbihpKXt0LmZyYW1lUmVxdWVzdElkPWUobiksby53b3JsZCh0KX0oKX0sby5zdG9wPWZ1bmN0aW9uKGUpe3QoZS5mcmFtZVJlcXVlc3RJZCl9LG8uY2xlYXI9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuY29udGFpbmVyLG49ZS5zcHJpdGVDb250YWluZXI7dC5jaGlsZHJlblswXTspdC5yZW1vdmVDaGlsZCh0LmNoaWxkcmVuWzBdKTtmb3IoO24uY2hpbGRyZW5bMF07KW4ucmVtb3ZlQ2hpbGQobi5jaGlsZHJlblswXSk7XG52YXIgbz1lLnNwcml0ZXNbXCJiZy0wXCJdO2UudGV4dHVyZXM9e30sZS5zcHJpdGVzPXt9LGUucHJpbWl0aXZlcz17fSxlLnNwcml0ZXNbXCJiZy0wXCJdPW8sbyYmdC5hZGRDaGlsZEF0KG8sMCksZS5jb250YWluZXIuYWRkQ2hpbGQoZS5zcHJpdGVDb250YWluZXIpLGUuY3VycmVudEJhY2tncm91bmQ9bnVsbCx0LnNjYWxlLnNldCgxLDEpLHQucG9zaXRpb24uc2V0KDAsMCl9LG8uc2V0QmFja2dyb3VuZD1mdW5jdGlvbihlLHQpe2lmKGUuY3VycmVudEJhY2tncm91bmQhPT10KXt2YXIgbj10LmluZGV4T2YmJnQuaW5kZXhPZihcIiNcIikhPT0tMSxvPWUuc3ByaXRlc1tcImJnLTBcIl07aWYobil7dmFyIGk9cy5jb2xvclRvTnVtYmVyKHQpO2UucmVuZGVyZXIuYmFja2dyb3VuZENvbG9yPWksbyYmZS5jb250YWluZXIucmVtb3ZlQ2hpbGQobyl9ZWxzZSBpZighbyl7dmFyIHI9ZChlLHQpO289ZS5zcHJpdGVzW1wiYmctMFwiXT1uZXcgUElYSS5TcHJpdGUociksby5wb3NpdGlvbi54PTAsby5wb3NpdGlvbi55PTAsZS5jb250YWluZXIuYWRkQ2hpbGRBdChvLDApfWUuY3VycmVudEJhY2tncm91bmQ9dH19LG8ud29ybGQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1lLmVuZ2luZSxzPW4ud29ybGQsYT1lLnJlbmRlcmVyLGM9ZS5jb250YWluZXIsZD1lLm9wdGlvbnMsdT1yLmFsbEJvZGllcyhzKSxwPXIuYWxsQ29uc3RyYWludHMocyksZj1bXTtkLndpcmVmcmFtZXM/by5zZXRCYWNrZ3JvdW5kKGUsZC53aXJlZnJhbWVCYWNrZ3JvdW5kKTpvLnNldEJhY2tncm91bmQoZSxkLmJhY2tncm91bmQpO3ZhciBtPWUuYm91bmRzLm1heC54LWUuYm91bmRzLm1pbi54LHY9ZS5ib3VuZHMubWF4LnktZS5ib3VuZHMubWluLnkseT1tL2Uub3B0aW9ucy53aWR0aCxnPXYvZS5vcHRpb25zLmhlaWdodDtpZihkLmhhc0JvdW5kcyl7Zm9yKHQ9MDt0PHUubGVuZ3RoO3QrKyl7dmFyIHg9dVt0XTt4LnJlbmRlci5zcHJpdGUudmlzaWJsZT1pLm92ZXJsYXBzKHguYm91bmRzLGUuYm91bmRzKX1mb3IodD0wO3Q8cC5sZW5ndGg7dCsrKXtcbnZhciBoPXBbdF0sYj1oLmJvZHlBLHc9aC5ib2R5QixTPWgucG9pbnRBLEM9aC5wb2ludEI7YiYmKFM9bC5hZGQoYi5wb3NpdGlvbixoLnBvaW50QSkpLHcmJihDPWwuYWRkKHcucG9zaXRpb24saC5wb2ludEIpKSxTJiZDJiYoaS5jb250YWlucyhlLmJvdW5kcyxTKXx8aS5jb250YWlucyhlLmJvdW5kcyxDKSkmJmYucHVzaChoKX1jLnNjYWxlLnNldCgxL3ksMS9nKSxjLnBvc2l0aW9uLnNldCgtZS5ib3VuZHMubWluLngqKDEveSksLWUuYm91bmRzLm1pbi55KigxL2cpKX1lbHNlIGY9cDtmb3IodD0wO3Q8dS5sZW5ndGg7dCsrKW8uYm9keShlLHVbdF0pO2Zvcih0PTA7dDxmLmxlbmd0aDt0Kyspby5jb25zdHJhaW50KGUsZlt0XSk7YS5yZW5kZXIoYyl9LG8uY29uc3RyYWludD1mdW5jdGlvbihlLHQpe3ZhciBuPShlLmVuZ2luZSx0LmJvZHlBKSxvPXQuYm9keUIsaT10LnBvaW50QSxyPXQucG9pbnRCLGE9ZS5jb250YWluZXIsbD10LnJlbmRlcixjPVwiYy1cIit0LmlkLGQ9ZS5wcmltaXRpdmVzW2NdO3JldHVybiBkfHwoZD1lLnByaW1pdGl2ZXNbY109bmV3IFBJWEkuR3JhcGhpY3MpLGwudmlzaWJsZSYmdC5wb2ludEEmJnQucG9pbnRCPyhzLmluZGV4T2YoYS5jaGlsZHJlbixkKT09PS0xJiZhLmFkZENoaWxkKGQpLGQuY2xlYXIoKSxkLmJlZ2luRmlsbCgwLDApLGQubGluZVN0eWxlKGwubGluZVdpZHRoLHMuY29sb3JUb051bWJlcihsLnN0cm9rZVN0eWxlKSwxKSxuP2QubW92ZVRvKG4ucG9zaXRpb24ueCtpLngsbi5wb3NpdGlvbi55K2kueSk6ZC5tb3ZlVG8oaS54LGkueSksbz9kLmxpbmVUbyhvLnBvc2l0aW9uLngrci54LG8ucG9zaXRpb24ueStyLnkpOmQubGluZVRvKHIueCxyLnkpLHZvaWQgZC5lbmRGaWxsKCkpOnZvaWQgZC5jbGVhcigpfSxvLmJvZHk9ZnVuY3Rpb24oZSx0KXt2YXIgbz0oZS5lbmdpbmUsdC5yZW5kZXIpO2lmKG8udmlzaWJsZSlpZihvLnNwcml0ZSYmby5zcHJpdGUudGV4dHVyZSl7dmFyIGk9XCJiLVwiK3QuaWQscj1lLnNwcml0ZXNbaV0sYT1lLnNwcml0ZUNvbnRhaW5lcjtcbnJ8fChyPWUuc3ByaXRlc1tpXT1uKGUsdCkpLHMuaW5kZXhPZihhLmNoaWxkcmVuLHIpPT09LTEmJmEuYWRkQ2hpbGQociksci5wb3NpdGlvbi54PXQucG9zaXRpb24ueCxyLnBvc2l0aW9uLnk9dC5wb3NpdGlvbi55LHIucm90YXRpb249dC5hbmdsZSxyLnNjYWxlLng9by5zcHJpdGUueFNjYWxlfHwxLHIuc2NhbGUueT1vLnNwcml0ZS55U2NhbGV8fDF9ZWxzZXt2YXIgbD1cImItXCIrdC5pZCxkPWUucHJpbWl0aXZlc1tsXSx1PWUuY29udGFpbmVyO2R8fChkPWUucHJpbWl0aXZlc1tsXT1jKGUsdCksZC5pbml0aWFsQW5nbGU9dC5hbmdsZSkscy5pbmRleE9mKHUuY2hpbGRyZW4sZCk9PT0tMSYmdS5hZGRDaGlsZChkKSxkLnBvc2l0aW9uLng9dC5wb3NpdGlvbi54LGQucG9zaXRpb24ueT10LnBvc2l0aW9uLnksZC5yb3RhdGlvbj10LmFuZ2xlLWQuaW5pdGlhbEFuZ2xlfX07dmFyIG49ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnJlbmRlcixvPW4uc3ByaXRlLnRleHR1cmUsaT1kKGUsbykscj1uZXcgUElYSS5TcHJpdGUoaSk7cmV0dXJuIHIuYW5jaG9yLng9dC5yZW5kZXIuc3ByaXRlLnhPZmZzZXQsci5hbmNob3IueT10LnJlbmRlci5zcHJpdGUueU9mZnNldCxyfSxjPWZ1bmN0aW9uKGUsdCl7dmFyIG4sbz10LnJlbmRlcixpPWUub3B0aW9ucyxyPW5ldyBQSVhJLkdyYXBoaWNzLGE9cy5jb2xvclRvTnVtYmVyKG8uZmlsbFN0eWxlKSxsPXMuY29sb3JUb051bWJlcihvLnN0cm9rZVN0eWxlKSxjPXMuY29sb3JUb051bWJlcihvLnN0cm9rZVN0eWxlKSxkPXMuY29sb3JUb051bWJlcihcIiNiYmJcIiksdT1zLmNvbG9yVG9OdW1iZXIoXCIjQ0Q1QzVDXCIpO3IuY2xlYXIoKTtmb3IodmFyIHA9dC5wYXJ0cy5sZW5ndGg+MT8xOjA7cDx0LnBhcnRzLmxlbmd0aDtwKyspe249dC5wYXJ0c1twXSxpLndpcmVmcmFtZXM/KHIuYmVnaW5GaWxsKDAsMCksci5saW5lU3R5bGUoMSxkLDEpKTooci5iZWdpbkZpbGwoYSwxKSxyLmxpbmVTdHlsZShvLmxpbmVXaWR0aCxsLDEpKSxyLm1vdmVUbyhuLnZlcnRpY2VzWzBdLngtdC5wb3NpdGlvbi54LG4udmVydGljZXNbMF0ueS10LnBvc2l0aW9uLnkpO1xuZm9yKHZhciBmPTE7ZjxuLnZlcnRpY2VzLmxlbmd0aDtmKyspci5saW5lVG8obi52ZXJ0aWNlc1tmXS54LXQucG9zaXRpb24ueCxuLnZlcnRpY2VzW2ZdLnktdC5wb3NpdGlvbi55KTtyLmxpbmVUbyhuLnZlcnRpY2VzWzBdLngtdC5wb3NpdGlvbi54LG4udmVydGljZXNbMF0ueS10LnBvc2l0aW9uLnkpLHIuZW5kRmlsbCgpLChpLnNob3dBbmdsZUluZGljYXRvcnx8aS5zaG93QXhlcykmJihyLmJlZ2luRmlsbCgwLDApLGkud2lyZWZyYW1lcz9yLmxpbmVTdHlsZSgxLHUsMSk6ci5saW5lU3R5bGUoMSxjKSxyLm1vdmVUbyhuLnBvc2l0aW9uLngtdC5wb3NpdGlvbi54LG4ucG9zaXRpb24ueS10LnBvc2l0aW9uLnkpLHIubGluZVRvKChuLnZlcnRpY2VzWzBdLngrbi52ZXJ0aWNlc1tuLnZlcnRpY2VzLmxlbmd0aC0xXS54KS8yLXQucG9zaXRpb24ueCwobi52ZXJ0aWNlc1swXS55K24udmVydGljZXNbbi52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkvMi10LnBvc2l0aW9uLnkpLHIuZW5kRmlsbCgpKX1yZXR1cm4gcn0sZD1mdW5jdGlvbihlLHQpe3ZhciBuPWUudGV4dHVyZXNbdF07cmV0dXJuIG58fChuPWUudGV4dHVyZXNbdF09UElYSS5UZXh0dXJlLmZyb21JbWFnZSh0KSksbn19KCl9LHtcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9jb3JlL0V2ZW50c1wiOjE2LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOH1dfSx7fSxbMzBdKSgzMCl9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NsaWVudC9hcHAvbGlicy9tYXR0ZXIubWluLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///415\n");

/***/ })

});