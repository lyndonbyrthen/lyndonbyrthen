webpackJsonp([1],{

/***/ 413:
/*!************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./src/client/app/subapps/App2.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ 2);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _matter = __webpack_require__(/*! ../libs/matter.min */ 415);\n\nvar _matter2 = _interopRequireDefault(_matter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar App2 = function (_React$Component) {\n    _inherits(App2, _React$Component);\n\n    function App2(props) {\n        _classCallCheck(this, App2);\n\n        var _this = _possibleConstructorReturn(this, (App2.__proto__ || Object.getPrototypeOf(App2)).call(this, props));\n\n        console.log(_matter2.default);\n        _this.airFriction = _this.airFriction.bind(_this);\n\n        return _this;\n    }\n\n    _createClass(App2, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            if (this.af) return;\n            try {\n                this.af = this.airFriction();\n            } catch (e) {\n                console.log(e, 'af error');\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.af.stop();\n        }\n    }, {\n        key: 'airFriction',\n        value: function airFriction() {\n            var Engine = _matter2.default.Engine,\n                Render = _matter2.default.Render,\n                Runner = _matter2.default.Runner,\n                MouseConstraint = _matter2.default.MouseConstraint,\n                Mouse = _matter2.default.Mouse,\n                World = _matter2.default.World,\n                Bodies = _matter2.default.Bodies;\n\n            // create engine\n            var engine = Engine.create(),\n                world = engine.world;\n\n            // create renderer\n            var render = Render.create({\n                //element: document.body,\n                element: this.refs.canvas,\n\n                engine: engine,\n                options: {\n                    width: 800,\n                    height: 600,\n                    showVelocity: true\n                }\n            });\n\n            Render.run(render);\n\n            // create runner\n            var runner = Runner.create();\n            Runner.run(runner, engine);\n\n            // add bodies\n            World.add(world, [\n            // falling blocks\n            Bodies.rectangle(200, 100, 60, 60, { frictionAir: 0.001 }), Bodies.rectangle(400, 100, 60, 60, { frictionAir: 0.05 }), Bodies.rectangle(600, 100, 60, 60, { frictionAir: 0.1 }),\n\n            // walls\n            Bodies.rectangle(400, 0, 800, 50, { isStatic: true }), Bodies.rectangle(400, 600, 800, 50, { isStatic: true }), Bodies.rectangle(800, 300, 50, 600, { isStatic: true }), Bodies.rectangle(0, 300, 50, 600, { isStatic: true })]);\n\n            // add mouse control\n            var mouse = Mouse.create(render.canvas),\n                mouseConstraint = MouseConstraint.create(engine, {\n                mouse: mouse,\n                constraint: {\n                    stiffness: 0.2,\n                    render: {\n                        visible: false\n                    }\n                }\n            });\n\n            World.add(world, mouseConstraint);\n\n            // keep the mouse in sync with rendering\n            render.mouse = mouse;\n\n            console.log('Render', Render);\n\n            // fit the render viewport to the scene\n            /*Render.lookAt(render, {\r\n            \tmin: { x: 0, y: 0 },\r\n            \tmax: { x: 800, y: 600 }\r\n            });*/\n\n            // context for MatterTools.Demo\n            return {\n                engine: engine,\n                runner: runner,\n                render: render,\n                canvas: render.canvas,\n                stop: function stop() {\n                    _matter2.default.Render.stop(render);\n                    _matter2.default.Runner.stop(runner);\n                }\n            };\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n\n            return _react2.default.createElement('div', { ref: 'canvas' });\n        }\n    }]);\n\n    return App2;\n}(_react2.default.Component);\n\nexports.default = App2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jbGllbnQvYXBwL3N1YmFwcHMvQXBwMi5qcz81YzZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xyXG5pbXBvcnQgTWF0dGVyIGZyb20gJy4uL2xpYnMvbWF0dGVyLm1pbidcclxuXHJcbmNsYXNzIEFwcDIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIFxyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgXHRjb25zb2xlLmxvZyhNYXR0ZXIpO1xyXG4gIFx0dGhpcy5haXJGcmljdGlvbiA9IHRoaXMuYWlyRnJpY3Rpb24uYmluZCh0aGlzKTtcclxuXHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICBcdGlmICh0aGlzLmFmKSByZXR1cm47XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR0aGlzLmFmID0gdGhpcy5haXJGcmljdGlvbigpO1xyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRjb25zb2xlLmxvZyhlLCdhZiBlcnJvcicpXHJcbiAgXHR9XHJcbiAgXHRcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gIFx0dGhpcy5hZi5zdG9wKCk7XHJcbiAgfVxyXG5cclxuICBhaXJGcmljdGlvbigpIHtcclxuICBcdHZhciBFbmdpbmUgPSBNYXR0ZXIuRW5naW5lLFxyXG4gIFx0UmVuZGVyID0gTWF0dGVyLlJlbmRlcixcclxuICBcdFJ1bm5lciA9IE1hdHRlci5SdW5uZXIsXHJcbiAgXHRNb3VzZUNvbnN0cmFpbnQgPSBNYXR0ZXIuTW91c2VDb25zdHJhaW50LFxyXG4gIFx0TW91c2UgPSBNYXR0ZXIuTW91c2UsXHJcbiAgXHRXb3JsZCA9IE1hdHRlci5Xb3JsZCxcclxuICBcdEJvZGllcyA9IE1hdHRlci5Cb2RpZXM7XHJcblxyXG4gICAgLy8gY3JlYXRlIGVuZ2luZVxyXG4gICAgdmFyIGVuZ2luZSA9IEVuZ2luZS5jcmVhdGUoKSxcclxuICAgIHdvcmxkID0gZW5naW5lLndvcmxkO1xyXG5cclxuICAgIC8vIGNyZWF0ZSByZW5kZXJlclxyXG4gICAgdmFyIHJlbmRlciA9IFJlbmRlci5jcmVhdGUoe1xyXG4gICAgXHQvL2VsZW1lbnQ6IGRvY3VtZW50LmJvZHksXHJcbiAgICBcdGVsZW1lbnQ6IHRoaXMucmVmcy5jYW52YXMsXHJcblxyXG4gICAgXHRlbmdpbmU6IGVuZ2luZSxcclxuICAgIFx0b3B0aW9uczoge1xyXG4gICAgXHRcdHdpZHRoOiA4MDAsXHJcbiAgICBcdFx0aGVpZ2h0OiA2MDAsXHJcbiAgICBcdFx0c2hvd1ZlbG9jaXR5OiB0cnVlXHJcbiAgICBcdH1cclxuICAgIH0pO1xyXG5cclxuICAgIFJlbmRlci5ydW4ocmVuZGVyKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgcnVubmVyXHJcbiAgICB2YXIgcnVubmVyID0gUnVubmVyLmNyZWF0ZSgpO1xyXG4gICAgUnVubmVyLnJ1bihydW5uZXIsIGVuZ2luZSk7XHJcblxyXG4gICAgLy8gYWRkIGJvZGllc1xyXG4gICAgV29ybGQuYWRkKHdvcmxkLCBbXHJcbiAgICAgICAgLy8gZmFsbGluZyBibG9ja3NcclxuICAgICAgICBCb2RpZXMucmVjdGFuZ2xlKDIwMCwgMTAwLCA2MCwgNjAsIHsgZnJpY3Rpb25BaXI6IDAuMDAxIH0pLFxyXG4gICAgICAgIEJvZGllcy5yZWN0YW5nbGUoNDAwLCAxMDAsIDYwLCA2MCwgeyBmcmljdGlvbkFpcjogMC4wNSB9KSxcclxuICAgICAgICBCb2RpZXMucmVjdGFuZ2xlKDYwMCwgMTAwLCA2MCwgNjAsIHsgZnJpY3Rpb25BaXI6IDAuMSB9KSxcclxuXHJcbiAgICAgICAgLy8gd2FsbHNcclxuICAgICAgICBCb2RpZXMucmVjdGFuZ2xlKDQwMCwgMCwgODAwLCA1MCwgeyBpc1N0YXRpYzogdHJ1ZSB9KSxcclxuICAgICAgICBCb2RpZXMucmVjdGFuZ2xlKDQwMCwgNjAwLCA4MDAsIDUwLCB7IGlzU3RhdGljOiB0cnVlIH0pLFxyXG4gICAgICAgIEJvZGllcy5yZWN0YW5nbGUoODAwLCAzMDAsIDUwLCA2MDAsIHsgaXNTdGF0aWM6IHRydWUgfSksXHJcbiAgICAgICAgQm9kaWVzLnJlY3RhbmdsZSgwLCAzMDAsIDUwLCA2MDAsIHsgaXNTdGF0aWM6IHRydWUgfSlcclxuICAgICAgICBdKTtcclxuXHJcbiAgICAvLyBhZGQgbW91c2UgY29udHJvbFxyXG4gICAgdmFyIG1vdXNlID0gTW91c2UuY3JlYXRlKHJlbmRlci5jYW52YXMpLFxyXG4gICAgbW91c2VDb25zdHJhaW50ID0gTW91c2VDb25zdHJhaW50LmNyZWF0ZShlbmdpbmUsIHtcclxuICAgIFx0bW91c2U6IG1vdXNlLFxyXG4gICAgXHRjb25zdHJhaW50OiB7XHJcbiAgICBcdFx0c3RpZmZuZXNzOiAwLjIsXHJcbiAgICBcdFx0cmVuZGVyOiB7XHJcbiAgICBcdFx0XHR2aXNpYmxlOiBmYWxzZVxyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgfSk7XHJcblxyXG4gICAgV29ybGQuYWRkKHdvcmxkLCBtb3VzZUNvbnN0cmFpbnQpO1xyXG5cclxuICAgIC8vIGtlZXAgdGhlIG1vdXNlIGluIHN5bmMgd2l0aCByZW5kZXJpbmdcclxuICAgIHJlbmRlci5tb3VzZSA9IG1vdXNlO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdSZW5kZXInLFJlbmRlcilcclxuXHJcbiAgICAvLyBmaXQgdGhlIHJlbmRlciB2aWV3cG9ydCB0byB0aGUgc2NlbmVcclxuICAgIC8qUmVuZGVyLmxvb2tBdChyZW5kZXIsIHtcclxuICAgIFx0bWluOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgIFx0bWF4OiB7IHg6IDgwMCwgeTogNjAwIH1cclxuICAgIH0pOyovXHJcblxyXG4gICAgLy8gY29udGV4dCBmb3IgTWF0dGVyVG9vbHMuRGVtb1xyXG4gICAgcmV0dXJuIHtcclxuICAgIFx0ZW5naW5lOiBlbmdpbmUsXHJcbiAgICBcdHJ1bm5lcjogcnVubmVyLFxyXG4gICAgXHRyZW5kZXI6IHJlbmRlcixcclxuICAgIFx0Y2FudmFzOiByZW5kZXIuY2FudmFzLFxyXG4gICAgXHRzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgIFx0XHRNYXR0ZXIuUmVuZGVyLnN0b3AocmVuZGVyKTtcclxuICAgIFx0XHRNYXR0ZXIuUnVubmVyLnN0b3AocnVubmVyKTtcclxuICAgIFx0fVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICByZW5kZXIoKSB7XHJcblxyXG4gIFx0cmV0dXJuIChcclxuICBcdFx0PGRpdiByZWY9J2NhbnZhcyc+XHJcbiAgXHRcdCAgXHJcblxyXG4gIFx0XHQ8L2Rpdj5cclxuICBcdClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFwcDI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jbGllbnQvYXBwL3N1YmFwcHMvQXBwMi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUxBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFGQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTs7O0FBRUE7QUFDQTtBQUNBO0FBTUE7Ozs7QUFuSEE7QUFDQTtBQXFIQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///413\n");

/***/ }),

/***/ 415:
/*!*******************************************!*\
  !*** ./src/client/app/libs/matter.min.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* matter-js 0.10.0 by @liabru 2016-05-01\n* http://brm.io/matter-js/\n* License MIT\n*/\n!function (e) {\n  if (\"object\" == ( false ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {\n    var t;t = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, t.Matter = e();\n  }\n}(function () {\n  return function e(t, o, n) {\n    function i(s, a) {\n      if (!o[s]) {\n        if (!t[s]) {\n          var l = \"function\" == typeof require && require;if (!a && l) return require(s, !0);if (r) return r(s, !0);var c = new Error(\"Cannot find module '\" + s + \"'\");throw c.code = \"MODULE_NOT_FOUND\", c;\n        }var d = o[s] = { exports: {} };t[s][0].call(d.exports, function (e) {\n          var o = t[s][1][e];return i(o ? o : e);\n        }, d, d.exports, e, t, o, n);\n      }return o[s].exports;\n    }for (var r = \"function\" == typeof require && require, s = 0; s < n.length; s++) {\n      i(n[s]);\n    }return i;\n  }({ 1: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Sleeping\"),\n          a = (e(\"../render/Render\"), e(\"../core/Common\")),\n          l = e(\"../geometry/Bounds\"),\n          c = e(\"../geometry/Axes\");!function () {\n        n._inertiaScale = 4, n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, n.create = function (t) {\n          var o = { id: a.nextId(), type: \"body\", label: \"Body\", parts: [], angle: 0, vertices: i.fromPath(\"L 0 0 L 40 0 L 40 40 L 0 40\"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 }, lineWidth: 1.5 } },\n              n = a.extend(o, t);return e(n, t), n;\n        }, n.nextGroup = function (e) {\n          return e ? n._nextNonCollidingGroupId-- : n._nextCollidingGroupId++;\n        }, n.nextCategory = function () {\n          return n._nextCategory = n._nextCategory << 1, n._nextCategory;\n        };var e = function e(_e, t) {\n          n.set(_e, { bounds: _e.bounds || l.create(_e.vertices), positionPrev: _e.positionPrev || r.clone(_e.position), anglePrev: _e.anglePrev || _e.angle,\n            vertices: _e.vertices, parts: _e.parts || [_e], isStatic: _e.isStatic, isSleeping: _e.isSleeping, parent: _e.parent || _e }), i.rotate(_e.vertices, _e.angle, _e.position), c.rotate(_e.axes, _e.angle), l.update(_e.bounds, _e.vertices, _e.velocity), n.set(_e, { axes: t.axes || _e.axes, area: t.area || _e.area, mass: t.mass || _e.mass, inertia: t.inertia || _e.inertia });var o = _e.isStatic ? \"#eeeeee\" : a.choose([\"#556270\", \"#4ECDC4\", \"#C7F464\", \"#FF6B6B\", \"#C44D58\"]),\n              s = a.shadeColor(o, -20);_e.render.fillStyle = _e.render.fillStyle || o, _e.render.strokeStyle = _e.render.strokeStyle || s, _e.render.sprite.xOffset += -(_e.bounds.min.x - _e.position.x) / (_e.bounds.max.x - _e.bounds.min.x), _e.render.sprite.yOffset += -(_e.bounds.min.y - _e.position.y) / (_e.bounds.max.y - _e.bounds.min.y);\n        };n.set = function (e, t, o) {\n          var i;\"string\" == typeof t && (i = t, t = {}, t[i] = o);for (i in t) {\n            if (o = t[i], t.hasOwnProperty(i)) switch (i) {case \"isStatic\":\n                n.setStatic(e, o);break;case \"isSleeping\":\n                s.set(e, o);break;case \"mass\":\n                n.setMass(e, o);break;case \"density\":\n                n.setDensity(e, o);break;case \"inertia\":\n                n.setInertia(e, o);break;case \"vertices\":\n                n.setVertices(e, o);\n                break;case \"position\":\n                n.setPosition(e, o);break;case \"angle\":\n                n.setAngle(e, o);break;case \"velocity\":\n                n.setVelocity(e, o);break;case \"angularVelocity\":\n                n.setAngularVelocity(e, o);break;case \"parts\":\n                n.setParts(e, o);break;default:\n                e[i] = o;}\n          }\n        }, n.setStatic = function (e, t) {\n          for (var o = 0; o < e.parts.length; o++) {\n            var n = e.parts[o];n.isStatic = t, t && (n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0);\n          }\n        }, n.setMass = function (e, t) {\n          e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area;\n        }, n.setDensity = function (e, t) {\n          n.setMass(e, t * e.area), e.density = t;\n        }, n.setInertia = function (e, t) {\n          e.inertia = t, e.inverseInertia = 1 / e.inertia;\n        }, n.setVertices = function (e, t) {\n          t[0].body === e ? e.vertices = t : e.vertices = i.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = i.area(e.vertices), n.setMass(e, e.density * e.area);var o = i.centre(e.vertices);i.translate(e.vertices, o, -1), n.setInertia(e, n._inertiaScale * i.inertia(e.vertices, e.mass)), i.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity);\n        }, n.setParts = function (e, o, r) {\n          var s;for (o = o.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, s = 0; s < o.length; s++) {\n            var a = o[s];a !== e && (a.parent = e, e.parts.push(a));\n          }if (1 !== e.parts.length) {\n            if (r = \"undefined\" != typeof r ? r : !0) {\n              var l = [];for (s = 0; s < o.length; s++) {\n                l = l.concat(o[s].vertices);\n              }i.clockwiseSort(l);var c = i.hull(l),\n                  d = i.centre(c);n.setVertices(e, c), i.translate(e.vertices, d);\n            }var u = t(e);e.area = u.area, e.parent = e, e.position.x = u.centre.x, e.position.y = u.centre.y, e.positionPrev.x = u.centre.x, e.positionPrev.y = u.centre.y, n.setMass(e, u.mass), n.setInertia(e, u.inertia), n.setPosition(e, u.centre);\n          }\n        }, n.setPosition = function (e, t) {\n          var o = r.sub(t, e.position);e.positionPrev.x += o.x, e.positionPrev.y += o.y;for (var n = 0; n < e.parts.length; n++) {\n            var s = e.parts[n];s.position.x += o.x, s.position.y += o.y, i.translate(s.vertices, o), l.update(s.bounds, s.vertices, e.velocity);\n          }\n        }, n.setAngle = function (e, t) {\n          var o = t - e.angle;e.anglePrev += o;for (var n = 0; n < e.parts.length; n++) {\n            var s = e.parts[n];s.angle += o, i.rotate(s.vertices, o, e.position), c.rotate(s.axes, o), l.update(s.bounds, s.vertices, e.velocity), n > 0 && r.rotateAbout(s.position, o, e.position, s.position);\n          }\n        }, n.setVelocity = function (e, t) {\n          e.positionPrev.x = e.position.x - t.x, e.positionPrev.y = e.position.y - t.y, e.velocity.x = t.x, e.velocity.y = t.y, e.speed = r.magnitude(e.velocity);\n        }, n.setAngularVelocity = function (e, t) {\n          e.anglePrev = e.angle - t, e.angularVelocity = t, e.angularSpeed = Math.abs(e.angularVelocity);\n        }, n.translate = function (e, t) {\n          n.setPosition(e, r.add(e.position, t));\n        }, n.rotate = function (e, t) {\n          n.setAngle(e, e.angle + t);\n        }, n.scale = function (e, o, r, s) {\n          for (var a = 0; a < e.parts.length; a++) {\n            var d = e.parts[a];i.scale(d.vertices, o, r, e.position), d.axes = c.fromVertices(d.vertices), e.isStatic || (d.area = i.area(d.vertices), n.setMass(d, e.density * d.area), i.translate(d.vertices, { x: -d.position.x, y: -d.position.y }), n.setInertia(d, i.inertia(d.vertices, d.mass)), i.translate(d.vertices, { x: d.position.x, y: d.position.y })), l.update(d.bounds, d.vertices, e.velocity);\n          }if (e.circleRadius && (o === r ? e.circleRadius *= o : e.circleRadius = null), !e.isStatic) {\n            var u = t(e);e.area = u.area, n.setMass(e, u.mass), n.setInertia(e, u.inertia);\n          }\n        }, n.update = function (e, t, o, n) {\n          var s = Math.pow(t * o * e.timeScale, 2),\n              a = 1 - e.frictionAir * o * e.timeScale,\n              d = e.position.x - e.positionPrev.x,\n              u = e.position.y - e.positionPrev.y;e.velocity.x = d * a * n + e.force.x / e.mass * s, e.velocity.y = u * a * n + e.force.y / e.mass * s, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.angularVelocity = (e.angle - e.anglePrev) * a * n + e.torque / e.inertia * s, e.anglePrev = e.angle, e.angle += e.angularVelocity, e.speed = r.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity);for (var p = 0; p < e.parts.length; p++) {\n            var f = e.parts[p];i.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (i.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && r.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity);\n          }\n        }, n.applyForce = function (e, t, o) {\n          e.force.x += o.x, e.force.y += o.y;var n = { x: t.x - e.position.x, y: t.y - e.position.y };e.torque += n.x * o.y - n.y * o.x;\n        };var t = function t(e) {\n          for (var t = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, o = 1 === e.parts.length ? 0 : 1; o < e.parts.length; o++) {\n            var n = e.parts[o];t.mass += n.mass, t.area += n.area, t.inertia += n.inertia, t.centre = r.add(t.centre, r.mult(n.position, n.mass !== 1 / 0 ? n.mass : 1));\n          }return t.centre = r.div(t.centre, t.mass !== 1 / 0 ? t.mass : e.parts.length), t;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Sleeping\": 20, \"../geometry/Axes\": 23, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27, \"../render/Render\": 29 }], 2: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../core/Events\"),\n          r = e(\"../core/Common\"),\n          s = e(\"./Body\");!function () {\n        n.create = function (e) {\n          return r.extend({ id: r.nextId(), type: \"composite\", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: \"Composite\" }, e);\n        }, n.setModified = function (e, t, o, i) {\n          if (e.isModified = t, o && e.parent && n.setModified(e.parent, t, o, i), i) for (var r = 0; r < e.composites.length; r++) {\n            var s = e.composites[r];\n            n.setModified(s, t, o, i);\n          }\n        }, n.add = function (e, t) {\n          var o = [].concat(t);i.trigger(e, \"beforeAdd\", { object: t });for (var s = 0; s < o.length; s++) {\n            var a = o[s];switch (a.type) {case \"body\":\n                if (a.parent !== a) {\n                  r.log(\"Composite.add: skipped adding a compound body part (you must add its parent instead)\", \"warn\");break;\n                }n.addBody(e, a);break;case \"constraint\":\n                n.addConstraint(e, a);break;case \"composite\":\n                n.addComposite(e, a);break;case \"mouseConstraint\":\n                n.addConstraint(e, a.constraint);}\n          }return i.trigger(e, \"afterAdd\", { object: t }), e;\n        }, n.remove = function (e, t, o) {\n          var r = [].concat(t);i.trigger(e, \"beforeRemove\", { object: t });for (var s = 0; s < r.length; s++) {\n            var a = r[s];switch (a.type) {case \"body\":\n                n.removeBody(e, a, o);break;case \"constraint\":\n                n.removeConstraint(e, a, o);break;case \"composite\":\n                n.removeComposite(e, a, o);break;case \"mouseConstraint\":\n                n.removeConstraint(e, a.constraint);}\n          }return i.trigger(e, \"afterRemove\", { object: t }), e;\n        }, n.addComposite = function (e, t) {\n          return e.composites.push(t), t.parent = e, n.setModified(e, !0, !0, !1), e;\n        }, n.removeComposite = function (e, t, o) {\n          var i = r.indexOf(e.composites, t);if (-1 !== i && (n.removeCompositeAt(e, i), n.setModified(e, !0, !0, !1)), o) for (var s = 0; s < e.composites.length; s++) {\n            n.removeComposite(e.composites[s], t, !0);\n          }return e;\n        }, n.removeCompositeAt = function (e, t) {\n          return e.composites.splice(t, 1), n.setModified(e, !0, !0, !1), e;\n        }, n.addBody = function (e, t) {\n          return e.bodies.push(t), n.setModified(e, !0, !0, !1), e;\n        }, n.removeBody = function (e, t, o) {\n          var i = r.indexOf(e.bodies, t);if (-1 !== i && (n.removeBodyAt(e, i), n.setModified(e, !0, !0, !1)), o) for (var s = 0; s < e.composites.length; s++) {\n            n.removeBody(e.composites[s], t, !0);\n          }return e;\n        }, n.removeBodyAt = function (e, t) {\n          return e.bodies.splice(t, 1), n.setModified(e, !0, !0, !1), e;\n        }, n.addConstraint = function (e, t) {\n          return e.constraints.push(t), n.setModified(e, !0, !0, !1), e;\n        }, n.removeConstraint = function (e, t, o) {\n          var i = r.indexOf(e.constraints, t);if (-1 !== i && n.removeConstraintAt(e, i), o) for (var s = 0; s < e.composites.length; s++) {\n            n.removeConstraint(e.composites[s], t, !0);\n          }return e;\n        }, n.removeConstraintAt = function (e, t) {\n          return e.constraints.splice(t, 1), n.setModified(e, !0, !0, !1), e;\n        }, n.clear = function (e, t, o) {\n          if (o) for (var i = 0; i < e.composites.length; i++) {\n            n.clear(e.composites[i], t, !0);\n          }return t ? e.bodies = e.bodies.filter(function (e) {\n            return e.isStatic;\n          }) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, n.setModified(e, !0, !0, !1), e;\n        }, n.allBodies = function (e) {\n          for (var t = [].concat(e.bodies), o = 0; o < e.composites.length; o++) {\n            t = t.concat(n.allBodies(e.composites[o]));\n          }return t;\n        }, n.allConstraints = function (e) {\n          for (var t = [].concat(e.constraints), o = 0; o < e.composites.length; o++) {\n            t = t.concat(n.allConstraints(e.composites[o]));\n          }return t;\n        }, n.allComposites = function (e) {\n          for (var t = [].concat(e.composites), o = 0; o < e.composites.length; o++) {\n            t = t.concat(n.allComposites(e.composites[o]));\n          }return t;\n        }, n.get = function (e, t, o) {\n          var i, r;switch (o) {case \"body\":\n              i = n.allBodies(e);break;case \"constraint\":\n              i = n.allConstraints(e);break;case \"composite\":\n              i = n.allComposites(e).concat(e);}return i ? (r = i.filter(function (e) {\n            return e.id.toString() === t.toString();\n          }), 0 === r.length ? null : r[0]) : null;\n        }, n.move = function (e, t, o) {\n          return n.remove(e, t), n.add(o, t), e;\n        }, n.rebase = function (e) {\n          for (var t = n.allBodies(e).concat(n.allConstraints(e)).concat(n.allComposites(e)), o = 0; o < t.length; o++) {\n            t[o].id = r.nextId();\n          }return n.setModified(e, !0, !0, !1), e;\n        }, n.translate = function (e, t, o) {\n          for (var i = o ? n.allBodies(e) : e.bodies, r = 0; r < i.length; r++) {\n            s.translate(i[r], t);\n          }return n.setModified(e, !0, !0, !1), e;\n        }, n.rotate = function (e, t, o, i) {\n          for (var r = Math.cos(t), a = Math.sin(t), l = i ? n.allBodies(e) : e.bodies, c = 0; c < l.length; c++) {\n            var d = l[c],\n                u = d.position.x - o.x,\n                p = d.position.y - o.y;s.setPosition(d, { x: o.x + (u * r - p * a), y: o.y + (u * a + p * r) }), s.rotate(d, t);\n          }return n.setModified(e, !0, !0, !1), e;\n        }, n.scale = function (e, t, o, i, r) {\n          for (var a = r ? n.allBodies(e) : e.bodies, l = 0; l < a.length; l++) {\n            var c = a[l],\n                d = c.position.x - i.x,\n                u = c.position.y - i.y;s.setPosition(c, { x: i.x + d * t, y: i.y + u * o }), s.scale(c, t, o);\n          }return n.setModified(e, !0, !0, !1), e;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Events\": 16, \"./Body\": 1 }], 3: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Composite\"),\n          r = (e(\"../constraint/Constraint\"), e(\"../core/Common\"));!function () {\n        n.create = function (e) {\n          var t = i.create(),\n              o = { label: \"World\", gravity: { x: 0, y: 1, scale: .001 }, bounds: { min: { x: -(1 / 0), y: -(1 / 0) }, max: { x: 1 / 0, y: 1 / 0 } } };return r.extend(t, o, e);\n        };\n      }();\n    }, { \"../constraint/Constraint\": 12, \"../core/Common\": 14, \"./Composite\": 2 }], 4: [function (e, t, o) {\n      var n = {};t.exports = n, function () {\n        n.create = function (e) {\n          return { id: n.id(e), vertex: e, normalImpulse: 0, tangentImpulse: 0 };\n        }, n.id = function (e) {\n          return e.body.id + \"_\" + e.index;\n        };\n      }();\n    }, {}], 5: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./SAT\"),\n          r = e(\"./Pair\"),\n          s = e(\"../geometry/Bounds\");!function () {\n        n.collisions = function (e, t) {\n          for (var o = [], a = t.pairs.table, l = 0; l < e.length; l++) {\n            var c = e[l][0],\n                d = e[l][1];if ((!c.isStatic && !c.isSleeping || !d.isStatic && !d.isSleeping) && n.canCollide(c.collisionFilter, d.collisionFilter) && s.overlaps(c.bounds, d.bounds)) for (var u = c.parts.length > 1 ? 1 : 0; u < c.parts.length; u++) {\n              for (var p = c.parts[u], f = d.parts.length > 1 ? 1 : 0; f < d.parts.length; f++) {\n                var v = d.parts[f];if (p === c && v === d || s.overlaps(p.bounds, v.bounds)) {\n                  var m,\n                      y = r.id(p, v),\n                      g = a[y];m = g && g.isActive ? g.collision : null;var x = i.collides(p, v, m);\n                  x.collided && o.push(x);\n                }\n              }\n            }\n          }return o;\n        }, n.canCollide = function (e, t) {\n          return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 !== (e.mask & t.category) && 0 !== (t.mask & e.category);\n        };\n      }();\n    }, { \"../geometry/Bounds\": 24, \"./Pair\": 7, \"./SAT\": 11 }], 6: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Pair\"),\n          r = e(\"./Detector\"),\n          s = e(\"../core/Common\");!function () {\n        n.create = function (e) {\n          var t = { controller: n, detector: r.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 };return s.extend(t, e);\n        }, n.update = function (o, n, i, r) {\n          var s,\n              p,\n              f,\n              v,\n              m,\n              y = i.world,\n              g = o.buckets,\n              x = !1;for (s = 0; s < n.length; s++) {\n            var h = n[s];if ((!h.isSleeping || r) && !(h.bounds.max.x < y.bounds.min.x || h.bounds.min.x > y.bounds.max.x || h.bounds.max.y < y.bounds.min.y || h.bounds.min.y > y.bounds.max.y)) {\n              var b = t(o, h);if (!h.region || b.id !== h.region.id || r) {\n                h.region && !r || (h.region = b);var w = e(b, h.region);for (p = w.startCol; p <= w.endCol; p++) {\n                  for (f = w.startRow; f <= w.endRow; f++) {\n                    m = a(p, f), v = g[m];var S = p >= b.startCol && p <= b.endCol && f >= b.startRow && f <= b.endRow,\n                        C = p >= h.region.startCol && p <= h.region.endCol && f >= h.region.startRow && f <= h.region.endRow;\n                    !S && C && C && v && d(o, v, h), (h.region === b || S && !C || r) && (v || (v = l(g, m)), c(o, v, h));\n                  }\n                }h.region = b, x = !0;\n              }\n            }\n          }x && (o.pairsList = u(o));\n        }, n.clear = function (e) {\n          e.buckets = {}, e.pairs = {}, e.pairsList = [];\n        };var e = function e(_e2, t) {\n          var n = Math.min(_e2.startCol, t.startCol),\n              i = Math.max(_e2.endCol, t.endCol),\n              r = Math.min(_e2.startRow, t.startRow),\n              s = Math.max(_e2.endRow, t.endRow);return o(n, i, r, s);\n        },\n            t = function t(e, _t) {\n          var n = _t.bounds,\n              i = Math.floor(n.min.x / e.bucketWidth),\n              r = Math.floor(n.max.x / e.bucketWidth),\n              s = Math.floor(n.min.y / e.bucketHeight),\n              a = Math.floor(n.max.y / e.bucketHeight);return o(i, r, s, a);\n        },\n            o = function o(e, t, _o, n) {\n          return { id: e + \",\" + t + \",\" + _o + \",\" + n, startCol: e, endCol: t, startRow: _o, endRow: n };\n        },\n            a = function a(e, t) {\n          return e + \",\" + t;\n        },\n            l = function l(e, t) {\n          var o = e[t] = [];return o;\n        },\n            c = function c(e, t, o) {\n          for (var n = 0; n < t.length; n++) {\n            var r = t[n];if (!(o.id === r.id || o.isStatic && r.isStatic)) {\n              var s = i.id(o, r),\n                  a = e.pairs[s];a ? a[2] += 1 : e.pairs[s] = [o, r, 1];\n            }\n          }t.push(o);\n        },\n            d = function d(e, t, o) {\n          t.splice(s.indexOf(t, o), 1);for (var n = 0; n < t.length; n++) {\n            var r = t[n],\n                a = i.id(o, r),\n                l = e.pairs[a];l && (l[2] -= 1);\n          }\n        },\n            u = function u(e) {\n          var t,\n              o,\n              n = [];t = s.keys(e.pairs);for (var i = 0; i < t.length; i++) {\n            o = e.pairs[t[i]], o[2] > 0 ? n.push(o) : delete e.pairs[t[i]];\n          }return n;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"./Detector\": 5, \"./Pair\": 7 }], 7: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Contact\");!function () {\n        n.create = function (e, t) {\n          var o = e.bodyA,\n              i = e.bodyB,\n              r = e.parentA,\n              s = e.parentB,\n              a = { id: n.id(o, i), bodyA: o, bodyB: i, contacts: {}, activeContacts: [], separation: 0, isActive: !0, isSensor: o.isSensor || i.isSensor, timeCreated: t, timeUpdated: t, inverseMass: r.inverseMass + s.inverseMass, friction: Math.min(r.friction, s.friction), frictionStatic: Math.max(r.frictionStatic, s.frictionStatic), restitution: Math.max(r.restitution, s.restitution), slop: Math.max(r.slop, s.slop) };return n.update(a, e, t), a;\n        }, n.update = function (e, t, o) {\n          var r = e.contacts,\n              s = t.supports,\n              a = e.activeContacts,\n              l = t.parentA,\n              c = t.parentB;if (e.collision = t, e.inverseMass = l.inverseMass + c.inverseMass, e.friction = Math.min(l.friction, c.friction), e.frictionStatic = Math.max(l.frictionStatic, c.frictionStatic), e.restitution = Math.max(l.restitution, c.restitution), e.slop = Math.max(l.slop, c.slop), a.length = 0, t.collided) {\n            for (var d = 0; d < s.length; d++) {\n              var u = s[d],\n                  p = i.id(u),\n                  f = r[p];f ? a.push(f) : a.push(r[p] = i.create(u));\n            }e.separation = t.depth, n.setActive(e, !0, o);\n          } else e.isActive === !0 && n.setActive(e, !1, o);\n        }, n.setActive = function (e, t, o) {\n          t ? (e.isActive = !0, e.timeUpdated = o) : (e.isActive = !1, e.activeContacts.length = 0);\n        }, n.id = function (e, t) {\n          return e.id < t.id ? e.id + \"_\" + t.id : t.id + \"_\" + e.id;\n        };\n      }();\n    }, { \"./Contact\": 4 }], 8: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Pair\"),\n          r = e(\"../core/Common\");!function () {\n        var e = 1e3;n.create = function (e) {\n          return r.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, e);\n        }, n.update = function (e, t, o) {\n          var n,\n              s,\n              a,\n              l,\n              c = e.list,\n              d = e.table,\n              u = e.collisionStart,\n              p = e.collisionEnd,\n              f = e.collisionActive,\n              v = [];for (u.length = 0, p.length = 0, f.length = 0, l = 0; l < t.length; l++) {\n            n = t[l], n.collided && (s = i.id(n.bodyA, n.bodyB), v.push(s), a = d[s], a ? (a.isActive ? f.push(a) : u.push(a), i.update(a, n, o)) : (a = i.create(n, o), d[s] = a, u.push(a), c.push(a)));\n          }for (l = 0; l < c.length; l++) {\n            a = c[l], a.isActive && -1 === r.indexOf(v, a.id) && (i.setActive(a, !1, o), p.push(a));\n          }\n        }, n.removeOld = function (t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a = t.list,\n              l = t.table,\n              c = [];for (s = 0; s < a.length; s++) {\n            n = a[s], i = n.collision, i.bodyA.isSleeping || i.bodyB.isSleeping ? n.timeUpdated = o : o - n.timeUpdated > e && c.push(s);\n          }for (s = 0; s < c.length; s++) {\n            r = c[s] - s, n = a[r], delete l[n.id], a.splice(r, 1);\n          }\n        }, n.clear = function (e) {\n          return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e;\n        };\n      }();\n    }, { \"../core/Common\": 14, \"./Pair\": 7 }], 9: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vector\"),\n          r = e(\"./SAT\"),\n          s = e(\"../geometry/Bounds\"),\n          a = e(\"../factory/Bodies\"),\n          l = e(\"../geometry/Vertices\");!function () {\n        n.ray = function (e, t, o, n) {\n          n = n || 1e-100;for (var l = i.angle(t, o), c = i.magnitude(i.sub(t, o)), d = .5 * (o.x + t.x), u = .5 * (o.y + t.y), p = a.rectangle(d, u, c, n, { angle: l }), f = [], v = 0; v < e.length; v++) {\n            var m = e[v];if (s.overlaps(m.bounds, p.bounds)) for (var y = 1 === m.parts.length ? 0 : 1; y < m.parts.length; y++) {\n              var g = m.parts[y];if (s.overlaps(g.bounds, p.bounds)) {\n                var x = r.collides(g, p);if (x.collided) {\n                  x.body = x.bodyA = x.bodyB = m, f.push(x);break;\n                }\n              }\n            }\n          }return f;\n        }, n.region = function (e, t, o) {\n          for (var n = [], i = 0; i < e.length; i++) {\n            var r = e[i],\n                a = s.overlaps(r.bounds, t);(a && !o || !a && o) && n.push(r);\n          }return n;\n        }, n.point = function (e, t) {\n          for (var o = [], n = 0; n < e.length; n++) {\n            var i = e[n];if (s.contains(i.bounds, t)) for (var r = 1 === i.parts.length ? 0 : 1; r < i.parts.length; r++) {\n              var a = i.parts[r];if (s.contains(a.bounds, t) && l.contains(a.vertices, t)) {\n                o.push(i);break;\n              }\n            }\n          }return o;\n        };\n      }();\n    }, { \"../factory/Bodies\": 21, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27, \"./SAT\": 11 }], 10: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Common\"),\n          a = e(\"../geometry/Bounds\");!function () {\n        n._restingThresh = 4, n._restingThreshTangent = 6, n._positionDampen = .9, n._positionWarming = .8, n._frictionNormalMultiplier = 5, n.preSolvePosition = function (e) {\n          var t, o, n;for (t = 0; t < e.length; t++) {\n            o = e[t], o.isActive && (n = o.activeContacts.length, o.collision.parentA.totalContacts += n, o.collision.parentB.totalContacts += n);\n          }\n        }, n.solvePosition = function (e, t) {\n          var o,\n              i,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f = r._temp[0],\n              v = r._temp[1],\n              m = r._temp[2],\n              y = r._temp[3];for (o = 0; o < e.length; o++) {\n            i = e[o], i.isActive && !i.isSensor && (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, d = r.sub(r.add(l.positionImpulse, l.position, f), r.add(a.positionImpulse, r.sub(l.position, s.penetration, v), m), y), i.separation = r.dot(c, d));\n          }for (o = 0; o < e.length; o++) {\n            i = e[o], !i.isActive || i.isSensor || i.separation < 0 || (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, p = (i.separation - i.slop) * t, (a.isStatic || l.isStatic) && (p *= 2), a.isStatic || a.isSleeping || (u = n._positionDampen / a.totalContacts, a.positionImpulse.x += c.x * p * u, a.positionImpulse.y += c.y * p * u), l.isStatic || l.isSleeping || (u = n._positionDampen / l.totalContacts, l.positionImpulse.x -= c.x * p * u, l.positionImpulse.y -= c.y * p * u));\n          }\n        }, n.postSolvePosition = function (e) {\n          for (var t = 0; t < e.length; t++) {\n            var o = e[t];if (o.totalContacts = 0, 0 !== o.positionImpulse.x || 0 !== o.positionImpulse.y) {\n              for (var s = 0; s < o.parts.length; s++) {\n                var l = o.parts[s];i.translate(l.vertices, o.positionImpulse), a.update(l.bounds, l.vertices, o.velocity), l.position.x += o.positionImpulse.x, l.position.y += o.positionImpulse.y;\n              }o.positionPrev.x += o.positionImpulse.x, o.positionPrev.y += o.positionImpulse.y, r.dot(o.positionImpulse, o.velocity) < 0 ? (o.positionImpulse.x = 0, o.positionImpulse.y = 0) : (o.positionImpulse.x *= n._positionWarming, o.positionImpulse.y *= n._positionWarming);\n            }\n          }\n        }, n.preSolveVelocity = function (e) {\n          var t,\n              o,\n              n,\n              i,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f,\n              v,\n              m,\n              y = r._temp[0],\n              g = r._temp[1];for (t = 0; t < e.length; t++) {\n            if (n = e[t], n.isActive && !n.isSensor) for (i = n.activeContacts, s = n.collision, a = s.parentA, l = s.parentB, c = s.normal, d = s.tangent, o = 0; o < i.length; o++) {\n              u = i[o], p = u.vertex, f = u.normalImpulse, v = u.tangentImpulse, 0 === f && 0 === v || (y.x = c.x * f + d.x * v, y.y = c.y * f + d.y * v, a.isStatic || a.isSleeping || (m = r.sub(p, a.position, g), a.positionPrev.x += y.x * a.inverseMass, a.positionPrev.y += y.y * a.inverseMass, a.anglePrev += r.cross(m, y) * a.inverseInertia), l.isStatic || l.isSleeping || (m = r.sub(p, l.position, g), l.positionPrev.x -= y.x * l.inverseMass, l.positionPrev.y -= y.y * l.inverseMass, l.anglePrev -= r.cross(m, y) * l.inverseInertia));\n            }\n          }\n        }, n.solveVelocity = function (e, t) {\n          for (var o = t * t, i = r._temp[0], a = r._temp[1], l = r._temp[2], c = r._temp[3], d = r._temp[4], u = r._temp[5], p = 0; p < e.length; p++) {\n            var f = e[p];if (f.isActive && !f.isSensor) {\n              var v = f.collision,\n                  m = v.parentA,\n                  y = v.parentB,\n                  g = v.normal,\n                  x = v.tangent,\n                  h = f.activeContacts,\n                  b = 1 / h.length;m.velocity.x = m.position.x - m.positionPrev.x, m.velocity.y = m.position.y - m.positionPrev.y, y.velocity.x = y.position.x - y.positionPrev.x, y.velocity.y = y.position.y - y.positionPrev.y, m.angularVelocity = m.angle - m.anglePrev, y.angularVelocity = y.angle - y.anglePrev;for (var w = 0; w < h.length; w++) {\n                var S = h[w],\n                    C = S.vertex,\n                    A = r.sub(C, m.position, a),\n                    B = r.sub(C, y.position, l),\n                    P = r.add(m.velocity, r.mult(r.perp(A), m.angularVelocity), c),\n                    M = r.add(y.velocity, r.mult(r.perp(B), y.angularVelocity), d),\n                    k = r.sub(P, M, u),\n                    I = r.dot(g, k),\n                    T = r.dot(x, k),\n                    V = Math.abs(T),\n                    R = s.sign(T),\n                    E = (1 + f.restitution) * I,\n                    _ = s.clamp(f.separation + I, 0, 1) * n._frictionNormalMultiplier,\n                    F = T,\n                    O = 1 / 0;V > f.friction * f.frictionStatic * _ * o && (O = V, F = s.clamp(f.friction * R * o, -O, O));var L = r.cross(A, g),\n                    q = r.cross(B, g),\n                    W = b / (m.inverseMass + y.inverseMass + m.inverseInertia * L * L + y.inverseInertia * q * q);\n                if (E *= W, F *= W, 0 > I && I * I > n._restingThresh * o) S.normalImpulse = 0;else {\n                  var D = S.normalImpulse;S.normalImpulse = Math.min(S.normalImpulse + E, 0), E = S.normalImpulse - D;\n                }if (T * T > n._restingThreshTangent * o) S.tangentImpulse = 0;else {\n                  var N = S.tangentImpulse;S.tangentImpulse = s.clamp(S.tangentImpulse + F, -O, O), F = S.tangentImpulse - N;\n                }i.x = g.x * E + x.x * F, i.y = g.y * E + x.y * F, m.isStatic || m.isSleeping || (m.positionPrev.x += i.x * m.inverseMass, m.positionPrev.y += i.y * m.inverseMass, m.anglePrev += r.cross(A, i) * m.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= i.x * y.inverseMass, y.positionPrev.y -= i.y * y.inverseMass, y.anglePrev -= r.cross(B, i) * y.inverseInertia);\n              }\n            }\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27 }], 11: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\");!function () {\n        n.collides = function (t, n, s) {\n          var a,\n              l,\n              c,\n              d,\n              u = s,\n              p = !1;if (u) {\n            var f = t.parent,\n                v = n.parent,\n                m = f.speed * f.speed + f.angularSpeed * f.angularSpeed + v.speed * v.speed + v.angularSpeed * v.angularSpeed;\n            p = u && u.collided && .2 > m, d = u;\n          } else d = { collided: !1, bodyA: t, bodyB: n };if (u && p) {\n            var y = d.axisBody,\n                g = y === t ? n : t,\n                x = [y.axes[u.axisNumber]];if (c = e(y.vertices, g.vertices, x), d.reused = !0, c.overlap <= 0) return d.collided = !1, d;\n          } else {\n            if (a = e(t.vertices, n.vertices, t.axes), a.overlap <= 0) return d.collided = !1, d;if (l = e(n.vertices, t.vertices, n.axes), l.overlap <= 0) return d.collided = !1, d;a.overlap < l.overlap ? (c = a, d.axisBody = t) : (c = l, d.axisBody = n), d.axisNumber = c.axisNumber;\n          }d.bodyA = t.id < n.id ? t : n, d.bodyB = t.id < n.id ? n : t, d.collided = !0, d.normal = c.axis, d.depth = c.overlap, d.parentA = d.bodyA.parent, d.parentB = d.bodyB.parent, t = d.bodyA, n = d.bodyB, r.dot(d.normal, r.sub(n.position, t.position)) > 0 && (d.normal = r.neg(d.normal)), d.tangent = r.perp(d.normal), d.penetration = { x: d.normal.x * d.depth, y: d.normal.y * d.depth };var h = o(t, n, d.normal),\n              b = d.supports || [];if (b.length = 0, i.contains(t.vertices, h[0]) && b.push(h[0]), i.contains(t.vertices, h[1]) && b.push(h[1]), b.length < 2) {\n            var w = o(n, t, r.neg(d.normal));i.contains(n.vertices, w[0]) && b.push(w[0]), b.length < 2 && i.contains(n.vertices, w[1]) && b.push(w[1]);\n          }return b.length < 1 && (b = [h[0]]), d.supports = b, d;\n        };var e = function e(_e3, o, n) {\n          for (var i, s, a = r._temp[0], l = r._temp[1], c = { overlap: Number.MAX_VALUE }, d = 0; d < n.length; d++) {\n            if (s = n[d], t(a, _e3, s), t(l, o, s), i = Math.min(a.max - l.min, l.max - a.min), 0 >= i) return c.overlap = i, c;i < c.overlap && (c.overlap = i, c.axis = s, c.axisNumber = d);\n          }return c;\n        },\n            t = function t(e, _t2, o) {\n          for (var n = r.dot(_t2[0], o), i = n, s = 1; s < _t2.length; s += 1) {\n            var a = r.dot(_t2[s], o);a > i ? i = a : n > a && (n = a);\n          }e.min = n, e.max = i;\n        },\n            o = function o(e, t, _o2) {\n          for (var n, i, s, a, l = Number.MAX_VALUE, c = r._temp[0], d = t.vertices, u = e.position, p = 0; p < d.length; p++) {\n            i = d[p], c.x = i.x - u.x, c.y = i.y - u.y, n = -r.dot(_o2, c), l > n && (l = n, s = i);\n          }var f = s.index - 1 >= 0 ? s.index - 1 : d.length - 1;i = d[f], c.x = i.x - u.x, c.y = i.y - u.y, l = -r.dot(_o2, c), a = i;var v = (s.index + 1) % d.length;return i = d[v], c.x = i.x - u.x, c.y = i.y - u.y, n = -r.dot(_o2, c), l > n && (a = i), [s, a];\n        };\n      }();\n    }, { \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27 }], 12: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../geometry/Vector\"),\n          s = e(\"../core/Sleeping\"),\n          a = e(\"../geometry/Bounds\"),\n          l = e(\"../geometry/Axes\"),\n          c = e(\"../core/Common\");\n      !function () {\n        var e = 1e-6,\n            t = .001;n.create = function (t) {\n          var o = t;o.bodyA && !o.pointA && (o.pointA = { x: 0, y: 0 }), o.bodyB && !o.pointB && (o.pointB = { x: 0, y: 0 });var n = o.bodyA ? r.add(o.bodyA.position, o.pointA) : o.pointA,\n              i = o.bodyB ? r.add(o.bodyB.position, o.pointB) : o.pointB,\n              s = r.magnitude(r.sub(n, i));o.length = o.length || s || e;var a = { visible: !0, lineWidth: 2, strokeStyle: \"#666\" };return o.render = c.extend(a, o.render), o.id = o.id || c.nextId(), o.label = o.label || \"Constraint\", o.type = \"constraint\", o.stiffness = o.stiffness || 1, o.angularStiffness = o.angularStiffness || 0, o.angleA = o.bodyA ? o.bodyA.angle : o.angleA, o.angleB = o.bodyB ? o.bodyB.angle : o.angleB, o;\n        }, n.solveAll = function (e, t) {\n          for (var o = 0; o < e.length; o++) {\n            n.solve(e[o], t);\n          }\n        }, n.solve = function (o, n) {\n          var i = o.bodyA,\n              s = o.bodyB,\n              a = o.pointA,\n              l = o.pointB;i && !i.isStatic && (o.pointA = r.rotate(a, i.angle - o.angleA), o.angleA = i.angle), s && !s.isStatic && (o.pointB = r.rotate(l, s.angle - o.angleB), o.angleB = s.angle);var c = a,\n              d = l;if (i && (c = r.add(i.position, a)), s && (d = r.add(s.position, l)), c && d) {\n            var u = r.sub(c, d),\n                p = r.magnitude(u);0 === p && (p = e);\n            var f = (p - o.length) / p,\n                v = r.div(u, p),\n                m = r.mult(u, .5 * f * o.stiffness * n * n);if (!(Math.abs(1 - p / o.length) < t * n)) {\n              var y, g, x, h, b, w, S, C;i && !i.isStatic ? (x = { x: c.x - i.position.x + m.x, y: c.y - i.position.y + m.y }, i.velocity.x = i.position.x - i.positionPrev.x, i.velocity.y = i.position.y - i.positionPrev.y, i.angularVelocity = i.angle - i.anglePrev, y = r.add(i.velocity, r.mult(r.perp(x), i.angularVelocity)), b = r.dot(x, v), S = i.inverseMass + i.inverseInertia * b * b) : (y = { x: 0, y: 0 }, S = i ? i.inverseMass : 0), s && !s.isStatic ? (h = { x: d.x - s.position.x - m.x, y: d.y - s.position.y - m.y }, s.velocity.x = s.position.x - s.positionPrev.x, s.velocity.y = s.position.y - s.positionPrev.y, s.angularVelocity = s.angle - s.anglePrev, g = r.add(s.velocity, r.mult(r.perp(h), s.angularVelocity)), w = r.dot(h, v), C = s.inverseMass + s.inverseInertia * w * w) : (g = { x: 0, y: 0 }, C = s ? s.inverseMass : 0);var A = r.sub(g, y),\n                  B = r.dot(v, A) / (S + C);B > 0 && (B = 0);var P,\n                  M = { x: v.x * B, y: v.y * B };i && !i.isStatic && (P = r.cross(x, M) * i.inverseInertia * (1 - o.angularStiffness), i.constraintImpulse.x -= m.x, i.constraintImpulse.y -= m.y, i.constraintImpulse.angle += P, i.position.x -= m.x, i.position.y -= m.y, i.angle += P), s && !s.isStatic && (P = r.cross(h, M) * s.inverseInertia * (1 - o.angularStiffness), s.constraintImpulse.x += m.x, s.constraintImpulse.y += m.y, s.constraintImpulse.angle -= P, s.position.x += m.x, s.position.y += m.y, s.angle -= P);\n            }\n          }\n        }, n.postSolveAll = function (e) {\n          for (var t = 0; t < e.length; t++) {\n            var o = e[t],\n                n = o.constraintImpulse;if (0 !== n.x || 0 !== n.y || 0 !== n.angle) {\n              s.set(o, !1);for (var c = 0; c < o.parts.length; c++) {\n                var d = o.parts[c];i.translate(d.vertices, n), c > 0 && (d.position.x += n.x, d.position.y += n.y), 0 !== n.angle && (i.rotate(d.vertices, n.angle, o.position), l.rotate(d.axes, n.angle), c > 0 && r.rotateAbout(d.position, n.angle, o.position, d.position)), a.update(d.bounds, d.vertices, o.velocity);\n              }n.angle = 0, n.x = 0, n.y = 0;\n            }\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../core/Sleeping\": 20, \"../geometry/Axes\": 23, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27 }], 13: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../core/Sleeping\"),\n          s = e(\"../core/Mouse\"),\n          a = e(\"../core/Events\"),\n          l = e(\"../collision/Detector\"),\n          c = e(\"./Constraint\"),\n          d = e(\"../body/Composite\"),\n          u = e(\"../core/Common\"),\n          p = e(\"../geometry/Bounds\");\n      !function () {\n        n.create = function (t, o) {\n          var i = (t ? t.mouse : null) || (o ? o.mouse : null);i || (t && t.render && t.render.canvas ? i = s.create(t.render.canvas) : o && o.element ? i = s.create(o.element) : (i = s.create(), u.log(\"MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected\", \"warn\")));var r = c.create({ label: \"Mouse Constraint\", pointA: i.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: \"#90EE90\", lineWidth: 3 } }),\n              l = { type: \"mouseConstraint\", mouse: i, element: null, body: null, constraint: r, collisionFilter: { category: 1, mask: 4294967295, group: 0 } },\n              p = u.extend(l, o);return a.on(t, \"tick\", function () {\n            var o = d.allBodies(t.world);n.update(p, o), e(p);\n          }), p;\n        }, n.update = function (e, t) {\n          var o = e.mouse,\n              n = e.constraint,\n              s = e.body;if (0 === o.button) {\n            if (n.bodyB) r.set(n.bodyB, !1), n.pointA = o.position;else for (var c = 0; c < t.length; c++) {\n              if (s = t[c], p.contains(s.bounds, o.position) && l.canCollide(s.collisionFilter, e.collisionFilter)) for (var d = s.parts.length > 1 ? 1 : 0; d < s.parts.length; d++) {\n                var u = s.parts[d];if (i.contains(u.vertices, o.position)) {\n                  n.pointA = o.position, n.bodyB = e.body = s, n.pointB = { x: o.position.x - s.position.x, y: o.position.y - s.position.y }, n.angleB = s.angle, r.set(s, !1), a.trigger(e, \"startdrag\", { mouse: o, body: s });break;\n                }\n              }\n            }\n          } else n.bodyB = e.body = null, n.pointB = null, s && a.trigger(e, \"enddrag\", { mouse: o, body: s });\n        };var e = function e(_e4) {\n          var t = _e4.mouse,\n              o = t.sourceEvents;o.mousemove && a.trigger(_e4, \"mousemove\", { mouse: t }), o.mousedown && a.trigger(_e4, \"mousedown\", { mouse: t }), o.mouseup && a.trigger(_e4, \"mouseup\", { mouse: t }), s.clearSourceEvents(t);\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../collision/Detector\": 5, \"../core/Common\": 14, \"../core/Events\": 16, \"../core/Mouse\": 18, \"../core/Sleeping\": 20, \"../geometry/Bounds\": 24, \"../geometry/Vertices\": 27, \"./Constraint\": 12 }], 14: [function (e, t, o) {\n      var n = {};t.exports = n, function () {\n        n._nextId = 0, n._seed = 0, n.extend = function (e, t) {\n          var o, i, r;\"boolean\" == typeof t ? (o = 2, r = t) : (o = 1, r = !0), i = Array.prototype.slice.call(arguments, o);for (var s = 0; s < i.length; s++) {\n            var a = i[s];if (a) for (var l in a) {\n              r && a[l] && a[l].constructor === Object ? e[l] && e[l].constructor !== Object ? e[l] = a[l] : (e[l] = e[l] || {}, n.extend(e[l], r, a[l])) : e[l] = a[l];\n            }\n          }return e;\n        }, n.clone = function (e, t) {\n          return n.extend({}, t, e);\n        }, n.keys = function (e) {\n          if (Object.keys) return Object.keys(e);var t = [];for (var o in e) {\n            t.push(o);\n          }return t;\n        }, n.values = function (e) {\n          var t = [];if (Object.keys) {\n            for (var o = Object.keys(e), n = 0; n < o.length; n++) {\n              t.push(e[o[n]]);\n            }return t;\n          }for (var i in e) {\n            t.push(e[i]);\n          }return t;\n        }, n.shadeColor = function (e, t) {\n          var o = parseInt(e.slice(1), 16),\n              n = Math.round(2.55 * t),\n              i = (o >> 16) + n,\n              r = (o >> 8 & 255) + n,\n              s = (255 & o) + n;return \"#\" + (16777216 + 65536 * (255 > i ? 1 > i ? 0 : i : 255) + 256 * (255 > r ? 1 > r ? 0 : r : 255) + (255 > s ? 1 > s ? 0 : s : 255)).toString(16).slice(1);\n        }, n.shuffle = function (e) {\n          for (var t = e.length - 1; t > 0; t--) {\n            var o = Math.floor(n.random() * (t + 1)),\n                i = e[t];e[t] = e[o], e[o] = i;\n          }return e;\n        }, n.choose = function (e) {\n          return e[Math.floor(n.random() * e.length)];\n        }, n.isElement = function (e) {\n          try {\n            return e instanceof HTMLElement;\n          } catch (t) {\n            return \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && 1 === e.nodeType && \"object\" == _typeof(e.style) && \"object\" == _typeof(e.ownerDocument);\n          }\n        }, n.isArray = function (e) {\n          return \"[object Array]\" === Object.prototype.toString.call(e);\n        }, n.clamp = function (e, t, o) {\n          return t > e ? t : e > o ? o : e;\n        }, n.sign = function (e) {\n          return 0 > e ? -1 : 1;\n        }, n.now = function () {\n          var e = window.performance || {};return e.now = function () {\n            return e.now || e.webkitNow || e.msNow || e.oNow || e.mozNow || function () {\n              return +new Date();\n            };\n          }(), e.now();\n        }, n.random = function (t, o) {\n          return t = \"undefined\" != typeof t ? t : 0, o = \"undefined\" != typeof o ? o : 1, t + e() * (o - t);\n        }, n.colorToNumber = function (e) {\n          return e = e.replace(\"#\", \"\"), 3 == e.length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16);\n        }, n.log = function (e, t) {\n          if (console && console.log && console.warn) switch (t) {case \"warn\":\n              console.warn(\"Matter.js:\", e);break;case \"error\":\n              console.log(\"Matter.js:\", e);}\n        }, n.nextId = function () {\n          return n._nextId++;\n        }, n.indexOf = function (e, t) {\n          if (e.indexOf) return e.indexOf(t);for (var o = 0; o < e.length; o++) {\n            if (e[o] === t) return o;\n          }return -1;\n        };var e = function e() {\n          return n._seed = (9301 * n._seed + 49297) % 233280, n._seed / 233280;\n        };\n      }();\n    }, {}], 15: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../body/World\"),\n          r = e(\"./Sleeping\"),\n          s = e(\"../collision/Resolver\"),\n          a = e(\"../render/Render\"),\n          l = e(\"../collision/Pairs\"),\n          c = (e(\"./Metrics\"), e(\"../collision/Grid\")),\n          d = e(\"./Events\"),\n          u = e(\"../body/Composite\"),\n          p = e(\"../constraint/Constraint\"),\n          f = e(\"./Common\"),\n          v = e(\"../body/Body\");!function () {\n        n.create = function (e, t) {\n          t = f.isElement(e) ? t : e, e = f.isElement(e) ? e : null, t = t || {}, (e || t.render) && f.log(\"Engine.create: engine.render is deprecated (see docs)\", \"warn\");var o = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: c } },\n              n = f.extend(o, t);if (e || n.render) {\n            var r = { element: e, controller: a };n.render = f.extend(r, n.render);\n          }return n.render && n.render.controller && (n.render = n.render.controller.create(n.render)), n.render && (n.render.engine = n), n.world = t.world || i.create(n.world), n.pairs = l.create(), n.broadphase = n.broadphase.controller.create(n.broadphase), n.metrics = n.metrics || { extended: !1 }, n;\n        }, n.update = function (n, i, a) {\n          i = i || 1e3 / 60, a = a || 1;var c,\n              f = n.world,\n              v = n.timing,\n              m = n.broadphase,\n              y = [];v.timestamp += i * v.timeScale;var g = { timestamp: v.timestamp };d.trigger(n, \"beforeUpdate\", g);\n          var x = u.allBodies(f),\n              h = u.allConstraints(f);for (n.enableSleeping && r.update(x, v.timeScale), t(x, f.gravity), o(x, i, v.timeScale, a, f.bounds), c = 0; c < n.constraintIterations; c++) {\n            p.solveAll(h, v.timeScale);\n          }p.postSolveAll(x), m.controller ? (f.isModified && m.controller.clear(m), m.controller.update(m, x, n, f.isModified), y = m.pairsList) : y = x, f.isModified && u.setModified(f, !1, !1, !0);var b = m.detector(y, n),\n              w = n.pairs,\n              S = v.timestamp;for (l.update(w, b, S), l.removeOld(w, S), n.enableSleeping && r.afterCollisions(w.list, v.timeScale), w.collisionStart.length > 0 && d.trigger(n, \"collisionStart\", { pairs: w.collisionStart }), s.preSolvePosition(w.list), c = 0; c < n.positionIterations; c++) {\n            s.solvePosition(w.list, v.timeScale);\n          }for (s.postSolvePosition(x), s.preSolveVelocity(w.list), c = 0; c < n.velocityIterations; c++) {\n            s.solveVelocity(w.list, v.timeScale);\n          }return w.collisionActive.length > 0 && d.trigger(n, \"collisionActive\", { pairs: w.collisionActive }), w.collisionEnd.length > 0 && d.trigger(n, \"collisionEnd\", { pairs: w.collisionEnd }), e(x), d.trigger(n, \"afterUpdate\", g), n;\n        }, n.merge = function (e, t) {\n          if (f.extend(e, t), t.world) {\n            e.world = t.world, n.clear(e);for (var o = u.allBodies(e.world), i = 0; i < o.length; i++) {\n              var s = o[i];r.set(s, !1), s.id = f.nextId();\n            }\n          }\n        }, n.clear = function (e) {\n          var t = e.world;l.clear(e.pairs);var o = e.broadphase;if (o.controller) {\n            var n = u.allBodies(t);o.controller.clear(o), o.controller.update(o, n, e, !0);\n          }\n        };var e = function e(_e5) {\n          for (var t = 0; t < _e5.length; t++) {\n            var o = _e5[t];o.force.x = 0, o.force.y = 0, o.torque = 0;\n          }\n        },\n            t = function t(e, _t3) {\n          var o = \"undefined\" != typeof _t3.scale ? _t3.scale : .001;if ((0 !== _t3.x || 0 !== _t3.y) && 0 !== o) for (var n = 0; n < e.length; n++) {\n            var i = e[n];i.isStatic || i.isSleeping || (i.force.y += i.mass * _t3.y * o, i.force.x += i.mass * _t3.x * o);\n          }\n        },\n            o = function o(e, t, _o3, n, i) {\n          for (var r = 0; r < e.length; r++) {\n            var s = e[r];s.isStatic || s.isSleeping || v.update(s, t, _o3, n);\n          }\n        };\n      }();\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../body/World\": 3, \"../collision/Grid\": 6, \"../collision/Pairs\": 8, \"../collision/Resolver\": 10, \"../constraint/Constraint\": 12, \"../render/Render\": 29, \"./Common\": 14, \"./Events\": 16, \"./Metrics\": 17, \"./Sleeping\": 20 }], 16: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Common\");!function () {\n        n.on = function (e, t, o) {\n          for (var n, i = t.split(\" \"), r = 0; r < i.length; r++) {\n            n = i[r], e.events = e.events || {}, e.events[n] = e.events[n] || [], e.events[n].push(o);\n          }return o;\n        }, n.off = function (e, t, o) {\n          if (!t) return void (e.events = {});\"function\" == typeof t && (o = t, t = i.keys(e.events).join(\" \"));for (var n = t.split(\" \"), r = 0; r < n.length; r++) {\n            var s = e.events[n[r]],\n                a = [];if (o && s) for (var l = 0; l < s.length; l++) {\n              s[l] !== o && a.push(s[l]);\n            }e.events[n[r]] = a;\n          }\n        }, n.trigger = function (e, t, o) {\n          var n, r, s, a;if (e.events) {\n            o || (o = {}), n = t.split(\" \");for (var l = 0; l < n.length; l++) {\n              if (r = n[l], s = e.events[r]) {\n                a = i.clone(o, !1), a.name = r, a.source = e;for (var c = 0; c < s.length; c++) {\n                  s[c].apply(e, [a]);\n                }\n              }\n            }\n          }\n        };\n      }();\n    }, { \"./Common\": 14 }], 17: [function (e, t, o) {}, { \"../body/Composite\": 2, \"./Common\": 14 }], 18: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../core/Common\");!function () {\n        n.create = function (t) {\n          var o = {};return t || i.log(\"Mouse.create: element was undefined, defaulting to document.body\", \"warn\"), o.element = t || document.body, o.absolute = { x: 0, y: 0\n          }, o.position = { x: 0, y: 0 }, o.mousedownPosition = { x: 0, y: 0 }, o.mouseupPosition = { x: 0, y: 0 }, o.offset = { x: 0, y: 0 }, o.scale = { x: 1, y: 1 }, o.wheelDelta = 0, o.button = -1, o.pixelRatio = o.element.getAttribute(\"data-pixel-ratio\") || 1, o.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, o.mousemove = function (t) {\n            var n = e(t, o.element, o.pixelRatio),\n                i = t.changedTouches;i && (o.button = 0, t.preventDefault()), o.absolute.x = n.x, o.absolute.y = n.y, o.position.x = o.absolute.x * o.scale.x + o.offset.x, o.position.y = o.absolute.y * o.scale.y + o.offset.y, o.sourceEvents.mousemove = t;\n          }, o.mousedown = function (t) {\n            var n = e(t, o.element, o.pixelRatio),\n                i = t.changedTouches;i ? (o.button = 0, t.preventDefault()) : o.button = t.button, o.absolute.x = n.x, o.absolute.y = n.y, o.position.x = o.absolute.x * o.scale.x + o.offset.x, o.position.y = o.absolute.y * o.scale.y + o.offset.y, o.mousedownPosition.x = o.position.x, o.mousedownPosition.y = o.position.y, o.sourceEvents.mousedown = t;\n          }, o.mouseup = function (t) {\n            var n = e(t, o.element, o.pixelRatio),\n                i = t.changedTouches;i && t.preventDefault(), o.button = -1, o.absolute.x = n.x, o.absolute.y = n.y, o.position.x = o.absolute.x * o.scale.x + o.offset.x, o.position.y = o.absolute.y * o.scale.y + o.offset.y, o.mouseupPosition.x = o.position.x, o.mouseupPosition.y = o.position.y, o.sourceEvents.mouseup = t;\n          }, o.mousewheel = function (e) {\n            o.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault();\n          }, n.setElement(o, o.element), o;\n        }, n.setElement = function (e, t) {\n          e.element = t, t.addEventListener(\"mousemove\", e.mousemove), t.addEventListener(\"mousedown\", e.mousedown), t.addEventListener(\"mouseup\", e.mouseup), t.addEventListener(\"mousewheel\", e.mousewheel), t.addEventListener(\"DOMMouseScroll\", e.mousewheel), t.addEventListener(\"touchmove\", e.mousemove), t.addEventListener(\"touchstart\", e.mousedown), t.addEventListener(\"touchend\", e.mouseup);\n        }, n.clearSourceEvents = function (e) {\n          e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0;\n        }, n.setOffset = function (e, t) {\n          e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;\n        }, n.setScale = function (e, t) {\n          e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;\n        };var e = function e(_e6, t, o) {\n          var n,\n              i,\n              r = t.getBoundingClientRect(),\n              s = document.documentElement || document.body.parentNode || document.body,\n              a = void 0 !== window.pageXOffset ? window.pageXOffset : s.scrollLeft,\n              l = void 0 !== window.pageYOffset ? window.pageYOffset : s.scrollTop,\n              c = _e6.changedTouches;return c ? (n = c[0].pageX - r.left - a, i = c[0].pageY - r.top - l) : (n = _e6.pageX - r.left - a, i = _e6.pageY - r.top - l), { x: n / (t.clientWidth / t.width * o), y: i / (t.clientHeight / t.height * o) };\n        };\n      }();\n    }, { \"../core/Common\": 14 }], 19: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Events\"),\n          r = e(\"./Engine\"),\n          s = e(\"./Common\");!function () {\n        var e, t;\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          window.setTimeout(function () {\n            e(s.now());\n          }, 1e3 / 60);\n        }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), n.create = function (e) {\n          var t = { fps: 60, correction: 1, deltaSampleSize: 60, counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: !1, enabled: !0 },\n              o = s.extend(t, e);return o.delta = o.delta || 1e3 / o.fps, o.deltaMin = o.deltaMin || 1e3 / o.fps, o.deltaMax = o.deltaMax || 1e3 / (.5 * o.fps), o.fps = 1e3 / o.delta, o;\n        }, n.run = function (t, o) {\n          return \"undefined\" != typeof t.positionIterations && (o = t, t = n.create()), function i(r) {\n            t.frameRequestId = e(i), r && t.enabled && n.tick(t, o, r);\n          }(), t;\n        }, n.tick = function (e, t, o) {\n          var n,\n              s = t.timing,\n              a = 1,\n              l = { timestamp: s.timestamp };i.trigger(e, \"beforeTick\", l), i.trigger(t, \"beforeTick\", l), e.isFixed ? n = e.delta : (n = o - e.timePrev || e.delta, e.timePrev = o, e.deltaHistory.push(n), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), n = Math.min.apply(null, e.deltaHistory), n = n < e.deltaMin ? e.deltaMin : n, n = n > e.deltaMax ? e.deltaMax : n, a = n / e.delta, e.delta = n), 0 !== e.timeScalePrev && (a *= s.timeScale / e.timeScalePrev), 0 === s.timeScale && (a = 0), e.timeScalePrev = s.timeScale, e.correction = a, e.frameCounter += 1, o - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((o - e.counterTimestamp) / 1e3), e.counterTimestamp = o, e.frameCounter = 0), i.trigger(e, \"tick\", l), i.trigger(t, \"tick\", l), t.world.isModified && t.render && t.render.controller && t.render.controller.clear && t.render.controller.clear(t.render), i.trigger(e, \"beforeUpdate\", l), r.update(t, n, a), i.trigger(e, \"afterUpdate\", l), t.render && t.render.controller && (i.trigger(e, \"beforeRender\", l), i.trigger(t, \"beforeRender\", l), t.render.controller.world(t.render), i.trigger(e, \"afterRender\", l), i.trigger(t, \"afterRender\", l)), i.trigger(e, \"afterTick\", l), i.trigger(t, \"afterTick\", l);\n        }, n.stop = function (e) {\n          t(e.frameRequestId);\n        }, n.start = function (e, t) {\n          n.run(e, t);\n        };\n      }();\n    }, { \"./Common\": 14, \"./Engine\": 15, \"./Events\": 16 }], 20: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"./Events\");!function () {\n        n._motionWakeThreshold = .18, n._motionSleepThreshold = .08, n._minBias = .9, n.update = function (e, t) {\n          for (var o = t * t * t, i = 0; i < e.length; i++) {\n            var r = e[i],\n                s = r.speed * r.speed + r.angularSpeed * r.angularSpeed;if (0 === r.force.x && 0 === r.force.y) {\n              var a = Math.min(r.motion, s),\n                  l = Math.max(r.motion, s);r.motion = n._minBias * a + (1 - n._minBias) * l, r.sleepThreshold > 0 && r.motion < n._motionSleepThreshold * o ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && n.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1);\n            } else n.set(r, !1);\n          }\n        }, n.afterCollisions = function (e, t) {\n          for (var o = t * t * t, i = 0; i < e.length; i++) {\n            var r = e[i];if (r.isActive) {\n              var s = r.collision,\n                  a = s.bodyA.parent,\n                  l = s.bodyB.parent;if (!(a.isSleeping && l.isSleeping || a.isStatic || l.isStatic) && (a.isSleeping || l.isSleeping)) {\n                var c = a.isSleeping && !a.isStatic ? a : l,\n                    d = c === a ? l : a;!c.isStatic && d.motion > n._motionWakeThreshold * o && n.set(c, !1);\n              }\n            }\n          }\n        }, n.set = function (e, t) {\n          var o = e.isSleeping;t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, o || i.trigger(e, \"sleepStart\")) : (e.isSleeping = !1, e.sleepCounter = 0, o && i.trigger(e, \"sleepEnd\"));\n        };\n      }();\n    }, { \"./Events\": 16 }], 21: [function (e, t, o) {\n      var n = {};\n      t.exports = n;var i = e(\"../geometry/Vertices\"),\n          r = e(\"../core/Common\"),\n          s = e(\"../body/Body\"),\n          a = e(\"../geometry/Bounds\"),\n          l = e(\"../geometry/Vector\");!function () {\n        n.rectangle = function (e, t, o, n, a) {\n          a = a || {};var l = { label: \"Rectangle Body\", position: { x: e, y: t }, vertices: i.fromPath(\"L 0 0 L \" + o + \" 0 L \" + o + \" \" + n + \" L 0 \" + n) };if (a.chamfer) {\n            var c = a.chamfer;l.vertices = i.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete a.chamfer;\n          }return s.create(r.extend({}, l, a));\n        }, n.trapezoid = function (e, t, o, n, a, l) {\n          l = l || {}, a *= .5;var c,\n              d = (1 - 2 * a) * o,\n              u = o * a,\n              p = u + d,\n              f = p + u;c = .5 > a ? \"L 0 0 L \" + u + \" \" + -n + \" L \" + p + \" \" + -n + \" L \" + f + \" 0\" : \"L 0 0 L \" + p + \" \" + -n + \" L \" + f + \" 0\";var v = { label: \"Trapezoid Body\", position: { x: e, y: t }, vertices: i.fromPath(c) };if (l.chamfer) {\n            var m = l.chamfer;v.vertices = i.chamfer(v.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete l.chamfer;\n          }return s.create(r.extend({}, v, l));\n        }, n.circle = function (e, t, o, i, s) {\n          i = i || {};var a = { label: \"Circle Body\", circleRadius: o };s = s || 25;var l = Math.ceil(Math.max(10, Math.min(s, o)));return l % 2 === 1 && (l += 1), n.polygon(e, t, l, o, r.extend({}, a, i));\n        }, n.polygon = function (e, t, o, a, l) {\n          if (l = l || {}, 3 > o) return n.circle(e, t, a, l);for (var c = 2 * Math.PI / o, d = \"\", u = .5 * c, p = 0; o > p; p += 1) {\n            var f = u + p * c,\n                v = Math.cos(f) * a,\n                m = Math.sin(f) * a;d += \"L \" + v.toFixed(3) + \" \" + m.toFixed(3) + \" \";\n          }var y = { label: \"Polygon Body\", position: { x: e, y: t }, vertices: i.fromPath(d) };if (l.chamfer) {\n            var g = l.chamfer;y.vertices = i.chamfer(y.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete l.chamfer;\n          }return s.create(r.extend({}, y, l));\n        }, n.fromVertices = function (e, t, o, n, c, d, u) {\n          var p, f, v, m, y, g, x, h, b;for (n = n || {}, f = [], c = \"undefined\" != typeof c ? c : !1, d = \"undefined\" != typeof d ? d : .01, u = \"undefined\" != typeof u ? u : 10, window.decomp || r.log(\"Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.\", \"warn\"), r.isArray(o[0]) || (o = [o]), h = 0; h < o.length; h += 1) {\n            if (m = o[h], v = i.isConvex(m), v || !window.decomp) m = v ? i.clockwiseSort(m) : i.hull(m), f.push({ position: { x: e, y: t }, vertices: m });else {\n              var w = new decomp.Polygon();for (y = 0; y < m.length; y++) {\n                w.vertices.push([m[y].x, m[y].y]);\n              }w.makeCCW(), d !== !1 && w.removeCollinearPoints(d);var S = w.quickDecomp();for (y = 0; y < S.length; y++) {\n                var C = S[y],\n                    A = [];for (g = 0; g < C.vertices.length; g++) {\n                  A.push({ x: C.vertices[g][0], y: C.vertices[g][1] });\n                }u > 0 && i.area(A) < u || f.push({ position: i.centre(A), vertices: A });\n              }\n            }\n          }for (y = 0; y < f.length; y++) {\n            f[y] = s.create(r.extend(f[y], n));\n          }if (c) {\n            var B = 5;for (y = 0; y < f.length; y++) {\n              var P = f[y];for (g = y + 1; g < f.length; g++) {\n                var M = f[g];if (a.overlaps(P.bounds, M.bounds)) {\n                  var k = P.vertices,\n                      I = M.vertices;for (x = 0; x < P.vertices.length; x++) {\n                    for (b = 0; b < M.vertices.length; b++) {\n                      var T = l.magnitudeSquared(l.sub(k[(x + 1) % k.length], I[b])),\n                          V = l.magnitudeSquared(l.sub(k[x], I[(b + 1) % I.length]));B > T && B > V && (k[x].isInternal = !0, I[b].isInternal = !0);\n                    }\n                  }\n                }\n              }\n            }\n          }return f.length > 1 ? (p = s.create(r.extend({ parts: f.slice(0) }, n)), s.setPosition(p, { x: e, y: t }), p) : f[0];\n        };\n      }();\n    }, { \"../body/Body\": 1, \"../core/Common\": 14, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27 }], 22: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../body/Composite\"),\n          r = e(\"../constraint/Constraint\"),\n          s = e(\"../core/Common\"),\n          a = e(\"../body/Body\"),\n          l = e(\"./Bodies\");\n      !function () {\n        n.stack = function (e, t, o, n, r, s, l) {\n          for (var c, d = i.create({ label: \"Stack\" }), u = e, p = t, f = 0, v = 0; n > v; v++) {\n            for (var m = 0, y = 0; o > y; y++) {\n              var g = l(u, p, y, v, c, f);if (g) {\n                var x = g.bounds.max.y - g.bounds.min.y,\n                    h = g.bounds.max.x - g.bounds.min.x;x > m && (m = x), a.translate(g, { x: .5 * h, y: .5 * x }), u = g.bounds.max.x + r, i.addBody(d, g), c = g, f += 1;\n              } else u += r;\n            }p += m + s, u = e;\n          }return d;\n        }, n.chain = function (e, t, o, n, a, l) {\n          for (var c = e.bodies, d = 1; d < c.length; d++) {\n            var u = c[d - 1],\n                p = c[d],\n                f = u.bounds.max.y - u.bounds.min.y,\n                v = u.bounds.max.x - u.bounds.min.x,\n                m = p.bounds.max.y - p.bounds.min.y,\n                y = p.bounds.max.x - p.bounds.min.x,\n                g = { bodyA: u, pointA: { x: v * t, y: f * o }, bodyB: p, pointB: { x: y * n, y: m * a } },\n                x = s.extend(g, l);i.addConstraint(e, r.create(x));\n          }return e.label += \" Chain\", e;\n        }, n.mesh = function (e, t, o, n, a) {\n          var l,\n              c,\n              d,\n              u,\n              p,\n              f = e.bodies;for (l = 0; o > l; l++) {\n            for (c = 1; t > c; c++) {\n              d = f[c - 1 + l * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({ bodyA: d, bodyB: u }, a)));\n            }if (l > 0) for (c = 0; t > c; c++) {\n              d = f[c + (l - 1) * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({ bodyA: d, bodyB: u }, a))), n && c > 0 && (p = f[c - 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({\n                bodyA: p, bodyB: u }, a)))), n && t - 1 > c && (p = f[c + 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({ bodyA: p, bodyB: u }, a))));\n            }\n          }return e.label += \" Mesh\", e;\n        }, n.pyramid = function (e, t, o, i, r, s, l) {\n          return n.stack(e, t, o, i, r, s, function (t, n, s, c, d, u) {\n            var p = Math.min(i, Math.ceil(o / 2)),\n                f = d ? d.bounds.max.x - d.bounds.min.x : 0;if (!(c > p)) {\n              c = p - c;var v = c,\n                  m = o - 1 - c;if (!(v > s || s > m)) {\n                1 === u && a.translate(d, { x: (s + (o % 2 === 1 ? 1 : -1)) * f, y: 0 });var y = d ? s * f : 0;return l(e + y + s * r, n, s, c, d, u);\n              }\n            }\n          });\n        }, n.newtonsCradle = function (e, t, o, n, s) {\n          for (var a = i.create({ label: \"Newtons Cradle\" }), c = 0; o > c; c++) {\n            var d = 1.9,\n                u = l.circle(e + c * (n * d), t + s, n, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }),\n                p = r.create({ pointA: { x: e + c * (n * d), y: t }, bodyB: u });i.addBody(a, u), i.addConstraint(a, p);\n          }return a;\n        }, n.car = function (e, t, o, n, s) {\n          var c = a.nextGroup(!0),\n              d = -20,\n              u = .5 * -o + d,\n              p = .5 * o - d,\n              f = 0,\n              v = i.create({ label: \"Car\" }),\n              m = l.trapezoid(e, t, o, n, .3, { collisionFilter: { group: c }, friction: .01, chamfer: { radius: 10 } }),\n              y = l.circle(e + u, t + f, s, { collisionFilter: { group: c }, friction: .8, density: .01 }),\n              g = l.circle(e + p, t + f, s, {\n            collisionFilter: { group: c }, friction: .8, density: .01 }),\n              x = r.create({ bodyA: m, pointA: { x: u, y: f }, bodyB: y, stiffness: .2 }),\n              h = r.create({ bodyA: m, pointA: { x: p, y: f }, bodyB: g, stiffness: .2 });return i.addBody(v, m), i.addBody(v, y), i.addBody(v, g), i.addConstraint(v, x), i.addConstraint(v, h), v;\n        }, n.softBody = function (e, t, o, i, r, a, c, d, u, p) {\n          u = s.extend({ inertia: 1 / 0 }, u), p = s.extend({ stiffness: .4 }, p);var f = n.stack(e, t, o, i, r, a, function (e, t) {\n            return l.circle(e, t, d, u);\n          });return n.mesh(f, o, i, c, p), f.label = \"Soft Body\", f;\n        };\n      }();\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../constraint/Constraint\": 12, \"../core/Common\": 14, \"./Bodies\": 21 }], 23: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vector\"),\n          r = e(\"../core/Common\");!function () {\n        n.fromVertices = function (e) {\n          for (var t = {}, o = 0; o < e.length; o++) {\n            var n = (o + 1) % e.length,\n                s = i.normalise({ x: e[n].y - e[o].y, y: e[o].x - e[n].x }),\n                a = 0 === s.y ? 1 / 0 : s.x / s.y;a = a.toFixed(3).toString(), t[a] = s;\n          }return r.values(t);\n        }, n.rotate = function (e, t) {\n          if (0 !== t) for (var o = Math.cos(t), n = Math.sin(t), i = 0; i < e.length; i++) {\n            var r,\n                s = e[i];\n            r = s.x * o - s.y * n, s.y = s.x * n + s.y * o, s.x = r;\n          }\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Vector\": 26 }], 24: [function (e, t, o) {\n      var n = {};t.exports = n, function () {\n        n.create = function (e) {\n          var t = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } };return e && n.update(t, e), t;\n        }, n.update = function (e, t, o) {\n          e.min.x = 1 / 0, e.max.x = -(1 / 0), e.min.y = 1 / 0, e.max.y = -(1 / 0);for (var n = 0; n < t.length; n++) {\n            var i = t[n];i.x > e.max.x && (e.max.x = i.x), i.x < e.min.x && (e.min.x = i.x), i.y > e.max.y && (e.max.y = i.y), i.y < e.min.y && (e.min.y = i.y);\n          }o && (o.x > 0 ? e.max.x += o.x : e.min.x += o.x, o.y > 0 ? e.max.y += o.y : e.min.y += o.y);\n        }, n.contains = function (e, t) {\n          return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y;\n        }, n.overlaps = function (e, t) {\n          return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y;\n        }, n.translate = function (e, t) {\n          e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y;\n        }, n.shift = function (e, t) {\n          var o = e.max.x - e.min.x,\n              n = e.max.y - e.min.y;e.min.x = t.x, e.max.x = t.x + o, e.min.y = t.y, e.max.y = t.y + n;\n        };\n      }();\n    }, {}], 25: [function (e, t, o) {\n      var n = {};t.exports = n;e(\"../geometry/Bounds\");!function () {\n        n.pathToVertices = function (t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a,\n              l,\n              c,\n              d,\n              u,\n              p,\n              f,\n              v,\n              m = [],\n              y = 0,\n              g = 0,\n              x = 0;o = o || 15;var h = function h(e, t, o) {\n            var n = o % 2 === 1 && o > 1;if (!u || e != u.x || t != u.y) {\n              u && n ? (f = u.x, v = u.y) : (f = 0, v = 0);var i = { x: f + e, y: v + t };!n && u || (u = i), m.push(i), g = f + e, x = v + t;\n            }\n          },\n              b = function b(e) {\n            var t = e.pathSegTypeAsLetter.toUpperCase();if (\"Z\" !== t) {\n              switch (t) {case \"M\":case \"L\":case \"T\":case \"C\":case \"S\":case \"Q\":\n                  g = e.x, x = e.y;break;case \"H\":\n                  g = e.x;break;case \"V\":\n                  x = e.y;}h(g, x, e.pathSegType);\n            }\n          };for (e(t), r = t.getTotalLength(), l = [], n = 0; n < t.pathSegList.numberOfItems; n += 1) {\n            l.push(t.pathSegList.getItem(n));\n          }for (c = l.concat(); r > y;) {\n            if (p = t.getPathSegAtLength(y), a = l[p], a != d) {\n              for (; c.length && c[0] != a;) {\n                b(c.shift());\n              }d = a;\n            }switch (a.pathSegTypeAsLetter.toUpperCase()) {case \"C\":case \"T\":case \"S\":case \"Q\":case \"A\":\n                s = t.getPointAtLength(y), h(s.x, s.y, 0);}y += o;\n          }for (n = 0, i = c.length; i > n; ++n) {\n            b(c[n]);\n          }return m;\n        };var e = function e(_e7) {\n          for (var t, o, n, i, r, s, a = _e7.pathSegList, l = 0, c = 0, d = a.numberOfItems, u = 0; d > u; ++u) {\n            var p = a.getItem(u),\n                f = p.pathSegTypeAsLetter;if (/[MLHVCSQTA]/.test(f)) \"x\" in p && (l = p.x), \"y\" in p && (c = p.y);else switch (\"x1\" in p && (n = l + p.x1), \"x2\" in p && (r = l + p.x2), \"y1\" in p && (i = c + p.y1), \"y2\" in p && (s = c + p.y2), \"x\" in p && (l += p.x), \"y\" in p && (c += p.y), f) {case \"m\":\n                a.replaceItem(_e7.createSVGPathSegMovetoAbs(l, c), u);break;case \"l\":\n                a.replaceItem(_e7.createSVGPathSegLinetoAbs(l, c), u);break;case \"h\":\n                a.replaceItem(_e7.createSVGPathSegLinetoHorizontalAbs(l), u);break;case \"v\":\n                a.replaceItem(_e7.createSVGPathSegLinetoVerticalAbs(c), u);break;case \"c\":\n                a.replaceItem(_e7.createSVGPathSegCurvetoCubicAbs(l, c, n, i, r, s), u);break;case \"s\":\n                a.replaceItem(_e7.createSVGPathSegCurvetoCubicSmoothAbs(l, c, r, s), u);break;case \"q\":\n                a.replaceItem(_e7.createSVGPathSegCurvetoQuadraticAbs(l, c, n, i), u);break;case \"t\":\n                a.replaceItem(_e7.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), u);break;case \"a\":\n                a.replaceItem(_e7.createSVGPathSegArcAbs(l, c, p.r1, p.r2, p.angle, p.largeArcFlag, p.sweepFlag), u);break;case \"z\":case \"Z\":\n                l = t, c = o;}\"M\" != f && \"m\" != f || (t = l, o = c);\n          }\n        };\n      }();\n    }, { \"../geometry/Bounds\": 24 }], 26: [function (e, t, o) {\n      var n = {};t.exports = n, function () {\n        n.create = function (e, t) {\n          return { x: e || 0, y: t || 0 };\n        }, n.clone = function (e) {\n          return {\n            x: e.x, y: e.y };\n        }, n.magnitude = function (e) {\n          return Math.sqrt(e.x * e.x + e.y * e.y);\n        }, n.magnitudeSquared = function (e) {\n          return e.x * e.x + e.y * e.y;\n        }, n.rotate = function (e, t) {\n          var o = Math.cos(t),\n              n = Math.sin(t);return { x: e.x * o - e.y * n, y: e.x * n + e.y * o };\n        }, n.rotateAbout = function (e, t, o, n) {\n          var i = Math.cos(t),\n              r = Math.sin(t);n || (n = {});var s = o.x + ((e.x - o.x) * i - (e.y - o.y) * r);return n.y = o.y + ((e.x - o.x) * r + (e.y - o.y) * i), n.x = s, n;\n        }, n.normalise = function (e) {\n          var t = n.magnitude(e);return 0 === t ? { x: 0, y: 0 } : { x: e.x / t, y: e.y / t };\n        }, n.dot = function (e, t) {\n          return e.x * t.x + e.y * t.y;\n        }, n.cross = function (e, t) {\n          return e.x * t.y - e.y * t.x;\n        }, n.cross3 = function (e, t, o) {\n          return (t.x - e.x) * (o.y - e.y) - (t.y - e.y) * (o.x - e.x);\n        }, n.add = function (e, t, o) {\n          return o || (o = {}), o.x = e.x + t.x, o.y = e.y + t.y, o;\n        }, n.sub = function (e, t, o) {\n          return o || (o = {}), o.x = e.x - t.x, o.y = e.y - t.y, o;\n        }, n.mult = function (e, t) {\n          return { x: e.x * t, y: e.y * t };\n        }, n.div = function (e, t) {\n          return { x: e.x / t, y: e.y / t };\n        }, n.perp = function (e, t) {\n          return t = t === !0 ? -1 : 1, { x: t * -e.y, y: t * e.x };\n        }, n.neg = function (e) {\n          return { x: -e.x, y: -e.y };\n        }, n.angle = function (e, t) {\n          return Math.atan2(t.y - e.y, t.x - e.x);\n        }, n._temp = [n.create(), n.create(), n.create(), n.create(), n.create(), n.create()];\n      }();\n    }, {}], 27: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../geometry/Vector\"),\n          r = e(\"../core/Common\");!function () {\n        n.create = function (e, t) {\n          for (var o = [], n = 0; n < e.length; n++) {\n            var i = e[n],\n                r = { x: i.x, y: i.y, index: n, body: t, isInternal: !1 };o.push(r);\n          }return o;\n        }, n.fromPath = function (e, t) {\n          var o = /L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/gi,\n              i = [];return e.replace(o, function (e, t, o) {\n            i.push({ x: parseFloat(t), y: parseFloat(o) });\n          }), n.create(i, t);\n        }, n.centre = function (e) {\n          for (var t, o, r, s = n.area(e, !0), a = { x: 0, y: 0 }, l = 0; l < e.length; l++) {\n            r = (l + 1) % e.length, t = i.cross(e[l], e[r]), o = i.mult(i.add(e[l], e[r]), t), a = i.add(a, o);\n          }return i.div(a, 6 * s);\n        }, n.mean = function (e) {\n          for (var t = { x: 0, y: 0 }, o = 0; o < e.length; o++) {\n            t.x += e[o].x, t.y += e[o].y;\n          }return i.div(t, e.length);\n        }, n.area = function (e, t) {\n          for (var o = 0, n = e.length - 1, i = 0; i < e.length; i++) {\n            o += (e[n].x - e[i].x) * (e[n].y + e[i].y), n = i;\n          }return t ? o / 2 : Math.abs(o) / 2;\n        }, n.inertia = function (e, t) {\n          for (var o, n, r = 0, s = 0, a = e, l = 0; l < a.length; l++) {\n            n = (l + 1) % a.length, o = Math.abs(i.cross(a[n], a[l])), r += o * (i.dot(a[n], a[n]) + i.dot(a[n], a[l]) + i.dot(a[l], a[l])), s += o;\n          }return t / 6 * (r / s);\n        }, n.translate = function (e, t, o) {\n          var n;if (o) for (n = 0; n < e.length; n++) {\n            e[n].x += t.x * o, e[n].y += t.y * o;\n          } else for (n = 0; n < e.length; n++) {\n            e[n].x += t.x, e[n].y += t.y;\n          }return e;\n        }, n.rotate = function (e, t, o) {\n          if (0 !== t) {\n            for (var n = Math.cos(t), i = Math.sin(t), r = 0; r < e.length; r++) {\n              var s = e[r],\n                  a = s.x - o.x,\n                  l = s.y - o.y;s.x = o.x + (a * n - l * i), s.y = o.y + (a * i + l * n);\n            }return e;\n          }\n        }, n.contains = function (e, t) {\n          for (var o = 0; o < e.length; o++) {\n            var n = e[o],\n                i = e[(o + 1) % e.length];if ((t.x - n.x) * (i.y - n.y) + (t.y - n.y) * (n.x - i.x) > 0) return !1;\n          }return !0;\n        }, n.scale = function (e, t, o, r) {\n          if (1 === t && 1 === o) return e;r = r || n.centre(e);for (var s, a, l = 0; l < e.length; l++) {\n            s = e[l], a = i.sub(s, r), e[l].x = r.x + a.x * t, e[l].y = r.y + a.y * o;\n          }return e;\n        }, n.chamfer = function (e, t, o, n, s) {\n          t = t || [8], t.length || (t = [t]), o = \"undefined\" != typeof o ? o : -1, n = n || 2, s = s || 14;for (var a = [], l = 0; l < e.length; l++) {\n            var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],\n                d = e[l],\n                u = e[(l + 1) % e.length],\n                p = t[l < t.length ? l : t.length - 1];if (0 !== p) {\n              var f = i.normalise({ x: d.y - c.y, y: c.x - d.x }),\n                  v = i.normalise({ x: u.y - d.y,\n                y: d.x - u.x }),\n                  m = Math.sqrt(2 * Math.pow(p, 2)),\n                  y = i.mult(r.clone(f), p),\n                  g = i.normalise(i.mult(i.add(f, v), .5)),\n                  x = i.sub(d, i.mult(g, m)),\n                  h = o;-1 === o && (h = 1.75 * Math.pow(p, .32)), h = r.clamp(h, n, s), h % 2 === 1 && (h += 1);for (var b = Math.acos(i.dot(f, v)), w = b / h, S = 0; h > S; S++) {\n                a.push(i.add(i.rotate(y, w * S), x));\n              }\n            } else a.push(d);\n          }return a;\n        }, n.clockwiseSort = function (e) {\n          var t = n.mean(e);return e.sort(function (e, o) {\n            return i.angle(t, e) - i.angle(t, o);\n          }), e;\n        }, n.isConvex = function (e) {\n          var t,\n              o,\n              n,\n              i,\n              r = 0,\n              s = e.length;if (3 > s) return null;for (t = 0; s > t; t++) {\n            if (o = (t + 1) % s, n = (t + 2) % s, i = (e[o].x - e[t].x) * (e[n].y - e[o].y), i -= (e[o].y - e[t].y) * (e[n].x - e[o].x), 0 > i ? r |= 1 : i > 0 && (r |= 2), 3 === r) return !1;\n          }return 0 !== r ? !0 : null;\n        }, n.hull = function (e) {\n          var t,\n              o,\n              n = [],\n              r = [];for (e = e.slice(0), e.sort(function (e, t) {\n            var o = e.x - t.x;return 0 !== o ? o : e.y - t.y;\n          }), o = 0; o < e.length; o++) {\n            for (t = e[o]; r.length >= 2 && i.cross3(r[r.length - 2], r[r.length - 1], t) <= 0;) {\n              r.pop();\n            }r.push(t);\n          }for (o = e.length - 1; o >= 0; o--) {\n            for (t = e[o]; n.length >= 2 && i.cross3(n[n.length - 2], n[n.length - 1], t) <= 0;) {\n              n.pop();\n            }n.push(t);\n          }return n.pop(), r.pop(), n.concat(r);\n        };\n      }();\n    }, { \"../core/Common\": 14, \"../geometry/Vector\": 26 }], 28: [function (e, t, o) {\n      var n = t.exports = {};n.version = \"master\", n.Body = e(\"../body/Body\"), n.Composite = e(\"../body/Composite\"), n.World = e(\"../body/World\"), n.Contact = e(\"../collision/Contact\"), n.Detector = e(\"../collision/Detector\"), n.Grid = e(\"../collision/Grid\"), n.Pairs = e(\"../collision/Pairs\"), n.Pair = e(\"../collision/Pair\"), n.Query = e(\"../collision/Query\"), n.Resolver = e(\"../collision/Resolver\"), n.SAT = e(\"../collision/SAT\"), n.Constraint = e(\"../constraint/Constraint\"), n.MouseConstraint = e(\"../constraint/MouseConstraint\"), n.Common = e(\"../core/Common\"), n.Engine = e(\"../core/Engine\"), n.Events = e(\"../core/Events\"), n.Mouse = e(\"../core/Mouse\"), n.Runner = e(\"../core/Runner\"), n.Sleeping = e(\"../core/Sleeping\"), n.Bodies = e(\"../factory/Bodies\"), n.Composites = e(\"../factory/Composites\"), n.Axes = e(\"../geometry/Axes\"), n.Bounds = e(\"../geometry/Bounds\"), n.Svg = e(\"../geometry/Svg\"), n.Vector = e(\"../geometry/Vector\"), n.Vertices = e(\"../geometry/Vertices\"), n.Render = e(\"../render/Render\"), n.RenderPixi = e(\"../render/RenderPixi\"), n.World.add = n.Composite.add, n.World.remove = n.Composite.remove, n.World.addComposite = n.Composite.addComposite, n.World.addBody = n.Composite.addBody, n.World.addConstraint = n.Composite.addConstraint, n.World.clear = n.Composite.clear, n.Engine.run = n.Runner.run;\n    }, { \"../body/Body\": 1, \"../body/Composite\": 2, \"../body/World\": 3, \"../collision/Contact\": 4, \"../collision/Detector\": 5, \"../collision/Grid\": 6, \"../collision/Pair\": 7, \"../collision/Pairs\": 8, \"../collision/Query\": 9, \"../collision/Resolver\": 10, \"../collision/SAT\": 11, \"../constraint/Constraint\": 12, \"../constraint/MouseConstraint\": 13, \"../core/Common\": 14, \"../core/Engine\": 15, \"../core/Events\": 16, \"../core/Metrics\": 17, \"../core/Mouse\": 18, \"../core/Runner\": 19, \"../core/Sleeping\": 20, \"../factory/Bodies\": 21, \"../factory/Composites\": 22, \"../geometry/Axes\": 23, \"../geometry/Bounds\": 24, \"../geometry/Svg\": 25, \"../geometry/Vector\": 26, \"../geometry/Vertices\": 27, \"../render/Render\": 29, \"../render/RenderPixi\": 30 }], 29: [function (e, t, o) {\n      var n = {};t.exports = n;\n      var i = e(\"../core/Common\"),\n          r = e(\"../body/Composite\"),\n          s = e(\"../geometry/Bounds\"),\n          a = e(\"../core/Events\"),\n          l = e(\"../collision/Grid\"),\n          c = e(\"../geometry/Vector\");!function () {\n        var e, t;\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          window.setTimeout(function () {\n            e(i.now());\n          }, 1e3 / 60);\n        }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), n.create = function (e) {\n          var t = { controller: n, engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, options: { width: 800, height: 600, pixelRatio: 1, background: \"#fafafa\", wireframeBackground: \"#222\", hasBounds: !!e.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1,\n              showMousePosition: !1 } },\n              r = i.extend(t, e);return r.canvas && (r.canvas.width = r.options.width || r.canvas.width, r.canvas.height = r.options.height || r.canvas.height), r.mouse = e.mouse, r.engine = e.engine, r.canvas = r.canvas || o(r.options.width, r.options.height), r.context = r.canvas.getContext(\"2d\"), r.textures = {}, r.bounds = r.bounds || { min: { x: 0, y: 0 }, max: { x: r.canvas.width, y: r.canvas.height } }, 1 !== r.options.pixelRatio && n.setPixelRatio(r, r.options.pixelRatio), i.isElement(r.element) ? r.element.appendChild(r.canvas) : i.log(\"Render.create: options.element was undefined, render.canvas was created but not appended\", \"warn\"), r;\n        }, n.run = function (t) {\n          !function o(i) {\n            t.frameRequestId = e(o), n.world(t);\n          }();\n        }, n.stop = function (e) {\n          t(e.frameRequestId);\n        }, n.setPixelRatio = function (e, t) {\n          var o = e.options,\n              n = e.canvas;\"auto\" === t && (t = d(n)), o.pixelRatio = t, n.setAttribute(\"data-pixel-ratio\", t), n.width = o.width * t, n.height = o.height * t, n.style.width = o.width + \"px\", n.style.height = o.height + \"px\", e.context.scale(t, t);\n        }, n.world = function (e) {\n          var t,\n              o = e.engine,\n              i = o.world,\n              d = e.canvas,\n              u = e.context,\n              f = e.options,\n              v = r.allBodies(i),\n              m = r.allConstraints(i),\n              y = f.wireframes ? f.wireframeBackground : f.background,\n              g = [],\n              x = [],\n              h = {\n            timestamp: o.timing.timestamp };if (a.trigger(e, \"beforeRender\", h), e.currentBackground !== y && p(e, y), u.globalCompositeOperation = \"source-in\", u.fillStyle = \"transparent\", u.fillRect(0, 0, d.width, d.height), u.globalCompositeOperation = \"source-over\", f.hasBounds) {\n            var b = e.bounds.max.x - e.bounds.min.x,\n                w = e.bounds.max.y - e.bounds.min.y,\n                S = b / f.width,\n                C = w / f.height;for (t = 0; t < v.length; t++) {\n              var A = v[t];s.overlaps(A.bounds, e.bounds) && g.push(A);\n            }for (t = 0; t < m.length; t++) {\n              var B = m[t],\n                  P = B.bodyA,\n                  M = B.bodyB,\n                  k = B.pointA,\n                  I = B.pointB;P && (k = c.add(P.position, B.pointA)), M && (I = c.add(M.position, B.pointB)), k && I && (s.contains(e.bounds, k) || s.contains(e.bounds, I)) && x.push(B);\n            }u.scale(1 / S, 1 / C), u.translate(-e.bounds.min.x, -e.bounds.min.y);\n          } else x = m, g = v;!f.wireframes || o.enableSleeping && f.showSleeping ? n.bodies(e, g, u) : (f.showConvexHulls && n.bodyConvexHulls(e, g, u), n.bodyWireframes(e, g, u)), f.showBounds && n.bodyBounds(e, g, u), (f.showAxes || f.showAngleIndicator) && n.bodyAxes(e, g, u), f.showPositions && n.bodyPositions(e, g, u), f.showVelocity && n.bodyVelocity(e, g, u), f.showIds && n.bodyIds(e, g, u), f.showSeparations && n.separations(e, o.pairs.list, u), f.showCollisions && n.collisions(e, o.pairs.list, u), f.showVertexNumbers && n.vertexNumbers(e, g, u), f.showMousePosition && n.mousePosition(e, e.mouse, u), n.constraints(x, u), f.showBroadphase && o.broadphase.controller === l && n.grid(e, o.broadphase, u), f.showDebug && n.debug(e, u), f.hasBounds && u.setTransform(f.pixelRatio, 0, 0, f.pixelRatio, 0, 0), a.trigger(e, \"afterRender\", h);\n        }, n.debug = function (e, t) {\n          var o = t,\n              n = e.engine,\n              i = n.world,\n              s = n.metrics,\n              a = e.options,\n              l = (r.allBodies(i), \"    \");if (n.timing.timestamp - (e.debugTimestamp || 0) >= 500) {\n            var c = \"\";s.timing && (c += \"fps: \" + Math.round(s.timing.fps) + l), e.debugString = c, e.debugTimestamp = n.timing.timestamp;\n          }if (e.debugString) {\n            o.font = \"12px Arial\", a.wireframes ? o.fillStyle = \"rgba(255,255,255,0.5)\" : o.fillStyle = \"rgba(0,0,0,0.5)\";for (var d = e.debugString.split(\"\\n\"), u = 0; u < d.length; u++) {\n              o.fillText(d[u], 50, 50 + 18 * u);\n            }\n          }\n        }, n.constraints = function (e, t) {\n          for (var o = t, n = 0; n < e.length; n++) {\n            var i = e[n];if (i.render.visible && i.pointA && i.pointB) {\n              var r = i.bodyA,\n                  s = i.bodyB;r ? (o.beginPath(), o.moveTo(r.position.x + i.pointA.x, r.position.y + i.pointA.y)) : (o.beginPath(), o.moveTo(i.pointA.x, i.pointA.y)), s ? o.lineTo(s.position.x + i.pointB.x, s.position.y + i.pointB.y) : o.lineTo(i.pointB.x, i.pointB.y), o.lineWidth = i.render.lineWidth, o.strokeStyle = i.render.strokeStyle, o.stroke();\n            }\n          }\n        }, n.bodyShadows = function (e, t, o) {\n          for (var n = o, i = (e.engine, 0); i < t.length; i++) {\n            var r = t[i];if (r.render.visible) {\n              if (r.circleRadius) n.beginPath(), n.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI), n.closePath();else {\n                n.beginPath(), n.moveTo(r.vertices[0].x, r.vertices[0].y);for (var s = 1; s < r.vertices.length; s++) {\n                  n.lineTo(r.vertices[s].x, r.vertices[s].y);\n                }n.closePath();\n              }var a = r.position.x - .5 * e.options.width,\n                  l = r.position.y - .2 * e.options.height,\n                  c = Math.abs(a) + Math.abs(l);n.shadowColor = \"rgba(0,0,0,0.15)\", n.shadowOffsetX = .05 * a, n.shadowOffsetY = .05 * l, n.shadowBlur = 1 + 12 * Math.min(1, c / 1e3), n.fill(), n.shadowColor = null, n.shadowOffsetX = null, n.shadowOffsetY = null, n.shadowBlur = null;\n            }\n          }\n        }, n.bodies = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a = o,\n              l = (e.engine, e.options),\n              c = l.showInternalEdges || !l.wireframes;for (r = 0; r < t.length; r++) {\n            if (n = t[r], n.render.visible) for (s = n.parts.length > 1 ? 1 : 0; s < n.parts.length; s++) {\n              if (i = n.parts[s], i.render.visible) {\n                if (l.showSleeping && n.isSleeping ? a.globalAlpha = .5 * i.render.opacity : 1 !== i.render.opacity && (a.globalAlpha = i.render.opacity), i.render.sprite && i.render.sprite.texture && !l.wireframes) {\n                  var d = i.render.sprite,\n                      p = u(e, d.texture);a.translate(i.position.x, i.position.y), a.rotate(i.angle), a.drawImage(p, p.width * -d.xOffset * d.xScale, p.height * -d.yOffset * d.yScale, p.width * d.xScale, p.height * d.yScale), a.rotate(-i.angle), a.translate(-i.position.x, -i.position.y);\n                } else {\n                  if (i.circleRadius) a.beginPath(), a.arc(i.position.x, i.position.y, i.circleRadius, 0, 2 * Math.PI);else {\n                    a.beginPath(), a.moveTo(i.vertices[0].x, i.vertices[0].y);for (var f = 1; f < i.vertices.length; f++) {\n                      !i.vertices[f - 1].isInternal || c ? a.lineTo(i.vertices[f].x, i.vertices[f].y) : a.moveTo(i.vertices[f].x, i.vertices[f].y), i.vertices[f].isInternal && !c && a.moveTo(i.vertices[(f + 1) % i.vertices.length].x, i.vertices[(f + 1) % i.vertices.length].y);\n                    }a.lineTo(i.vertices[0].x, i.vertices[0].y), a.closePath();\n                  }l.wireframes ? (a.lineWidth = 1, a.strokeStyle = \"#bbb\") : (a.fillStyle = i.render.fillStyle, a.lineWidth = i.render.lineWidth, a.strokeStyle = i.render.strokeStyle, a.fill()), a.stroke();\n                }a.globalAlpha = 1;\n              }\n            }\n          }\n        }, n.bodyWireframes = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a,\n              l = o,\n              c = e.options.showInternalEdges;for (l.beginPath(), r = 0; r < t.length; r++) {\n            if (n = t[r], n.render.visible) for (a = n.parts.length > 1 ? 1 : 0; a < n.parts.length; a++) {\n              for (i = n.parts[a], l.moveTo(i.vertices[0].x, i.vertices[0].y), s = 1; s < i.vertices.length; s++) {\n                !i.vertices[s - 1].isInternal || c ? l.lineTo(i.vertices[s].x, i.vertices[s].y) : l.moveTo(i.vertices[s].x, i.vertices[s].y), i.vertices[s].isInternal && !c && l.moveTo(i.vertices[(s + 1) % i.vertices.length].x, i.vertices[(s + 1) % i.vertices.length].y);\n              }l.lineTo(i.vertices[0].x, i.vertices[0].y);\n            }\n          }l.lineWidth = 1, l.strokeStyle = \"#bbb\", l.stroke();\n        }, n.bodyConvexHulls = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s = o;for (s.beginPath(), i = 0; i < t.length; i++) {\n            if (n = t[i], n.render.visible && 1 !== n.parts.length) {\n              for (s.moveTo(n.vertices[0].x, n.vertices[0].y), r = 1; r < n.vertices.length; r++) {\n                s.lineTo(n.vertices[r].x, n.vertices[r].y);\n              }s.lineTo(n.vertices[0].x, n.vertices[0].y);\n            }\n          }s.lineWidth = 1, s.strokeStyle = \"rgba(255,255,255,0.2)\", s.stroke();\n        }, n.vertexNumbers = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s = o;for (n = 0; n < t.length; n++) {\n            var a = t[n].parts;for (r = a.length > 1 ? 1 : 0; r < a.length; r++) {\n              var l = a[r];for (i = 0; i < l.vertices.length; i++) {\n                s.fillStyle = \"rgba(255,255,255,0.2)\", s.fillText(n + \"_\" + i, l.position.x + .8 * (l.vertices[i].x - l.position.x), l.position.y + .8 * (l.vertices[i].y - l.position.y));\n              }\n            }\n          }\n        }, n.mousePosition = function (e, t, o) {\n          var n = o;n.fillStyle = \"rgba(255,255,255,0.8)\", n.fillText(t.position.x + \"  \" + t.position.y, t.position.x + 5, t.position.y - 5);\n        }, n.bodyBounds = function (e, t, o) {\n          var n = o,\n              i = (e.engine, e.options);n.beginPath();for (var r = 0; r < t.length; r++) {\n            var s = t[r];if (s.render.visible) for (var a = t[r].parts, l = a.length > 1 ? 1 : 0; l < a.length; l++) {\n              var c = a[l];n.rect(c.bounds.min.x, c.bounds.min.y, c.bounds.max.x - c.bounds.min.x, c.bounds.max.y - c.bounds.min.y);\n            }\n          }i.wireframes ? n.strokeStyle = \"rgba(255,255,255,0.08)\" : n.strokeStyle = \"rgba(0,0,0,0.1)\", n.lineWidth = 1, n.stroke();\n        }, n.bodyAxes = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a = o,\n              l = (e.engine, e.options);for (a.beginPath(), i = 0; i < t.length; i++) {\n            var c = t[i],\n                d = c.parts;if (c.render.visible) if (l.showAxes) for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {\n              for (n = d[r], s = 0; s < n.axes.length; s++) {\n                var u = n.axes[s];a.moveTo(n.position.x, n.position.y), a.lineTo(n.position.x + 20 * u.x, n.position.y + 20 * u.y);\n              }\n            } else for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {\n              for (n = d[r], s = 0; s < n.axes.length; s++) {\n                a.moveTo(n.position.x, n.position.y), a.lineTo((n.vertices[0].x + n.vertices[n.vertices.length - 1].x) / 2, (n.vertices[0].y + n.vertices[n.vertices.length - 1].y) / 2);\n              }\n            }\n          }l.wireframes ? a.strokeStyle = \"indianred\" : (a.strokeStyle = \"rgba(0,0,0,0.8)\", a.globalCompositeOperation = \"overlay\"), a.lineWidth = 1, a.stroke(), a.globalCompositeOperation = \"source-over\";\n        }, n.bodyPositions = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a = o,\n              l = (e.engine, e.options);for (a.beginPath(), r = 0; r < t.length; r++) {\n            if (n = t[r], n.render.visible) for (s = 0; s < n.parts.length; s++) {\n              i = n.parts[s], a.arc(i.position.x, i.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();\n            }\n          }for (l.wireframes ? a.fillStyle = \"indianred\" : a.fillStyle = \"rgba(0,0,0,0.5)\", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {\n            n = t[r], n.render.visible && (a.arc(n.positionPrev.x, n.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());\n          }a.fillStyle = \"rgba(255,165,0,0.8)\", a.fill();\n        }, n.bodyVelocity = function (e, t, o) {\n          var n = o;n.beginPath();for (var i = 0; i < t.length; i++) {\n            var r = t[i];r.render.visible && (n.moveTo(r.position.x, r.position.y), n.lineTo(r.position.x + 2 * (r.position.x - r.positionPrev.x), r.position.y + 2 * (r.position.y - r.positionPrev.y)));\n          }n.lineWidth = 3, n.strokeStyle = \"cornflowerblue\", n.stroke();\n        }, n.bodyIds = function (e, t, o) {\n          var n,\n              i,\n              r = o;for (n = 0; n < t.length; n++) {\n            if (t[n].render.visible) {\n              var s = t[n].parts;for (i = s.length > 1 ? 1 : 0; i < s.length; i++) {\n                var a = s[i];r.font = \"12px Arial\", r.fillStyle = \"rgba(255,255,255,0.5)\", r.fillText(a.id, a.position.x + 10, a.position.y - 10);\n              }\n            }\n          }\n        }, n.collisions = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a = o,\n              l = e.options;for (a.beginPath(), r = 0; r < t.length; r++) {\n            if (n = t[r], n.isActive) for (i = n.collision, s = 0; s < n.activeContacts.length; s++) {\n              var c = n.activeContacts[s],\n                  d = c.vertex;\n              a.rect(d.x - 1.5, d.y - 1.5, 3.5, 3.5);\n            }\n          }for (l.wireframes ? a.fillStyle = \"rgba(255,255,255,0.7)\" : a.fillStyle = \"orange\", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {\n            if (n = t[r], n.isActive && (i = n.collision, n.activeContacts.length > 0)) {\n              var u = n.activeContacts[0].vertex.x,\n                  p = n.activeContacts[0].vertex.y;2 === n.activeContacts.length && (u = (n.activeContacts[0].vertex.x + n.activeContacts[1].vertex.x) / 2, p = (n.activeContacts[0].vertex.y + n.activeContacts[1].vertex.y) / 2), i.bodyB === i.supports[0].body || i.bodyA.isStatic === !0 ? a.moveTo(u - 8 * i.normal.x, p - 8 * i.normal.y) : a.moveTo(u + 8 * i.normal.x, p + 8 * i.normal.y), a.lineTo(u, p);\n            }\n          }l.wireframes ? a.strokeStyle = \"rgba(255,165,0,0.7)\" : a.strokeStyle = \"orange\", a.lineWidth = 1, a.stroke();\n        }, n.separations = function (e, t, o) {\n          var n,\n              i,\n              r,\n              s,\n              a,\n              l = o,\n              c = e.options;for (l.beginPath(), a = 0; a < t.length; a++) {\n            if (n = t[a], n.isActive) {\n              i = n.collision, r = i.bodyA, s = i.bodyB;var d = 1;s.isStatic || r.isStatic || (d = .5), s.isStatic && (d = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x - i.penetration.x * d, s.position.y - i.penetration.y * d), d = 1, s.isStatic || r.isStatic || (d = .5), r.isStatic && (d = 0), l.moveTo(r.position.x, r.position.y), l.lineTo(r.position.x + i.penetration.x * d, r.position.y + i.penetration.y * d);\n            }\n          }c.wireframes ? l.strokeStyle = \"rgba(255,165,0,0.5)\" : l.strokeStyle = \"orange\", l.stroke();\n        }, n.grid = function (e, t, o) {\n          var n = o,\n              r = e.options;r.wireframes ? n.strokeStyle = \"rgba(255,180,0,0.1)\" : n.strokeStyle = \"rgba(255,180,0,0.5)\", n.beginPath();for (var s = i.keys(t.buckets), a = 0; a < s.length; a++) {\n            var l = s[a];if (!(t.buckets[l].length < 2)) {\n              var c = l.split(\",\");n.rect(.5 + parseInt(c[0], 10) * t.bucketWidth, .5 + parseInt(c[1], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight);\n            }\n          }n.lineWidth = 1, n.stroke();\n        }, n.inspector = function (e, t) {\n          var o,\n              n = (e.engine, e.selected),\n              i = e.render,\n              r = i.options;if (r.hasBounds) {\n            var s = i.bounds.max.x - i.bounds.min.x,\n                a = i.bounds.max.y - i.bounds.min.y,\n                l = s / i.options.width,\n                c = a / i.options.height;t.scale(1 / l, 1 / c), t.translate(-i.bounds.min.x, -i.bounds.min.y);\n          }for (var d = 0; d < n.length; d++) {\n            var u = n[d].data;switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = \"rgba(255,165,0,0.9)\", t.setLineDash([1, 2]), u.type) {case \"body\":\n                o = u.bounds, t.beginPath(), t.rect(Math.floor(o.min.x - 3), Math.floor(o.min.y - 3), Math.floor(o.max.x - o.min.x + 6), Math.floor(o.max.y - o.min.y + 6)), t.closePath(), t.stroke();break;case \"constraint\":\n                var p = u.pointA;u.bodyA && (p = u.pointB), t.beginPath(), t.arc(p.x, p.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke();}t.setLineDash([]), t.translate(-.5, -.5);\n          }null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = \"rgba(255,165,0,0.6)\", t.fillStyle = \"rgba(255,165,0,0.1)\", o = e.selectBounds, t.beginPath(), t.rect(Math.floor(o.min.x), Math.floor(o.min.y), Math.floor(o.max.x - o.min.x), Math.floor(o.max.y - o.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), r.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0);\n        };var o = function o(e, t) {\n          var o = document.createElement(\"canvas\");return o.width = e, o.height = t, o.oncontextmenu = function () {\n            return !1;\n          }, o.onselectstart = function () {\n            return !1;\n          }, o;\n        },\n            d = function d(e) {\n          var t = e.getContext(\"2d\"),\n              o = window.devicePixelRatio || 1,\n              n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;\n          return o / n;\n        },\n            u = function u(e, t) {\n          var o = e.textures[t];return o ? o : (o = e.textures[t] = new Image(), o.src = t, o);\n        },\n            p = function p(e, t) {\n          var o = t;/(jpg|gif|png)$/.test(t) && (o = \"url(\" + t + \")\"), e.canvas.style.background = o, e.canvas.style.backgroundSize = \"contain\", e.currentBackground = t;\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../collision/Grid\": 6, \"../core/Common\": 14, \"../core/Events\": 16, \"../geometry/Bounds\": 24, \"../geometry/Vector\": 26 }], 30: [function (e, t, o) {\n      var n = {};t.exports = n;var i = e(\"../body/Composite\"),\n          r = e(\"../core/Common\");!function () {\n        var e, t;\"undefined\" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          window.setTimeout(function () {\n            e(r.now());\n          }, 1e3 / 60);\n        }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), n.create = function (e) {\n          r.log(\"RenderPixi.create: Matter.RenderPixi is deprecated (see docs)\", \"warn\");var t = { controller: n, engine: null, element: null,\n            frameRequestId: null, canvas: null, renderer: null, container: null, spriteContainer: null, pixiOptions: null, options: { width: 800, height: 600, background: \"#fafafa\", wireframeBackground: \"#222\", hasBounds: !1, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1 } },\n              o = r.extend(t, e),\n              i = !o.options.wireframes && \"transparent\" === o.options.background;return o.pixiOptions = o.pixiOptions || { view: o.canvas, transparent: i, antialias: !0, backgroundColor: e.background }, o.mouse = e.mouse, o.engine = e.engine, o.renderer = o.renderer || new PIXI.WebGLRenderer(o.options.width, o.options.height, o.pixiOptions), o.container = o.container || new PIXI.Container(), o.spriteContainer = o.spriteContainer || new PIXI.Container(), o.canvas = o.canvas || o.renderer.view, o.bounds = o.bounds || { min: { x: 0, y: 0 }, max: { x: o.options.width, y: o.options.height } }, o.textures = {}, o.sprites = {}, o.primitives = {}, o.container.addChild(o.spriteContainer), r.isElement(o.element) ? o.element.appendChild(o.canvas) : r.log('No \"render.element\" passed, \"render.canvas\" was not inserted into document.', \"warn\"), o.canvas.oncontextmenu = function () {\n            return !1;\n          }, o.canvas.onselectstart = function () {\n            return !1;\n          }, o;\n        }, n.run = function (t) {\n          !function o(i) {\n            t.frameRequestId = e(o), n.world(t);\n          }();\n        }, n.stop = function (e) {\n          t(e.frameRequestId);\n        }, n.clear = function (e) {\n          for (var t = e.container, o = e.spriteContainer; t.children[0];) {\n            t.removeChild(t.children[0]);\n          }for (; o.children[0];) {\n            o.removeChild(o.children[0]);\n          }var n = e.sprites[\"bg-0\"];e.textures = {}, e.sprites = {}, e.primitives = {}, e.sprites[\"bg-0\"] = n, n && t.addChildAt(n, 0), e.container.addChild(e.spriteContainer), e.currentBackground = null, t.scale.set(1, 1), t.position.set(0, 0);\n        }, n.setBackground = function (e, t) {\n          if (e.currentBackground !== t) {\n            var o = t.indexOf && -1 !== t.indexOf(\"#\"),\n                n = e.sprites[\"bg-0\"];if (o) {\n              var i = r.colorToNumber(t);e.renderer.backgroundColor = i, n && e.container.removeChild(n);\n            } else if (!n) {\n              var s = a(e, t);n = e.sprites[\"bg-0\"] = new PIXI.Sprite(s), n.position.x = 0, n.position.y = 0, e.container.addChildAt(n, 0);\n            }e.currentBackground = t;\n          }\n        }, n.world = function (e) {\n          var t,\n              o = e.engine,\n              r = o.world,\n              s = e.renderer,\n              a = e.container,\n              l = e.options,\n              c = i.allBodies(r),\n              d = i.allConstraints(r),\n              u = [];\n          l.wireframes ? n.setBackground(e, l.wireframeBackground) : n.setBackground(e, l.background);var p = e.bounds.max.x - e.bounds.min.x,\n              f = e.bounds.max.y - e.bounds.min.y,\n              v = p / e.options.width,\n              m = f / e.options.height;if (l.hasBounds) {\n            for (t = 0; t < c.length; t++) {\n              var y = c[t];y.render.sprite.visible = Bounds.overlaps(y.bounds, e.bounds);\n            }for (t = 0; t < d.length; t++) {\n              var g = d[t],\n                  x = g.bodyA,\n                  h = g.bodyB,\n                  b = g.pointA,\n                  w = g.pointB;x && (b = Vector.add(x.position, g.pointA)), h && (w = Vector.add(h.position, g.pointB)), b && w && (Bounds.contains(e.bounds, b) || Bounds.contains(e.bounds, w)) && u.push(g);\n            }a.scale.set(1 / v, 1 / m), a.position.set(-e.bounds.min.x * (1 / v), -e.bounds.min.y * (1 / m));\n          } else u = d;for (t = 0; t < c.length; t++) {\n            n.body(e, c[t]);\n          }for (t = 0; t < u.length; t++) {\n            n.constraint(e, u[t]);\n          }s.render(a);\n        }, n.constraint = function (e, t) {\n          var o = (e.engine, t.bodyA),\n              n = t.bodyB,\n              i = t.pointA,\n              s = t.pointB,\n              a = e.container,\n              l = t.render,\n              c = \"c-\" + t.id,\n              d = e.primitives[c];return d || (d = e.primitives[c] = new PIXI.Graphics()), l.visible && t.pointA && t.pointB ? (-1 === r.indexOf(a.children, d) && a.addChild(d), d.clear(), d.beginFill(0, 0), d.lineStyle(l.lineWidth, r.colorToNumber(l.strokeStyle), 1), o ? d.moveTo(o.position.x + i.x, o.position.y + i.y) : d.moveTo(i.x, i.y), n ? d.lineTo(n.position.x + s.x, n.position.y + s.y) : d.lineTo(s.x, s.y), void d.endFill()) : void d.clear();\n        }, n.body = function (e, t) {\n          var n = (e.engine, t.render);if (n.visible) if (n.sprite && n.sprite.texture) {\n            var i = \"b-\" + t.id,\n                a = e.sprites[i],\n                l = e.spriteContainer;a || (a = e.sprites[i] = o(e, t)), -1 === r.indexOf(l.children, a) && l.addChild(a), a.position.x = t.position.x, a.position.y = t.position.y, a.rotation = t.angle, a.scale.x = n.sprite.xScale || 1, a.scale.y = n.sprite.yScale || 1;\n          } else {\n            var c = \"b-\" + t.id,\n                d = e.primitives[c],\n                u = e.container;d || (d = e.primitives[c] = s(e, t), d.initialAngle = t.angle), -1 === r.indexOf(u.children, d) && u.addChild(d), d.position.x = t.position.x, d.position.y = t.position.y, d.rotation = t.angle - d.initialAngle;\n          }\n        };var o = function o(e, t) {\n          var o = t.render,\n              n = o.sprite.texture,\n              i = a(e, n),\n              r = new PIXI.Sprite(i);return r.anchor.x = t.render.sprite.xOffset, r.anchor.y = t.render.sprite.yOffset, r;\n        },\n            s = function s(e, t) {\n          var o,\n              n = t.render,\n              i = e.options,\n              s = new PIXI.Graphics(),\n              a = r.colorToNumber(n.fillStyle),\n              l = r.colorToNumber(n.strokeStyle),\n              c = r.colorToNumber(n.strokeStyle),\n              d = r.colorToNumber(\"#bbb\"),\n              u = r.colorToNumber(\"#CD5C5C\");\n          s.clear();for (var p = t.parts.length > 1 ? 1 : 0; p < t.parts.length; p++) {\n            o = t.parts[p], i.wireframes ? (s.beginFill(0, 0), s.lineStyle(1, d, 1)) : (s.beginFill(a, 1), s.lineStyle(n.lineWidth, l, 1)), s.moveTo(o.vertices[0].x - t.position.x, o.vertices[0].y - t.position.y);for (var f = 1; f < o.vertices.length; f++) {\n              s.lineTo(o.vertices[f].x - t.position.x, o.vertices[f].y - t.position.y);\n            }s.lineTo(o.vertices[0].x - t.position.x, o.vertices[0].y - t.position.y), s.endFill(), (i.showAngleIndicator || i.showAxes) && (s.beginFill(0, 0), i.wireframes ? s.lineStyle(1, u, 1) : s.lineStyle(1, c), s.moveTo(o.position.x - t.position.x, o.position.y - t.position.y), s.lineTo((o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2 - t.position.x, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2 - t.position.y), s.endFill());\n          }return s;\n        },\n            a = function a(e, t) {\n          var o = e.textures[t];return o || (o = e.textures[t] = PIXI.Texture.fromImage(t)), o;\n        };\n      }();\n    }, { \"../body/Composite\": 2, \"../core/Common\": 14 }] }, {}, [28])(28);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jbGllbnQvYXBwL2xpYnMvbWF0dGVyLm1pbi5qcz80ODYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBtYXR0ZXItanMgMC4xMC4wIGJ5IEBsaWFicnUgMjAxNi0wNS0wMVxuKiBodHRwOi8vYnJtLmlvL21hdHRlci1qcy9cbiogTGljZW5zZSBNSVRcbiovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLHQuTWF0dGVyPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUodCxvLG4pe2Z1bmN0aW9uIGkocyxhKXtpZighb1tzXSl7aWYoIXRbc10pe3ZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWEmJmwpcmV0dXJuIGwocywhMCk7aWYocilyZXR1cm4gcihzLCEwKTt2YXIgYz1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3MrXCInXCIpO3Rocm93IGMuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixjfXZhciBkPW9bc109e2V4cG9ydHM6e319O3Rbc11bMF0uY2FsbChkLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG89dFtzXVsxXVtlXTtyZXR1cm4gaShvP286ZSl9LGQsZC5leHBvcnRzLGUsdCxvLG4pfXJldHVybiBvW3NdLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUscz0wO3M8bi5sZW5ndGg7cysrKWkobltzXSk7cmV0dXJuIGl9KHsxOltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxzPWUoXCIuLi9jb3JlL1NsZWVwaW5nXCIpLGE9KGUoXCIuLi9yZW5kZXIvUmVuZGVyXCIpLGUoXCIuLi9jb3JlL0NvbW1vblwiKSksbD1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLGM9ZShcIi4uL2dlb21ldHJ5L0F4ZXNcIik7IWZ1bmN0aW9uKCl7bi5faW5lcnRpYVNjYWxlPTQsbi5fbmV4dENvbGxpZGluZ0dyb3VwSWQ9MSxcbm4uX25leHROb25Db2xsaWRpbmdHcm91cElkPS0xLG4uX25leHRDYXRlZ29yeT0xLG4uY3JlYXRlPWZ1bmN0aW9uKHQpe3ZhciBvPXtpZDphLm5leHRJZCgpLHR5cGU6XCJib2R5XCIsbGFiZWw6XCJCb2R5XCIscGFydHM6W10sYW5nbGU6MCx2ZXJ0aWNlczppLmZyb21QYXRoKFwiTCAwIDAgTCA0MCAwIEwgNDAgNDAgTCAwIDQwXCIpLHBvc2l0aW9uOnt4OjAseTowfSxmb3JjZTp7eDowLHk6MH0sdG9ycXVlOjAscG9zaXRpb25JbXB1bHNlOnt4OjAseTowfSxjb25zdHJhaW50SW1wdWxzZTp7eDowLHk6MCxhbmdsZTowfSx0b3RhbENvbnRhY3RzOjAsc3BlZWQ6MCxhbmd1bGFyU3BlZWQ6MCx2ZWxvY2l0eTp7eDowLHk6MH0sYW5ndWxhclZlbG9jaXR5OjAsaXNTZW5zb3I6ITEsaXNTdGF0aWM6ITEsaXNTbGVlcGluZzohMSxtb3Rpb246MCxzbGVlcFRocmVzaG9sZDo2MCxkZW5zaXR5Oi4wMDEscmVzdGl0dXRpb246MCxmcmljdGlvbjouMSxmcmljdGlvblN0YXRpYzouNSxmcmljdGlvbkFpcjouMDEsY29sbGlzaW9uRmlsdGVyOntjYXRlZ29yeToxLG1hc2s6NDI5NDk2NzI5NSxncm91cDowfSxzbG9wOi4wNSx0aW1lU2NhbGU6MSxyZW5kZXI6e3Zpc2libGU6ITAsb3BhY2l0eToxLHNwcml0ZTp7eFNjYWxlOjEseVNjYWxlOjEseE9mZnNldDowLHlPZmZzZXQ6MH0sbGluZVdpZHRoOjEuNX19LG49YS5leHRlbmQobyx0KTtyZXR1cm4gZShuLHQpLG59LG4ubmV4dEdyb3VwPWZ1bmN0aW9uKGUpe3JldHVybiBlP24uX25leHROb25Db2xsaWRpbmdHcm91cElkLS06bi5fbmV4dENvbGxpZGluZ0dyb3VwSWQrK30sbi5uZXh0Q2F0ZWdvcnk9ZnVuY3Rpb24oKXtyZXR1cm4gbi5fbmV4dENhdGVnb3J5PW4uX25leHRDYXRlZ29yeTw8MSxuLl9uZXh0Q2F0ZWdvcnl9O3ZhciBlPWZ1bmN0aW9uKGUsdCl7bi5zZXQoZSx7Ym91bmRzOmUuYm91bmRzfHxsLmNyZWF0ZShlLnZlcnRpY2VzKSxwb3NpdGlvblByZXY6ZS5wb3NpdGlvblByZXZ8fHIuY2xvbmUoZS5wb3NpdGlvbiksYW5nbGVQcmV2OmUuYW5nbGVQcmV2fHxlLmFuZ2xlLFxudmVydGljZXM6ZS52ZXJ0aWNlcyxwYXJ0czplLnBhcnRzfHxbZV0saXNTdGF0aWM6ZS5pc1N0YXRpYyxpc1NsZWVwaW5nOmUuaXNTbGVlcGluZyxwYXJlbnQ6ZS5wYXJlbnR8fGV9KSxpLnJvdGF0ZShlLnZlcnRpY2VzLGUuYW5nbGUsZS5wb3NpdGlvbiksYy5yb3RhdGUoZS5heGVzLGUuYW5nbGUpLGwudXBkYXRlKGUuYm91bmRzLGUudmVydGljZXMsZS52ZWxvY2l0eSksbi5zZXQoZSx7YXhlczp0LmF4ZXN8fGUuYXhlcyxhcmVhOnQuYXJlYXx8ZS5hcmVhLG1hc3M6dC5tYXNzfHxlLm1hc3MsaW5lcnRpYTp0LmluZXJ0aWF8fGUuaW5lcnRpYX0pO3ZhciBvPWUuaXNTdGF0aWM/XCIjZWVlZWVlXCI6YS5jaG9vc2UoW1wiIzU1NjI3MFwiLFwiIzRFQ0RDNFwiLFwiI0M3RjQ2NFwiLFwiI0ZGNkI2QlwiLFwiI0M0NEQ1OFwiXSkscz1hLnNoYWRlQ29sb3IobywtMjApO2UucmVuZGVyLmZpbGxTdHlsZT1lLnJlbmRlci5maWxsU3R5bGV8fG8sZS5yZW5kZXIuc3Ryb2tlU3R5bGU9ZS5yZW5kZXIuc3Ryb2tlU3R5bGV8fHMsZS5yZW5kZXIuc3ByaXRlLnhPZmZzZXQrPS0oZS5ib3VuZHMubWluLngtZS5wb3NpdGlvbi54KS8oZS5ib3VuZHMubWF4LngtZS5ib3VuZHMubWluLngpLGUucmVuZGVyLnNwcml0ZS55T2Zmc2V0Kz0tKGUuYm91bmRzLm1pbi55LWUucG9zaXRpb24ueSkvKGUuYm91bmRzLm1heC55LWUuYm91bmRzLm1pbi55KX07bi5zZXQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBpO1wic3RyaW5nXCI9PXR5cGVvZiB0JiYoaT10LHQ9e30sdFtpXT1vKTtmb3IoaSBpbiB0KWlmKG89dFtpXSx0Lmhhc093blByb3BlcnR5KGkpKXN3aXRjaChpKXtjYXNlXCJpc1N0YXRpY1wiOm4uc2V0U3RhdGljKGUsbyk7YnJlYWs7Y2FzZVwiaXNTbGVlcGluZ1wiOnMuc2V0KGUsbyk7YnJlYWs7Y2FzZVwibWFzc1wiOm4uc2V0TWFzcyhlLG8pO2JyZWFrO2Nhc2VcImRlbnNpdHlcIjpuLnNldERlbnNpdHkoZSxvKTticmVhaztjYXNlXCJpbmVydGlhXCI6bi5zZXRJbmVydGlhKGUsbyk7YnJlYWs7Y2FzZVwidmVydGljZXNcIjpuLnNldFZlcnRpY2VzKGUsbyk7XG5icmVhaztjYXNlXCJwb3NpdGlvblwiOm4uc2V0UG9zaXRpb24oZSxvKTticmVhaztjYXNlXCJhbmdsZVwiOm4uc2V0QW5nbGUoZSxvKTticmVhaztjYXNlXCJ2ZWxvY2l0eVwiOm4uc2V0VmVsb2NpdHkoZSxvKTticmVhaztjYXNlXCJhbmd1bGFyVmVsb2NpdHlcIjpuLnNldEFuZ3VsYXJWZWxvY2l0eShlLG8pO2JyZWFrO2Nhc2VcInBhcnRzXCI6bi5zZXRQYXJ0cyhlLG8pO2JyZWFrO2RlZmF1bHQ6ZVtpXT1vfX0sbi5zZXRTdGF0aWM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89MDtvPGUucGFydHMubGVuZ3RoO28rKyl7dmFyIG49ZS5wYXJ0c1tvXTtuLmlzU3RhdGljPXQsdCYmKG4ucmVzdGl0dXRpb249MCxuLmZyaWN0aW9uPTEsbi5tYXNzPW4uaW5lcnRpYT1uLmRlbnNpdHk9MS8wLG4uaW52ZXJzZU1hc3M9bi5pbnZlcnNlSW5lcnRpYT0wLG4ucG9zaXRpb25QcmV2Lng9bi5wb3NpdGlvbi54LG4ucG9zaXRpb25QcmV2Lnk9bi5wb3NpdGlvbi55LG4uYW5nbGVQcmV2PW4uYW5nbGUsbi5hbmd1bGFyVmVsb2NpdHk9MCxuLnNwZWVkPTAsbi5hbmd1bGFyU3BlZWQ9MCxuLm1vdGlvbj0wKX19LG4uc2V0TWFzcz1mdW5jdGlvbihlLHQpe2UubWFzcz10LGUuaW52ZXJzZU1hc3M9MS9lLm1hc3MsZS5kZW5zaXR5PWUubWFzcy9lLmFyZWF9LG4uc2V0RGVuc2l0eT1mdW5jdGlvbihlLHQpe24uc2V0TWFzcyhlLHQqZS5hcmVhKSxlLmRlbnNpdHk9dH0sbi5zZXRJbmVydGlhPWZ1bmN0aW9uKGUsdCl7ZS5pbmVydGlhPXQsZS5pbnZlcnNlSW5lcnRpYT0xL2UuaW5lcnRpYX0sbi5zZXRWZXJ0aWNlcz1mdW5jdGlvbihlLHQpe3RbMF0uYm9keT09PWU/ZS52ZXJ0aWNlcz10OmUudmVydGljZXM9aS5jcmVhdGUodCxlKSxlLmF4ZXM9Yy5mcm9tVmVydGljZXMoZS52ZXJ0aWNlcyksZS5hcmVhPWkuYXJlYShlLnZlcnRpY2VzKSxuLnNldE1hc3MoZSxlLmRlbnNpdHkqZS5hcmVhKTt2YXIgbz1pLmNlbnRyZShlLnZlcnRpY2VzKTtpLnRyYW5zbGF0ZShlLnZlcnRpY2VzLG8sLTEpLG4uc2V0SW5lcnRpYShlLG4uX2luZXJ0aWFTY2FsZSppLmluZXJ0aWEoZS52ZXJ0aWNlcyxlLm1hc3MpKSxcbmkudHJhbnNsYXRlKGUudmVydGljZXMsZS5wb3NpdGlvbiksbC51cGRhdGUoZS5ib3VuZHMsZS52ZXJ0aWNlcyxlLnZlbG9jaXR5KX0sbi5zZXRQYXJ0cz1mdW5jdGlvbihlLG8scil7dmFyIHM7Zm9yKG89by5zbGljZSgwKSxlLnBhcnRzLmxlbmd0aD0wLGUucGFydHMucHVzaChlKSxlLnBhcmVudD1lLHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGE9b1tzXTthIT09ZSYmKGEucGFyZW50PWUsZS5wYXJ0cy5wdXNoKGEpKX1pZigxIT09ZS5wYXJ0cy5sZW5ndGgpe2lmKHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHI/cjohMCl7dmFyIGw9W107Zm9yKHM9MDtzPG8ubGVuZ3RoO3MrKylsPWwuY29uY2F0KG9bc10udmVydGljZXMpO2kuY2xvY2t3aXNlU29ydChsKTt2YXIgYz1pLmh1bGwobCksZD1pLmNlbnRyZShjKTtuLnNldFZlcnRpY2VzKGUsYyksaS50cmFuc2xhdGUoZS52ZXJ0aWNlcyxkKX12YXIgdT10KGUpO2UuYXJlYT11LmFyZWEsZS5wYXJlbnQ9ZSxlLnBvc2l0aW9uLng9dS5jZW50cmUueCxlLnBvc2l0aW9uLnk9dS5jZW50cmUueSxlLnBvc2l0aW9uUHJldi54PXUuY2VudHJlLngsZS5wb3NpdGlvblByZXYueT11LmNlbnRyZS55LG4uc2V0TWFzcyhlLHUubWFzcyksbi5zZXRJbmVydGlhKGUsdS5pbmVydGlhKSxuLnNldFBvc2l0aW9uKGUsdS5jZW50cmUpfX0sbi5zZXRQb3NpdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBvPXIuc3ViKHQsZS5wb3NpdGlvbik7ZS5wb3NpdGlvblByZXYueCs9by54LGUucG9zaXRpb25QcmV2LnkrPW8ueTtmb3IodmFyIG49MDtuPGUucGFydHMubGVuZ3RoO24rKyl7dmFyIHM9ZS5wYXJ0c1tuXTtzLnBvc2l0aW9uLngrPW8ueCxzLnBvc2l0aW9uLnkrPW8ueSxpLnRyYW5zbGF0ZShzLnZlcnRpY2VzLG8pLGwudXBkYXRlKHMuYm91bmRzLHMudmVydGljZXMsZS52ZWxvY2l0eSl9fSxuLnNldEFuZ2xlPWZ1bmN0aW9uKGUsdCl7dmFyIG89dC1lLmFuZ2xlO2UuYW5nbGVQcmV2Kz1vO2Zvcih2YXIgbj0wO248ZS5wYXJ0cy5sZW5ndGg7bisrKXtcbnZhciBzPWUucGFydHNbbl07cy5hbmdsZSs9byxpLnJvdGF0ZShzLnZlcnRpY2VzLG8sZS5wb3NpdGlvbiksYy5yb3RhdGUocy5heGVzLG8pLGwudXBkYXRlKHMuYm91bmRzLHMudmVydGljZXMsZS52ZWxvY2l0eSksbj4wJiZyLnJvdGF0ZUFib3V0KHMucG9zaXRpb24sbyxlLnBvc2l0aW9uLHMucG9zaXRpb24pfX0sbi5zZXRWZWxvY2l0eT1mdW5jdGlvbihlLHQpe2UucG9zaXRpb25QcmV2Lng9ZS5wb3NpdGlvbi54LXQueCxlLnBvc2l0aW9uUHJldi55PWUucG9zaXRpb24ueS10LnksZS52ZWxvY2l0eS54PXQueCxlLnZlbG9jaXR5Lnk9dC55LGUuc3BlZWQ9ci5tYWduaXR1ZGUoZS52ZWxvY2l0eSl9LG4uc2V0QW5ndWxhclZlbG9jaXR5PWZ1bmN0aW9uKGUsdCl7ZS5hbmdsZVByZXY9ZS5hbmdsZS10LGUuYW5ndWxhclZlbG9jaXR5PXQsZS5hbmd1bGFyU3BlZWQ9TWF0aC5hYnMoZS5hbmd1bGFyVmVsb2NpdHkpfSxuLnRyYW5zbGF0ZT1mdW5jdGlvbihlLHQpe24uc2V0UG9zaXRpb24oZSxyLmFkZChlLnBvc2l0aW9uLHQpKX0sbi5yb3RhdGU9ZnVuY3Rpb24oZSx0KXtuLnNldEFuZ2xlKGUsZS5hbmdsZSt0KX0sbi5zY2FsZT1mdW5jdGlvbihlLG8scixzKXtmb3IodmFyIGE9MDthPGUucGFydHMubGVuZ3RoO2ErKyl7dmFyIGQ9ZS5wYXJ0c1thXTtpLnNjYWxlKGQudmVydGljZXMsbyxyLGUucG9zaXRpb24pLGQuYXhlcz1jLmZyb21WZXJ0aWNlcyhkLnZlcnRpY2VzKSxlLmlzU3RhdGljfHwoZC5hcmVhPWkuYXJlYShkLnZlcnRpY2VzKSxuLnNldE1hc3MoZCxlLmRlbnNpdHkqZC5hcmVhKSxpLnRyYW5zbGF0ZShkLnZlcnRpY2VzLHt4Oi1kLnBvc2l0aW9uLngseTotZC5wb3NpdGlvbi55fSksbi5zZXRJbmVydGlhKGQsaS5pbmVydGlhKGQudmVydGljZXMsZC5tYXNzKSksaS50cmFuc2xhdGUoZC52ZXJ0aWNlcyx7eDpkLnBvc2l0aW9uLngseTpkLnBvc2l0aW9uLnl9KSksbC51cGRhdGUoZC5ib3VuZHMsZC52ZXJ0aWNlcyxlLnZlbG9jaXR5KX1pZihlLmNpcmNsZVJhZGl1cyYmKG89PT1yP2UuY2lyY2xlUmFkaXVzKj1vOmUuY2lyY2xlUmFkaXVzPW51bGwpLFxuIWUuaXNTdGF0aWMpe3ZhciB1PXQoZSk7ZS5hcmVhPXUuYXJlYSxuLnNldE1hc3MoZSx1Lm1hc3MpLG4uc2V0SW5lcnRpYShlLHUuaW5lcnRpYSl9fSxuLnVwZGF0ZT1mdW5jdGlvbihlLHQsbyxuKXt2YXIgcz1NYXRoLnBvdyh0Km8qZS50aW1lU2NhbGUsMiksYT0xLWUuZnJpY3Rpb25BaXIqbyplLnRpbWVTY2FsZSxkPWUucG9zaXRpb24ueC1lLnBvc2l0aW9uUHJldi54LHU9ZS5wb3NpdGlvbi55LWUucG9zaXRpb25QcmV2Lnk7ZS52ZWxvY2l0eS54PWQqYSpuK2UuZm9yY2UueC9lLm1hc3MqcyxlLnZlbG9jaXR5Lnk9dSphKm4rZS5mb3JjZS55L2UubWFzcypzLGUucG9zaXRpb25QcmV2Lng9ZS5wb3NpdGlvbi54LGUucG9zaXRpb25QcmV2Lnk9ZS5wb3NpdGlvbi55LGUucG9zaXRpb24ueCs9ZS52ZWxvY2l0eS54LGUucG9zaXRpb24ueSs9ZS52ZWxvY2l0eS55LGUuYW5ndWxhclZlbG9jaXR5PShlLmFuZ2xlLWUuYW5nbGVQcmV2KSphKm4rZS50b3JxdWUvZS5pbmVydGlhKnMsZS5hbmdsZVByZXY9ZS5hbmdsZSxlLmFuZ2xlKz1lLmFuZ3VsYXJWZWxvY2l0eSxlLnNwZWVkPXIubWFnbml0dWRlKGUudmVsb2NpdHkpLGUuYW5ndWxhclNwZWVkPU1hdGguYWJzKGUuYW5ndWxhclZlbG9jaXR5KTtmb3IodmFyIHA9MDtwPGUucGFydHMubGVuZ3RoO3ArKyl7dmFyIGY9ZS5wYXJ0c1twXTtpLnRyYW5zbGF0ZShmLnZlcnRpY2VzLGUudmVsb2NpdHkpLHA+MCYmKGYucG9zaXRpb24ueCs9ZS52ZWxvY2l0eS54LGYucG9zaXRpb24ueSs9ZS52ZWxvY2l0eS55KSwwIT09ZS5hbmd1bGFyVmVsb2NpdHkmJihpLnJvdGF0ZShmLnZlcnRpY2VzLGUuYW5ndWxhclZlbG9jaXR5LGUucG9zaXRpb24pLGMucm90YXRlKGYuYXhlcyxlLmFuZ3VsYXJWZWxvY2l0eSkscD4wJiZyLnJvdGF0ZUFib3V0KGYucG9zaXRpb24sZS5hbmd1bGFyVmVsb2NpdHksZS5wb3NpdGlvbixmLnBvc2l0aW9uKSksbC51cGRhdGUoZi5ib3VuZHMsZi52ZXJ0aWNlcyxlLnZlbG9jaXR5KX19LG4uYXBwbHlGb3JjZT1mdW5jdGlvbihlLHQsbyl7XG5lLmZvcmNlLngrPW8ueCxlLmZvcmNlLnkrPW8ueTt2YXIgbj17eDp0LngtZS5wb3NpdGlvbi54LHk6dC55LWUucG9zaXRpb24ueX07ZS50b3JxdWUrPW4ueCpvLnktbi55Km8ueH07dmFyIHQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXttYXNzOjAsYXJlYTowLGluZXJ0aWE6MCxjZW50cmU6e3g6MCx5OjB9fSxvPTE9PT1lLnBhcnRzLmxlbmd0aD8wOjE7bzxlLnBhcnRzLmxlbmd0aDtvKyspe3ZhciBuPWUucGFydHNbb107dC5tYXNzKz1uLm1hc3MsdC5hcmVhKz1uLmFyZWEsdC5pbmVydGlhKz1uLmluZXJ0aWEsdC5jZW50cmU9ci5hZGQodC5jZW50cmUsci5tdWx0KG4ucG9zaXRpb24sbi5tYXNzIT09MS8wP24ubWFzczoxKSl9cmV0dXJuIHQuY2VudHJlPXIuZGl2KHQuY2VudHJlLHQubWFzcyE9PTEvMD90Lm1hc3M6ZS5wYXJ0cy5sZW5ndGgpLHR9fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9TbGVlcGluZ1wiOjIwLFwiLi4vZ2VvbWV0cnkvQXhlc1wiOjIzLFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6MjcsXCIuLi9yZW5kZXIvUmVuZGVyXCI6Mjl9XSwyOltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4uL2NvcmUvRXZlbnRzXCIpLHI9ZShcIi4uL2NvcmUvQ29tbW9uXCIpLHM9ZShcIi4vQm9keVwiKTshZnVuY3Rpb24oKXtuLmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gci5leHRlbmQoe2lkOnIubmV4dElkKCksdHlwZTpcImNvbXBvc2l0ZVwiLHBhcmVudDpudWxsLGlzTW9kaWZpZWQ6ITEsYm9kaWVzOltdLGNvbnN0cmFpbnRzOltdLGNvbXBvc2l0ZXM6W10sbGFiZWw6XCJDb21wb3NpdGVcIn0sZSl9LG4uc2V0TW9kaWZpZWQ9ZnVuY3Rpb24oZSx0LG8saSl7aWYoZS5pc01vZGlmaWVkPXQsbyYmZS5wYXJlbnQmJm4uc2V0TW9kaWZpZWQoZS5wYXJlbnQsdCxvLGkpLGkpZm9yKHZhciByPTA7cjxlLmNvbXBvc2l0ZXMubGVuZ3RoO3IrKyl7dmFyIHM9ZS5jb21wb3NpdGVzW3JdO1xubi5zZXRNb2RpZmllZChzLHQsbyxpKX19LG4uYWRkPWZ1bmN0aW9uKGUsdCl7dmFyIG89W10uY29uY2F0KHQpO2kudHJpZ2dlcihlLFwiYmVmb3JlQWRkXCIse29iamVjdDp0fSk7Zm9yKHZhciBzPTA7czxvLmxlbmd0aDtzKyspe3ZhciBhPW9bc107c3dpdGNoKGEudHlwZSl7Y2FzZVwiYm9keVwiOmlmKGEucGFyZW50IT09YSl7ci5sb2coXCJDb21wb3NpdGUuYWRkOiBza2lwcGVkIGFkZGluZyBhIGNvbXBvdW5kIGJvZHkgcGFydCAoeW91IG11c3QgYWRkIGl0cyBwYXJlbnQgaW5zdGVhZClcIixcIndhcm5cIik7YnJlYWt9bi5hZGRCb2R5KGUsYSk7YnJlYWs7Y2FzZVwiY29uc3RyYWludFwiOm4uYWRkQ29uc3RyYWludChlLGEpO2JyZWFrO2Nhc2VcImNvbXBvc2l0ZVwiOm4uYWRkQ29tcG9zaXRlKGUsYSk7YnJlYWs7Y2FzZVwibW91c2VDb25zdHJhaW50XCI6bi5hZGRDb25zdHJhaW50KGUsYS5jb25zdHJhaW50KX19cmV0dXJuIGkudHJpZ2dlcihlLFwiYWZ0ZXJBZGRcIix7b2JqZWN0OnR9KSxlfSxuLnJlbW92ZT1mdW5jdGlvbihlLHQsbyl7dmFyIHI9W10uY29uY2F0KHQpO2kudHJpZ2dlcihlLFwiYmVmb3JlUmVtb3ZlXCIse29iamVjdDp0fSk7Zm9yKHZhciBzPTA7czxyLmxlbmd0aDtzKyspe3ZhciBhPXJbc107c3dpdGNoKGEudHlwZSl7Y2FzZVwiYm9keVwiOm4ucmVtb3ZlQm9keShlLGEsbyk7YnJlYWs7Y2FzZVwiY29uc3RyYWludFwiOm4ucmVtb3ZlQ29uc3RyYWludChlLGEsbyk7YnJlYWs7Y2FzZVwiY29tcG9zaXRlXCI6bi5yZW1vdmVDb21wb3NpdGUoZSxhLG8pO2JyZWFrO2Nhc2VcIm1vdXNlQ29uc3RyYWludFwiOm4ucmVtb3ZlQ29uc3RyYWludChlLGEuY29uc3RyYWludCl9fXJldHVybiBpLnRyaWdnZXIoZSxcImFmdGVyUmVtb3ZlXCIse29iamVjdDp0fSksZX0sbi5hZGRDb21wb3NpdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb21wb3NpdGVzLnB1c2godCksdC5wYXJlbnQ9ZSxuLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG4ucmVtb3ZlQ29tcG9zaXRlPWZ1bmN0aW9uKGUsdCxvKXtcbnZhciBpPXIuaW5kZXhPZihlLmNvbXBvc2l0ZXMsdCk7aWYoLTEhPT1pJiYobi5yZW1vdmVDb21wb3NpdGVBdChlLGkpLG4uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSkpLG8pZm9yKHZhciBzPTA7czxlLmNvbXBvc2l0ZXMubGVuZ3RoO3MrKyluLnJlbW92ZUNvbXBvc2l0ZShlLmNvbXBvc2l0ZXNbc10sdCwhMCk7cmV0dXJuIGV9LG4ucmVtb3ZlQ29tcG9zaXRlQXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb21wb3NpdGVzLnNwbGljZSh0LDEpLG4uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSksZX0sbi5hZGRCb2R5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuYm9kaWVzLnB1c2godCksbi5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfSxuLnJlbW92ZUJvZHk9ZnVuY3Rpb24oZSx0LG8pe3ZhciBpPXIuaW5kZXhPZihlLmJvZGllcyx0KTtpZigtMSE9PWkmJihuLnJlbW92ZUJvZHlBdChlLGkpLG4uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSkpLG8pZm9yKHZhciBzPTA7czxlLmNvbXBvc2l0ZXMubGVuZ3RoO3MrKyluLnJlbW92ZUJvZHkoZS5jb21wb3NpdGVzW3NdLHQsITApO3JldHVybiBlfSxuLnJlbW92ZUJvZHlBdD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmJvZGllcy5zcGxpY2UodCwxKSxuLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG4uYWRkQ29uc3RyYWludD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmNvbnN0cmFpbnRzLnB1c2godCksbi5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfSxuLnJlbW92ZUNvbnN0cmFpbnQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBpPXIuaW5kZXhPZihlLmNvbnN0cmFpbnRzLHQpO2lmKC0xIT09aSYmbi5yZW1vdmVDb25zdHJhaW50QXQoZSxpKSxvKWZvcih2YXIgcz0wO3M8ZS5jb21wb3NpdGVzLmxlbmd0aDtzKyspbi5yZW1vdmVDb25zdHJhaW50KGUuY29tcG9zaXRlc1tzXSx0LCEwKTtyZXR1cm4gZX0sbi5yZW1vdmVDb25zdHJhaW50QXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25zdHJhaW50cy5zcGxpY2UodCwxKSxuLnNldE1vZGlmaWVkKGUsITAsITAsITEpLFxuZX0sbi5jbGVhcj1mdW5jdGlvbihlLHQsbyl7aWYobylmb3IodmFyIGk9MDtpPGUuY29tcG9zaXRlcy5sZW5ndGg7aSsrKW4uY2xlYXIoZS5jb21wb3NpdGVzW2ldLHQsITApO3JldHVybiB0P2UuYm9kaWVzPWUuYm9kaWVzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5pc1N0YXRpY30pOmUuYm9kaWVzLmxlbmd0aD0wLGUuY29uc3RyYWludHMubGVuZ3RoPTAsZS5jb21wb3NpdGVzLmxlbmd0aD0wLG4uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSksZX0sbi5hbGxCb2RpZXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLmNvbmNhdChlLmJvZGllcyksbz0wO288ZS5jb21wb3NpdGVzLmxlbmd0aDtvKyspdD10LmNvbmNhdChuLmFsbEJvZGllcyhlLmNvbXBvc2l0ZXNbb10pKTtyZXR1cm4gdH0sbi5hbGxDb25zdHJhaW50cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10uY29uY2F0KGUuY29uc3RyYWludHMpLG89MDtvPGUuY29tcG9zaXRlcy5sZW5ndGg7bysrKXQ9dC5jb25jYXQobi5hbGxDb25zdHJhaW50cyhlLmNvbXBvc2l0ZXNbb10pKTtyZXR1cm4gdH0sbi5hbGxDb21wb3NpdGVzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXS5jb25jYXQoZS5jb21wb3NpdGVzKSxvPTA7bzxlLmNvbXBvc2l0ZXMubGVuZ3RoO28rKyl0PXQuY29uY2F0KG4uYWxsQ29tcG9zaXRlcyhlLmNvbXBvc2l0ZXNbb10pKTtyZXR1cm4gdH0sbi5nZXQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBpLHI7c3dpdGNoKG8pe2Nhc2VcImJvZHlcIjppPW4uYWxsQm9kaWVzKGUpO2JyZWFrO2Nhc2VcImNvbnN0cmFpbnRcIjppPW4uYWxsQ29uc3RyYWludHMoZSk7YnJlYWs7Y2FzZVwiY29tcG9zaXRlXCI6aT1uLmFsbENvbXBvc2l0ZXMoZSkuY29uY2F0KGUpfXJldHVybiBpPyhyPWkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkLnRvU3RyaW5nKCk9PT10LnRvU3RyaW5nKCl9KSwwPT09ci5sZW5ndGg/bnVsbDpyWzBdKTpudWxsfSxuLm1vdmU9ZnVuY3Rpb24oZSx0LG8pe3JldHVybiBuLnJlbW92ZShlLHQpLFxubi5hZGQobyx0KSxlfSxuLnJlYmFzZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bi5hbGxCb2RpZXMoZSkuY29uY2F0KG4uYWxsQ29uc3RyYWludHMoZSkpLmNvbmNhdChuLmFsbENvbXBvc2l0ZXMoZSkpLG89MDtvPHQubGVuZ3RoO28rKyl0W29dLmlkPXIubmV4dElkKCk7cmV0dXJuIG4uc2V0TW9kaWZpZWQoZSwhMCwhMCwhMSksZX0sbi50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LG8pe2Zvcih2YXIgaT1vP24uYWxsQm9kaWVzKGUpOmUuYm9kaWVzLHI9MDtyPGkubGVuZ3RoO3IrKylzLnRyYW5zbGF0ZShpW3JdLHQpO3JldHVybiBuLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG4ucm90YXRlPWZ1bmN0aW9uKGUsdCxvLGkpe2Zvcih2YXIgcj1NYXRoLmNvcyh0KSxhPU1hdGguc2luKHQpLGw9aT9uLmFsbEJvZGllcyhlKTplLmJvZGllcyxjPTA7YzxsLmxlbmd0aDtjKyspe3ZhciBkPWxbY10sdT1kLnBvc2l0aW9uLngtby54LHA9ZC5wb3NpdGlvbi55LW8ueTtzLnNldFBvc2l0aW9uKGQse3g6by54Kyh1KnItcCphKSx5Om8ueSsodSphK3Aqcil9KSxzLnJvdGF0ZShkLHQpfXJldHVybiBuLnNldE1vZGlmaWVkKGUsITAsITAsITEpLGV9LG4uc2NhbGU9ZnVuY3Rpb24oZSx0LG8saSxyKXtmb3IodmFyIGE9cj9uLmFsbEJvZGllcyhlKTplLmJvZGllcyxsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciBjPWFbbF0sZD1jLnBvc2l0aW9uLngtaS54LHU9Yy5wb3NpdGlvbi55LWkueTtzLnNldFBvc2l0aW9uKGMse3g6aS54K2QqdCx5OmkueSt1Km99KSxzLnNjYWxlKGMsdCxvKX1yZXR1cm4gbi5zZXRNb2RpZmllZChlLCEwLCEwLCExKSxlfX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuL0JvZHlcIjoxfV0sMzpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuL0NvbXBvc2l0ZVwiKSxyPShlKFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCIpLGUoXCIuLi9jb3JlL0NvbW1vblwiKSk7IWZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSl7XG52YXIgdD1pLmNyZWF0ZSgpLG89e2xhYmVsOlwiV29ybGRcIixncmF2aXR5Ont4OjAseToxLHNjYWxlOi4wMDF9LGJvdW5kczp7bWluOnt4Oi0oMS8wKSx5Oi0oMS8wKX0sbWF4Ont4OjEvMCx5OjEvMH19fTtyZXR1cm4gci5leHRlbmQodCxvLGUpfX0oKX0se1wiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCI6MTIsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi9Db21wb3NpdGVcIjoyfV0sNDpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uLGZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJue2lkOm4uaWQoZSksdmVydGV4OmUsbm9ybWFsSW1wdWxzZTowLHRhbmdlbnRJbXB1bHNlOjB9fSxuLmlkPWZ1bmN0aW9uKGUpe3JldHVybiBlLmJvZHkuaWQrXCJfXCIrZS5pbmRleH19KCl9LHt9XSw1OltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4vU0FUXCIpLHI9ZShcIi4vUGFpclwiKSxzPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIik7IWZ1bmN0aW9uKCl7bi5jb2xsaXNpb25zPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBvPVtdLGE9dC5wYWlycy50YWJsZSxsPTA7bDxlLmxlbmd0aDtsKyspe3ZhciBjPWVbbF1bMF0sZD1lW2xdWzFdO2lmKCghYy5pc1N0YXRpYyYmIWMuaXNTbGVlcGluZ3x8IWQuaXNTdGF0aWMmJiFkLmlzU2xlZXBpbmcpJiZuLmNhbkNvbGxpZGUoYy5jb2xsaXNpb25GaWx0ZXIsZC5jb2xsaXNpb25GaWx0ZXIpJiZzLm92ZXJsYXBzKGMuYm91bmRzLGQuYm91bmRzKSlmb3IodmFyIHU9Yy5wYXJ0cy5sZW5ndGg+MT8xOjA7dTxjLnBhcnRzLmxlbmd0aDt1KyspZm9yKHZhciBwPWMucGFydHNbdV0sZj1kLnBhcnRzLmxlbmd0aD4xPzE6MDtmPGQucGFydHMubGVuZ3RoO2YrKyl7dmFyIHY9ZC5wYXJ0c1tmXTtpZihwPT09YyYmdj09PWR8fHMub3ZlcmxhcHMocC5ib3VuZHMsdi5ib3VuZHMpKXt2YXIgbSx5PXIuaWQocCx2KSxnPWFbeV07bT1nJiZnLmlzQWN0aXZlP2cuY29sbGlzaW9uOm51bGw7dmFyIHg9aS5jb2xsaWRlcyhwLHYsbSk7XG54LmNvbGxpZGVkJiZvLnB1c2goeCl9fX1yZXR1cm4gb30sbi5jYW5Db2xsaWRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ3JvdXA9PT10Lmdyb3VwJiYwIT09ZS5ncm91cD9lLmdyb3VwPjA6MCE9PShlLm1hc2smdC5jYXRlZ29yeSkmJjAhPT0odC5tYXNrJmUuY2F0ZWdvcnkpfX0oKX0se1wiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjQsXCIuL1BhaXJcIjo3LFwiLi9TQVRcIjoxMX1dLDY6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi9QYWlyXCIpLHI9ZShcIi4vRGV0ZWN0b3JcIikscz1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9e2NvbnRyb2xsZXI6bixkZXRlY3RvcjpyLmNvbGxpc2lvbnMsYnVja2V0czp7fSxwYWlyczp7fSxwYWlyc0xpc3Q6W10sYnVja2V0V2lkdGg6NDgsYnVja2V0SGVpZ2h0OjQ4fTtyZXR1cm4gcy5leHRlbmQodCxlKX0sbi51cGRhdGU9ZnVuY3Rpb24obyxuLGkscil7dmFyIHMscCxmLHYsbSx5PWkud29ybGQsZz1vLmJ1Y2tldHMseD0hMTtmb3Iocz0wO3M8bi5sZW5ndGg7cysrKXt2YXIgaD1uW3NdO2lmKCghaC5pc1NsZWVwaW5nfHxyKSYmIShoLmJvdW5kcy5tYXgueDx5LmJvdW5kcy5taW4ueHx8aC5ib3VuZHMubWluLng+eS5ib3VuZHMubWF4Lnh8fGguYm91bmRzLm1heC55PHkuYm91bmRzLm1pbi55fHxoLmJvdW5kcy5taW4ueT55LmJvdW5kcy5tYXgueSkpe3ZhciBiPXQobyxoKTtpZighaC5yZWdpb258fGIuaWQhPT1oLnJlZ2lvbi5pZHx8cil7aC5yZWdpb24mJiFyfHwoaC5yZWdpb249Yik7dmFyIHc9ZShiLGgucmVnaW9uKTtmb3IocD13LnN0YXJ0Q29sO3A8PXcuZW5kQ29sO3ArKylmb3IoZj13LnN0YXJ0Um93O2Y8PXcuZW5kUm93O2YrKyl7bT1hKHAsZiksdj1nW21dO3ZhciBTPXA+PWIuc3RhcnRDb2wmJnA8PWIuZW5kQ29sJiZmPj1iLnN0YXJ0Um93JiZmPD1iLmVuZFJvdyxDPXA+PWgucmVnaW9uLnN0YXJ0Q29sJiZwPD1oLnJlZ2lvbi5lbmRDb2wmJmY+PWgucmVnaW9uLnN0YXJ0Um93JiZmPD1oLnJlZ2lvbi5lbmRSb3c7XG4hUyYmQyYmQyYmdiYmZChvLHYsaCksKGgucmVnaW9uPT09Ynx8UyYmIUN8fHIpJiYodnx8KHY9bChnLG0pKSxjKG8sdixoKSl9aC5yZWdpb249Yix4PSEwfX19eCYmKG8ucGFpcnNMaXN0PXUobykpfSxuLmNsZWFyPWZ1bmN0aW9uKGUpe2UuYnVja2V0cz17fSxlLnBhaXJzPXt9LGUucGFpcnNMaXN0PVtdfTt2YXIgZT1mdW5jdGlvbihlLHQpe3ZhciBuPU1hdGgubWluKGUuc3RhcnRDb2wsdC5zdGFydENvbCksaT1NYXRoLm1heChlLmVuZENvbCx0LmVuZENvbCkscj1NYXRoLm1pbihlLnN0YXJ0Um93LHQuc3RhcnRSb3cpLHM9TWF0aC5tYXgoZS5lbmRSb3csdC5lbmRSb3cpO3JldHVybiBvKG4saSxyLHMpfSx0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5ib3VuZHMsaT1NYXRoLmZsb29yKG4ubWluLngvZS5idWNrZXRXaWR0aCkscj1NYXRoLmZsb29yKG4ubWF4LngvZS5idWNrZXRXaWR0aCkscz1NYXRoLmZsb29yKG4ubWluLnkvZS5idWNrZXRIZWlnaHQpLGE9TWF0aC5mbG9vcihuLm1heC55L2UuYnVja2V0SGVpZ2h0KTtyZXR1cm4gbyhpLHIscyxhKX0sbz1mdW5jdGlvbihlLHQsbyxuKXtyZXR1cm57aWQ6ZStcIixcIit0K1wiLFwiK28rXCIsXCIrbixzdGFydENvbDplLGVuZENvbDp0LHN0YXJ0Um93Om8sZW5kUm93Om59fSxhPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrXCIsXCIrdH0sbD1mdW5jdGlvbihlLHQpe3ZhciBvPWVbdF09W107cmV0dXJuIG99LGM9ZnVuY3Rpb24oZSx0LG8pe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2lmKCEoby5pZD09PXIuaWR8fG8uaXNTdGF0aWMmJnIuaXNTdGF0aWMpKXt2YXIgcz1pLmlkKG8sciksYT1lLnBhaXJzW3NdO2E/YVsyXSs9MTplLnBhaXJzW3NdPVtvLHIsMV19fXQucHVzaChvKX0sZD1mdW5jdGlvbihlLHQsbyl7dC5zcGxpY2Uocy5pbmRleE9mKHQsbyksMSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl0sYT1pLmlkKG8sciksbD1lLnBhaXJzW2FdO2wmJihsWzJdLT0xKX19LHU9ZnVuY3Rpb24oZSl7XG52YXIgdCxvLG49W107dD1zLmtleXMoZS5wYWlycyk7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspbz1lLnBhaXJzW3RbaV1dLG9bMl0+MD9uLnB1c2gobyk6ZGVsZXRlIGUucGFpcnNbdFtpXV07cmV0dXJuIG59fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi9EZXRlY3RvclwiOjUsXCIuL1BhaXJcIjo3fV0sNzpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuL0NvbnRhY3RcIik7IWZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSx0KXt2YXIgbz1lLmJvZHlBLGk9ZS5ib2R5QixyPWUucGFyZW50QSxzPWUucGFyZW50QixhPXtpZDpuLmlkKG8saSksYm9keUE6byxib2R5QjppLGNvbnRhY3RzOnt9LGFjdGl2ZUNvbnRhY3RzOltdLHNlcGFyYXRpb246MCxpc0FjdGl2ZTohMCxpc1NlbnNvcjpvLmlzU2Vuc29yfHxpLmlzU2Vuc29yLHRpbWVDcmVhdGVkOnQsdGltZVVwZGF0ZWQ6dCxpbnZlcnNlTWFzczpyLmludmVyc2VNYXNzK3MuaW52ZXJzZU1hc3MsZnJpY3Rpb246TWF0aC5taW4oci5mcmljdGlvbixzLmZyaWN0aW9uKSxmcmljdGlvblN0YXRpYzpNYXRoLm1heChyLmZyaWN0aW9uU3RhdGljLHMuZnJpY3Rpb25TdGF0aWMpLHJlc3RpdHV0aW9uOk1hdGgubWF4KHIucmVzdGl0dXRpb24scy5yZXN0aXR1dGlvbiksc2xvcDpNYXRoLm1heChyLnNsb3Ascy5zbG9wKX07cmV0dXJuIG4udXBkYXRlKGEsZSx0KSxhfSxuLnVwZGF0ZT1mdW5jdGlvbihlLHQsbyl7dmFyIHI9ZS5jb250YWN0cyxzPXQuc3VwcG9ydHMsYT1lLmFjdGl2ZUNvbnRhY3RzLGw9dC5wYXJlbnRBLGM9dC5wYXJlbnRCO2lmKGUuY29sbGlzaW9uPXQsZS5pbnZlcnNlTWFzcz1sLmludmVyc2VNYXNzK2MuaW52ZXJzZU1hc3MsZS5mcmljdGlvbj1NYXRoLm1pbihsLmZyaWN0aW9uLGMuZnJpY3Rpb24pLGUuZnJpY3Rpb25TdGF0aWM9TWF0aC5tYXgobC5mcmljdGlvblN0YXRpYyxjLmZyaWN0aW9uU3RhdGljKSxlLnJlc3RpdHV0aW9uPU1hdGgubWF4KGwucmVzdGl0dXRpb24sYy5yZXN0aXR1dGlvbiksXG5lLnNsb3A9TWF0aC5tYXgobC5zbG9wLGMuc2xvcCksYS5sZW5ndGg9MCx0LmNvbGxpZGVkKXtmb3IodmFyIGQ9MDtkPHMubGVuZ3RoO2QrKyl7dmFyIHU9c1tkXSxwPWkuaWQodSksZj1yW3BdO2Y/YS5wdXNoKGYpOmEucHVzaChyW3BdPWkuY3JlYXRlKHUpKX1lLnNlcGFyYXRpb249dC5kZXB0aCxuLnNldEFjdGl2ZShlLCEwLG8pfWVsc2UgZS5pc0FjdGl2ZT09PSEwJiZuLnNldEFjdGl2ZShlLCExLG8pfSxuLnNldEFjdGl2ZT1mdW5jdGlvbihlLHQsbyl7dD8oZS5pc0FjdGl2ZT0hMCxlLnRpbWVVcGRhdGVkPW8pOihlLmlzQWN0aXZlPSExLGUuYWN0aXZlQ29udGFjdHMubGVuZ3RoPTApfSxuLmlkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuaWQ8dC5pZD9lLmlkK1wiX1wiK3QuaWQ6dC5pZCtcIl9cIitlLmlkfX0oKX0se1wiLi9Db250YWN0XCI6NH1dLDg6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi9QYWlyXCIpLHI9ZShcIi4uL2NvcmUvQ29tbW9uXCIpOyFmdW5jdGlvbigpe3ZhciBlPTFlMztuLmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gci5leHRlbmQoe3RhYmxlOnt9LGxpc3Q6W10sY29sbGlzaW9uU3RhcnQ6W10sY29sbGlzaW9uQWN0aXZlOltdLGNvbGxpc2lvbkVuZDpbXX0sZSl9LG4udXBkYXRlPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbixzLGEsbCxjPWUubGlzdCxkPWUudGFibGUsdT1lLmNvbGxpc2lvblN0YXJ0LHA9ZS5jb2xsaXNpb25FbmQsZj1lLmNvbGxpc2lvbkFjdGl2ZSx2PVtdO2Zvcih1Lmxlbmd0aD0wLHAubGVuZ3RoPTAsZi5sZW5ndGg9MCxsPTA7bDx0Lmxlbmd0aDtsKyspbj10W2xdLG4uY29sbGlkZWQmJihzPWkuaWQobi5ib2R5QSxuLmJvZHlCKSx2LnB1c2gocyksYT1kW3NdLGE/KGEuaXNBY3RpdmU/Zi5wdXNoKGEpOnUucHVzaChhKSxpLnVwZGF0ZShhLG4sbykpOihhPWkuY3JlYXRlKG4sbyksZFtzXT1hLHUucHVzaChhKSxjLnB1c2goYSkpKTtmb3IobD0wO2w8Yy5sZW5ndGg7bCsrKWE9Y1tsXSxhLmlzQWN0aXZlJiYtMT09PXIuaW5kZXhPZih2LGEuaWQpJiYoaS5zZXRBY3RpdmUoYSwhMSxvKSxcbnAucHVzaChhKSl9LG4ucmVtb3ZlT2xkPWZ1bmN0aW9uKHQsbyl7dmFyIG4saSxyLHMsYT10Lmxpc3QsbD10LnRhYmxlLGM9W107Zm9yKHM9MDtzPGEubGVuZ3RoO3MrKyluPWFbc10saT1uLmNvbGxpc2lvbixpLmJvZHlBLmlzU2xlZXBpbmd8fGkuYm9keUIuaXNTbGVlcGluZz9uLnRpbWVVcGRhdGVkPW86by1uLnRpbWVVcGRhdGVkPmUmJmMucHVzaChzKTtmb3Iocz0wO3M8Yy5sZW5ndGg7cysrKXI9Y1tzXS1zLG49YVtyXSxkZWxldGUgbFtuLmlkXSxhLnNwbGljZShyLDEpfSxuLmNsZWFyPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRhYmxlPXt9LGUubGlzdC5sZW5ndGg9MCxlLmNvbGxpc2lvblN0YXJ0Lmxlbmd0aD0wLGUuY29sbGlzaW9uQWN0aXZlLmxlbmd0aD0wLGUuY29sbGlzaW9uRW5kLmxlbmd0aD0wLGV9fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi9QYWlyXCI6N31dLDk6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLHI9ZShcIi4vU0FUXCIpLHM9ZShcIi4uL2dlb21ldHJ5L0JvdW5kc1wiKSxhPWUoXCIuLi9mYWN0b3J5L0JvZGllc1wiKSxsPWUoXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiKTshZnVuY3Rpb24oKXtuLnJheT1mdW5jdGlvbihlLHQsbyxuKXtuPW58fDFlLTEwMDtmb3IodmFyIGw9aS5hbmdsZSh0LG8pLGM9aS5tYWduaXR1ZGUoaS5zdWIodCxvKSksZD0uNSooby54K3QueCksdT0uNSooby55K3QueSkscD1hLnJlY3RhbmdsZShkLHUsYyxuLHthbmdsZTpsfSksZj1bXSx2PTA7djxlLmxlbmd0aDt2Kyspe3ZhciBtPWVbdl07aWYocy5vdmVybGFwcyhtLmJvdW5kcyxwLmJvdW5kcykpZm9yKHZhciB5PTE9PT1tLnBhcnRzLmxlbmd0aD8wOjE7eTxtLnBhcnRzLmxlbmd0aDt5Kyspe3ZhciBnPW0ucGFydHNbeV07aWYocy5vdmVybGFwcyhnLmJvdW5kcyxwLmJvdW5kcykpe3ZhciB4PXIuY29sbGlkZXMoZyxwKTtpZih4LmNvbGxpZGVkKXt4LmJvZHk9eC5ib2R5QT14LmJvZHlCPW0sXG5mLnB1c2goeCk7YnJlYWt9fX19cmV0dXJuIGZ9LG4ucmVnaW9uPWZ1bmN0aW9uKGUsdCxvKXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgcj1lW2ldLGE9cy5vdmVybGFwcyhyLmJvdW5kcyx0KTsoYSYmIW98fCFhJiZvKSYmbi5wdXNoKHIpfXJldHVybiBufSxuLnBvaW50PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBvPVtdLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZVtuXTtpZihzLmNvbnRhaW5zKGkuYm91bmRzLHQpKWZvcih2YXIgcj0xPT09aS5wYXJ0cy5sZW5ndGg/MDoxO3I8aS5wYXJ0cy5sZW5ndGg7cisrKXt2YXIgYT1pLnBhcnRzW3JdO2lmKHMuY29udGFpbnMoYS5ib3VuZHMsdCkmJmwuY29udGFpbnMoYS52ZXJ0aWNlcyx0KSl7by5wdXNoKGkpO2JyZWFrfX19cmV0dXJuIG99fSgpfSx7XCIuLi9mYWN0b3J5L0JvZGllc1wiOjIxLFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6MjcsXCIuL1NBVFwiOjExfV0sMTA6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIikscj1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLHM9ZShcIi4uL2NvcmUvQ29tbW9uXCIpLGE9ZShcIi4uL2dlb21ldHJ5L0JvdW5kc1wiKTshZnVuY3Rpb24oKXtuLl9yZXN0aW5nVGhyZXNoPTQsbi5fcmVzdGluZ1RocmVzaFRhbmdlbnQ9NixuLl9wb3NpdGlvbkRhbXBlbj0uOSxuLl9wb3NpdGlvbldhcm1pbmc9Ljgsbi5fZnJpY3Rpb25Ob3JtYWxNdWx0aXBsaWVyPTUsbi5wcmVTb2x2ZVBvc2l0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0LG8sbjtmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKW89ZVt0XSxvLmlzQWN0aXZlJiYobj1vLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCxvLmNvbGxpc2lvbi5wYXJlbnRBLnRvdGFsQ29udGFjdHMrPW4sby5jb2xsaXNpb24ucGFyZW50Qi50b3RhbENvbnRhY3RzKz1uKX0sbi5zb2x2ZVBvc2l0aW9uPWZ1bmN0aW9uKGUsdCl7XG52YXIgbyxpLHMsYSxsLGMsZCx1LHAsZj1yLl90ZW1wWzBdLHY9ci5fdGVtcFsxXSxtPXIuX3RlbXBbMl0seT1yLl90ZW1wWzNdO2ZvcihvPTA7bzxlLmxlbmd0aDtvKyspaT1lW29dLGkuaXNBY3RpdmUmJiFpLmlzU2Vuc29yJiYocz1pLmNvbGxpc2lvbixhPXMucGFyZW50QSxsPXMucGFyZW50QixjPXMubm9ybWFsLGQ9ci5zdWIoci5hZGQobC5wb3NpdGlvbkltcHVsc2UsbC5wb3NpdGlvbixmKSxyLmFkZChhLnBvc2l0aW9uSW1wdWxzZSxyLnN1YihsLnBvc2l0aW9uLHMucGVuZXRyYXRpb24sdiksbSkseSksaS5zZXBhcmF0aW9uPXIuZG90KGMsZCkpO2ZvcihvPTA7bzxlLmxlbmd0aDtvKyspaT1lW29dLCFpLmlzQWN0aXZlfHxpLmlzU2Vuc29yfHxpLnNlcGFyYXRpb248MHx8KHM9aS5jb2xsaXNpb24sYT1zLnBhcmVudEEsbD1zLnBhcmVudEIsYz1zLm5vcm1hbCxwPShpLnNlcGFyYXRpb24taS5zbG9wKSp0LChhLmlzU3RhdGljfHxsLmlzU3RhdGljKSYmKHAqPTIpLGEuaXNTdGF0aWN8fGEuaXNTbGVlcGluZ3x8KHU9bi5fcG9zaXRpb25EYW1wZW4vYS50b3RhbENvbnRhY3RzLGEucG9zaXRpb25JbXB1bHNlLngrPWMueCpwKnUsYS5wb3NpdGlvbkltcHVsc2UueSs9Yy55KnAqdSksbC5pc1N0YXRpY3x8bC5pc1NsZWVwaW5nfHwodT1uLl9wb3NpdGlvbkRhbXBlbi9sLnRvdGFsQ29udGFjdHMsbC5wb3NpdGlvbkltcHVsc2UueC09Yy54KnAqdSxsLnBvc2l0aW9uSW1wdWxzZS55LT1jLnkqcCp1KSl9LG4ucG9zdFNvbHZlUG9zaXRpb249ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBvPWVbdF07aWYoby50b3RhbENvbnRhY3RzPTAsMCE9PW8ucG9zaXRpb25JbXB1bHNlLnh8fDAhPT1vLnBvc2l0aW9uSW1wdWxzZS55KXtmb3IodmFyIHM9MDtzPG8ucGFydHMubGVuZ3RoO3MrKyl7dmFyIGw9by5wYXJ0c1tzXTtpLnRyYW5zbGF0ZShsLnZlcnRpY2VzLG8ucG9zaXRpb25JbXB1bHNlKSxhLnVwZGF0ZShsLmJvdW5kcyxsLnZlcnRpY2VzLG8udmVsb2NpdHkpLFxubC5wb3NpdGlvbi54Kz1vLnBvc2l0aW9uSW1wdWxzZS54LGwucG9zaXRpb24ueSs9by5wb3NpdGlvbkltcHVsc2UueX1vLnBvc2l0aW9uUHJldi54Kz1vLnBvc2l0aW9uSW1wdWxzZS54LG8ucG9zaXRpb25QcmV2LnkrPW8ucG9zaXRpb25JbXB1bHNlLnksci5kb3Qoby5wb3NpdGlvbkltcHVsc2Usby52ZWxvY2l0eSk8MD8oby5wb3NpdGlvbkltcHVsc2UueD0wLG8ucG9zaXRpb25JbXB1bHNlLnk9MCk6KG8ucG9zaXRpb25JbXB1bHNlLngqPW4uX3Bvc2l0aW9uV2FybWluZyxvLnBvc2l0aW9uSW1wdWxzZS55Kj1uLl9wb3NpdGlvbldhcm1pbmcpfX19LG4ucHJlU29sdmVWZWxvY2l0eT1mdW5jdGlvbihlKXt2YXIgdCxvLG4saSxzLGEsbCxjLGQsdSxwLGYsdixtLHk9ci5fdGVtcFswXSxnPXIuX3RlbXBbMV07Zm9yKHQ9MDt0PGUubGVuZ3RoO3QrKylpZihuPWVbdF0sbi5pc0FjdGl2ZSYmIW4uaXNTZW5zb3IpZm9yKGk9bi5hY3RpdmVDb250YWN0cyxzPW4uY29sbGlzaW9uLGE9cy5wYXJlbnRBLGw9cy5wYXJlbnRCLGM9cy5ub3JtYWwsZD1zLnRhbmdlbnQsbz0wO288aS5sZW5ndGg7bysrKXU9aVtvXSxwPXUudmVydGV4LGY9dS5ub3JtYWxJbXB1bHNlLHY9dS50YW5nZW50SW1wdWxzZSwwPT09ZiYmMD09PXZ8fCh5Lng9Yy54KmYrZC54KnYseS55PWMueSpmK2QueSp2LGEuaXNTdGF0aWN8fGEuaXNTbGVlcGluZ3x8KG09ci5zdWIocCxhLnBvc2l0aW9uLGcpLGEucG9zaXRpb25QcmV2LngrPXkueCphLmludmVyc2VNYXNzLGEucG9zaXRpb25QcmV2LnkrPXkueSphLmludmVyc2VNYXNzLGEuYW5nbGVQcmV2Kz1yLmNyb3NzKG0seSkqYS5pbnZlcnNlSW5lcnRpYSksbC5pc1N0YXRpY3x8bC5pc1NsZWVwaW5nfHwobT1yLnN1YihwLGwucG9zaXRpb24sZyksbC5wb3NpdGlvblByZXYueC09eS54KmwuaW52ZXJzZU1hc3MsbC5wb3NpdGlvblByZXYueS09eS55KmwuaW52ZXJzZU1hc3MsbC5hbmdsZVByZXYtPXIuY3Jvc3MobSx5KSpsLmludmVyc2VJbmVydGlhKSl9LG4uc29sdmVWZWxvY2l0eT1mdW5jdGlvbihlLHQpe1xuZm9yKHZhciBvPXQqdCxpPXIuX3RlbXBbMF0sYT1yLl90ZW1wWzFdLGw9ci5fdGVtcFsyXSxjPXIuX3RlbXBbM10sZD1yLl90ZW1wWzRdLHU9ci5fdGVtcFs1XSxwPTA7cDxlLmxlbmd0aDtwKyspe3ZhciBmPWVbcF07aWYoZi5pc0FjdGl2ZSYmIWYuaXNTZW5zb3Ipe3ZhciB2PWYuY29sbGlzaW9uLG09di5wYXJlbnRBLHk9di5wYXJlbnRCLGc9di5ub3JtYWwseD12LnRhbmdlbnQsaD1mLmFjdGl2ZUNvbnRhY3RzLGI9MS9oLmxlbmd0aDttLnZlbG9jaXR5Lng9bS5wb3NpdGlvbi54LW0ucG9zaXRpb25QcmV2LngsbS52ZWxvY2l0eS55PW0ucG9zaXRpb24ueS1tLnBvc2l0aW9uUHJldi55LHkudmVsb2NpdHkueD15LnBvc2l0aW9uLngteS5wb3NpdGlvblByZXYueCx5LnZlbG9jaXR5Lnk9eS5wb3NpdGlvbi55LXkucG9zaXRpb25QcmV2LnksbS5hbmd1bGFyVmVsb2NpdHk9bS5hbmdsZS1tLmFuZ2xlUHJldix5LmFuZ3VsYXJWZWxvY2l0eT15LmFuZ2xlLXkuYW5nbGVQcmV2O2Zvcih2YXIgdz0wO3c8aC5sZW5ndGg7dysrKXt2YXIgUz1oW3ddLEM9Uy52ZXJ0ZXgsQT1yLnN1YihDLG0ucG9zaXRpb24sYSksQj1yLnN1YihDLHkucG9zaXRpb24sbCksUD1yLmFkZChtLnZlbG9jaXR5LHIubXVsdChyLnBlcnAoQSksbS5hbmd1bGFyVmVsb2NpdHkpLGMpLE09ci5hZGQoeS52ZWxvY2l0eSxyLm11bHQoci5wZXJwKEIpLHkuYW5ndWxhclZlbG9jaXR5KSxkKSxrPXIuc3ViKFAsTSx1KSxJPXIuZG90KGcsayksVD1yLmRvdCh4LGspLFY9TWF0aC5hYnMoVCksUj1zLnNpZ24oVCksRT0oMStmLnJlc3RpdHV0aW9uKSpJLF89cy5jbGFtcChmLnNlcGFyYXRpb24rSSwwLDEpKm4uX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllcixGPVQsTz0xLzA7Vj5mLmZyaWN0aW9uKmYuZnJpY3Rpb25TdGF0aWMqXypvJiYoTz1WLEY9cy5jbGFtcChmLmZyaWN0aW9uKlIqbywtTyxPKSk7dmFyIEw9ci5jcm9zcyhBLGcpLHE9ci5jcm9zcyhCLGcpLFc9Yi8obS5pbnZlcnNlTWFzcyt5LmludmVyc2VNYXNzK20uaW52ZXJzZUluZXJ0aWEqTCpMK3kuaW52ZXJzZUluZXJ0aWEqcSpxKTtcbmlmKEUqPVcsRio9VywwPkkmJkkqST5uLl9yZXN0aW5nVGhyZXNoKm8pUy5ub3JtYWxJbXB1bHNlPTA7ZWxzZXt2YXIgRD1TLm5vcm1hbEltcHVsc2U7Uy5ub3JtYWxJbXB1bHNlPU1hdGgubWluKFMubm9ybWFsSW1wdWxzZStFLDApLEU9Uy5ub3JtYWxJbXB1bHNlLUR9aWYoVCpUPm4uX3Jlc3RpbmdUaHJlc2hUYW5nZW50Km8pUy50YW5nZW50SW1wdWxzZT0wO2Vsc2V7dmFyIE49Uy50YW5nZW50SW1wdWxzZTtTLnRhbmdlbnRJbXB1bHNlPXMuY2xhbXAoUy50YW5nZW50SW1wdWxzZStGLC1PLE8pLEY9Uy50YW5nZW50SW1wdWxzZS1OfWkueD1nLngqRSt4LngqRixpLnk9Zy55KkUreC55KkYsbS5pc1N0YXRpY3x8bS5pc1NsZWVwaW5nfHwobS5wb3NpdGlvblByZXYueCs9aS54Km0uaW52ZXJzZU1hc3MsbS5wb3NpdGlvblByZXYueSs9aS55Km0uaW52ZXJzZU1hc3MsbS5hbmdsZVByZXYrPXIuY3Jvc3MoQSxpKSptLmludmVyc2VJbmVydGlhKSx5LmlzU3RhdGljfHx5LmlzU2xlZXBpbmd8fCh5LnBvc2l0aW9uUHJldi54LT1pLngqeS5pbnZlcnNlTWFzcyx5LnBvc2l0aW9uUHJldi55LT1pLnkqeS5pbnZlcnNlTWFzcyx5LmFuZ2xlUHJldi09ci5jcm9zcyhCLGkpKnkuaW52ZXJzZUluZXJ0aWEpfX19fX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI0LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjYsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI3fV0sMTE6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIikscj1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpOyFmdW5jdGlvbigpe24uY29sbGlkZXM9ZnVuY3Rpb24odCxuLHMpe3ZhciBhLGwsYyxkLHU9cyxwPSExO2lmKHUpe3ZhciBmPXQucGFyZW50LHY9bi5wYXJlbnQsbT1mLnNwZWVkKmYuc3BlZWQrZi5hbmd1bGFyU3BlZWQqZi5hbmd1bGFyU3BlZWQrdi5zcGVlZCp2LnNwZWVkK3YuYW5ndWxhclNwZWVkKnYuYW5ndWxhclNwZWVkO1xucD11JiZ1LmNvbGxpZGVkJiYuMj5tLGQ9dX1lbHNlIGQ9e2NvbGxpZGVkOiExLGJvZHlBOnQsYm9keUI6bn07aWYodSYmcCl7dmFyIHk9ZC5heGlzQm9keSxnPXk9PT10P246dCx4PVt5LmF4ZXNbdS5heGlzTnVtYmVyXV07aWYoYz1lKHkudmVydGljZXMsZy52ZXJ0aWNlcyx4KSxkLnJldXNlZD0hMCxjLm92ZXJsYXA8PTApcmV0dXJuIGQuY29sbGlkZWQ9ITEsZH1lbHNle2lmKGE9ZSh0LnZlcnRpY2VzLG4udmVydGljZXMsdC5heGVzKSxhLm92ZXJsYXA8PTApcmV0dXJuIGQuY29sbGlkZWQ9ITEsZDtpZihsPWUobi52ZXJ0aWNlcyx0LnZlcnRpY2VzLG4uYXhlcyksbC5vdmVybGFwPD0wKXJldHVybiBkLmNvbGxpZGVkPSExLGQ7YS5vdmVybGFwPGwub3ZlcmxhcD8oYz1hLGQuYXhpc0JvZHk9dCk6KGM9bCxkLmF4aXNCb2R5PW4pLGQuYXhpc051bWJlcj1jLmF4aXNOdW1iZXJ9ZC5ib2R5QT10LmlkPG4uaWQ/dDpuLGQuYm9keUI9dC5pZDxuLmlkP246dCxkLmNvbGxpZGVkPSEwLGQubm9ybWFsPWMuYXhpcyxkLmRlcHRoPWMub3ZlcmxhcCxkLnBhcmVudEE9ZC5ib2R5QS5wYXJlbnQsZC5wYXJlbnRCPWQuYm9keUIucGFyZW50LHQ9ZC5ib2R5QSxuPWQuYm9keUIsci5kb3QoZC5ub3JtYWwsci5zdWIobi5wb3NpdGlvbix0LnBvc2l0aW9uKSk+MCYmKGQubm9ybWFsPXIubmVnKGQubm9ybWFsKSksZC50YW5nZW50PXIucGVycChkLm5vcm1hbCksZC5wZW5ldHJhdGlvbj17eDpkLm5vcm1hbC54KmQuZGVwdGgseTpkLm5vcm1hbC55KmQuZGVwdGh9O3ZhciBoPW8odCxuLGQubm9ybWFsKSxiPWQuc3VwcG9ydHN8fFtdO2lmKGIubGVuZ3RoPTAsaS5jb250YWlucyh0LnZlcnRpY2VzLGhbMF0pJiZiLnB1c2goaFswXSksaS5jb250YWlucyh0LnZlcnRpY2VzLGhbMV0pJiZiLnB1c2goaFsxXSksYi5sZW5ndGg8Mil7dmFyIHc9byhuLHQsci5uZWcoZC5ub3JtYWwpKTtpLmNvbnRhaW5zKG4udmVydGljZXMsd1swXSkmJmIucHVzaCh3WzBdKSxiLmxlbmd0aDwyJiZpLmNvbnRhaW5zKG4udmVydGljZXMsd1sxXSkmJmIucHVzaCh3WzFdKTtcbn1yZXR1cm4gYi5sZW5ndGg8MSYmKGI9W2hbMF1dKSxkLnN1cHBvcnRzPWIsZH07dmFyIGU9ZnVuY3Rpb24oZSxvLG4pe2Zvcih2YXIgaSxzLGE9ci5fdGVtcFswXSxsPXIuX3RlbXBbMV0sYz17b3ZlcmxhcDpOdW1iZXIuTUFYX1ZBTFVFfSxkPTA7ZDxuLmxlbmd0aDtkKyspe2lmKHM9bltkXSx0KGEsZSxzKSx0KGwsbyxzKSxpPU1hdGgubWluKGEubWF4LWwubWluLGwubWF4LWEubWluKSwwPj1pKXJldHVybiBjLm92ZXJsYXA9aSxjO2k8Yy5vdmVybGFwJiYoYy5vdmVybGFwPWksYy5heGlzPXMsYy5heGlzTnVtYmVyPWQpfXJldHVybiBjfSx0PWZ1bmN0aW9uKGUsdCxvKXtmb3IodmFyIG49ci5kb3QodFswXSxvKSxpPW4scz0xO3M8dC5sZW5ndGg7cys9MSl7dmFyIGE9ci5kb3QodFtzXSxvKTthPmk/aT1hOm4+YSYmKG49YSl9ZS5taW49bixlLm1heD1pfSxvPWZ1bmN0aW9uKGUsdCxvKXtmb3IodmFyIG4saSxzLGEsbD1OdW1iZXIuTUFYX1ZBTFVFLGM9ci5fdGVtcFswXSxkPXQudmVydGljZXMsdT1lLnBvc2l0aW9uLHA9MDtwPGQubGVuZ3RoO3ArKylpPWRbcF0sYy54PWkueC11LngsYy55PWkueS11Lnksbj0tci5kb3QobyxjKSxsPm4mJihsPW4scz1pKTt2YXIgZj1zLmluZGV4LTE+PTA/cy5pbmRleC0xOmQubGVuZ3RoLTE7aT1kW2ZdLGMueD1pLngtdS54LGMueT1pLnktdS55LGw9LXIuZG90KG8sYyksYT1pO3ZhciB2PShzLmluZGV4KzEpJWQubGVuZ3RoO3JldHVybiBpPWRbdl0sYy54PWkueC11LngsYy55PWkueS11Lnksbj0tci5kb3QobyxjKSxsPm4mJihhPWkpLFtzLGFdfX0oKX0se1wiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjYsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI3fV0sMTI6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIikscj1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpLHM9ZShcIi4uL2NvcmUvU2xlZXBpbmdcIiksYT1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLGw9ZShcIi4uL2dlb21ldHJ5L0F4ZXNcIiksYz1lKFwiLi4vY29yZS9Db21tb25cIik7XG4hZnVuY3Rpb24oKXt2YXIgZT0xZS02LHQ9LjAwMTtuLmNyZWF0ZT1mdW5jdGlvbih0KXt2YXIgbz10O28uYm9keUEmJiFvLnBvaW50QSYmKG8ucG9pbnRBPXt4OjAseTowfSksby5ib2R5QiYmIW8ucG9pbnRCJiYoby5wb2ludEI9e3g6MCx5OjB9KTt2YXIgbj1vLmJvZHlBP3IuYWRkKG8uYm9keUEucG9zaXRpb24sby5wb2ludEEpOm8ucG9pbnRBLGk9by5ib2R5Qj9yLmFkZChvLmJvZHlCLnBvc2l0aW9uLG8ucG9pbnRCKTpvLnBvaW50QixzPXIubWFnbml0dWRlKHIuc3ViKG4saSkpO28ubGVuZ3RoPW8ubGVuZ3RofHxzfHxlO3ZhciBhPXt2aXNpYmxlOiEwLGxpbmVXaWR0aDoyLHN0cm9rZVN0eWxlOlwiIzY2NlwifTtyZXR1cm4gby5yZW5kZXI9Yy5leHRlbmQoYSxvLnJlbmRlciksby5pZD1vLmlkfHxjLm5leHRJZCgpLG8ubGFiZWw9by5sYWJlbHx8XCJDb25zdHJhaW50XCIsby50eXBlPVwiY29uc3RyYWludFwiLG8uc3RpZmZuZXNzPW8uc3RpZmZuZXNzfHwxLG8uYW5ndWxhclN0aWZmbmVzcz1vLmFuZ3VsYXJTdGlmZm5lc3N8fDAsby5hbmdsZUE9by5ib2R5QT9vLmJvZHlBLmFuZ2xlOm8uYW5nbGVBLG8uYW5nbGVCPW8uYm9keUI/by5ib2R5Qi5hbmdsZTpvLmFuZ2xlQixvfSxuLnNvbHZlQWxsPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspbi5zb2x2ZShlW29dLHQpfSxuLnNvbHZlPWZ1bmN0aW9uKG8sbil7dmFyIGk9by5ib2R5QSxzPW8uYm9keUIsYT1vLnBvaW50QSxsPW8ucG9pbnRCO2kmJiFpLmlzU3RhdGljJiYoby5wb2ludEE9ci5yb3RhdGUoYSxpLmFuZ2xlLW8uYW5nbGVBKSxvLmFuZ2xlQT1pLmFuZ2xlKSxzJiYhcy5pc1N0YXRpYyYmKG8ucG9pbnRCPXIucm90YXRlKGwscy5hbmdsZS1vLmFuZ2xlQiksby5hbmdsZUI9cy5hbmdsZSk7dmFyIGM9YSxkPWw7aWYoaSYmKGM9ci5hZGQoaS5wb3NpdGlvbixhKSkscyYmKGQ9ci5hZGQocy5wb3NpdGlvbixsKSksYyYmZCl7dmFyIHU9ci5zdWIoYyxkKSxwPXIubWFnbml0dWRlKHUpOzA9PT1wJiYocD1lKTtcbnZhciBmPShwLW8ubGVuZ3RoKS9wLHY9ci5kaXYodSxwKSxtPXIubXVsdCh1LC41KmYqby5zdGlmZm5lc3MqbipuKTtpZighKE1hdGguYWJzKDEtcC9vLmxlbmd0aCk8dCpuKSl7dmFyIHksZyx4LGgsYix3LFMsQztpJiYhaS5pc1N0YXRpYz8oeD17eDpjLngtaS5wb3NpdGlvbi54K20ueCx5OmMueS1pLnBvc2l0aW9uLnkrbS55fSxpLnZlbG9jaXR5Lng9aS5wb3NpdGlvbi54LWkucG9zaXRpb25QcmV2LngsaS52ZWxvY2l0eS55PWkucG9zaXRpb24ueS1pLnBvc2l0aW9uUHJldi55LGkuYW5ndWxhclZlbG9jaXR5PWkuYW5nbGUtaS5hbmdsZVByZXYseT1yLmFkZChpLnZlbG9jaXR5LHIubXVsdChyLnBlcnAoeCksaS5hbmd1bGFyVmVsb2NpdHkpKSxiPXIuZG90KHgsdiksUz1pLmludmVyc2VNYXNzK2kuaW52ZXJzZUluZXJ0aWEqYipiKTooeT17eDowLHk6MH0sUz1pP2kuaW52ZXJzZU1hc3M6MCkscyYmIXMuaXNTdGF0aWM/KGg9e3g6ZC54LXMucG9zaXRpb24ueC1tLngseTpkLnktcy5wb3NpdGlvbi55LW0ueX0scy52ZWxvY2l0eS54PXMucG9zaXRpb24ueC1zLnBvc2l0aW9uUHJldi54LHMudmVsb2NpdHkueT1zLnBvc2l0aW9uLnktcy5wb3NpdGlvblByZXYueSxzLmFuZ3VsYXJWZWxvY2l0eT1zLmFuZ2xlLXMuYW5nbGVQcmV2LGc9ci5hZGQocy52ZWxvY2l0eSxyLm11bHQoci5wZXJwKGgpLHMuYW5ndWxhclZlbG9jaXR5KSksdz1yLmRvdChoLHYpLEM9cy5pbnZlcnNlTWFzcytzLmludmVyc2VJbmVydGlhKncqdyk6KGc9e3g6MCx5OjB9LEM9cz9zLmludmVyc2VNYXNzOjApO3ZhciBBPXIuc3ViKGcseSksQj1yLmRvdCh2LEEpLyhTK0MpO0I+MCYmKEI9MCk7dmFyIFAsTT17eDp2LngqQix5OnYueSpCfTtpJiYhaS5pc1N0YXRpYyYmKFA9ci5jcm9zcyh4LE0pKmkuaW52ZXJzZUluZXJ0aWEqKDEtby5hbmd1bGFyU3RpZmZuZXNzKSxpLmNvbnN0cmFpbnRJbXB1bHNlLngtPW0ueCxpLmNvbnN0cmFpbnRJbXB1bHNlLnktPW0ueSxpLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlKz1QLFxuaS5wb3NpdGlvbi54LT1tLngsaS5wb3NpdGlvbi55LT1tLnksaS5hbmdsZSs9UCkscyYmIXMuaXNTdGF0aWMmJihQPXIuY3Jvc3MoaCxNKSpzLmludmVyc2VJbmVydGlhKigxLW8uYW5ndWxhclN0aWZmbmVzcykscy5jb25zdHJhaW50SW1wdWxzZS54Kz1tLngscy5jb25zdHJhaW50SW1wdWxzZS55Kz1tLnkscy5jb25zdHJhaW50SW1wdWxzZS5hbmdsZS09UCxzLnBvc2l0aW9uLngrPW0ueCxzLnBvc2l0aW9uLnkrPW0ueSxzLmFuZ2xlLT1QKX19fSxuLnBvc3RTb2x2ZUFsbD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7dmFyIG89ZVt0XSxuPW8uY29uc3RyYWludEltcHVsc2U7aWYoMCE9PW4ueHx8MCE9PW4ueXx8MCE9PW4uYW5nbGUpe3Muc2V0KG8sITEpO2Zvcih2YXIgYz0wO2M8by5wYXJ0cy5sZW5ndGg7YysrKXt2YXIgZD1vLnBhcnRzW2NdO2kudHJhbnNsYXRlKGQudmVydGljZXMsbiksYz4wJiYoZC5wb3NpdGlvbi54Kz1uLngsZC5wb3NpdGlvbi55Kz1uLnkpLDAhPT1uLmFuZ2xlJiYoaS5yb3RhdGUoZC52ZXJ0aWNlcyxuLmFuZ2xlLG8ucG9zaXRpb24pLGwucm90YXRlKGQuYXhlcyxuLmFuZ2xlKSxjPjAmJnIucm90YXRlQWJvdXQoZC5wb3NpdGlvbixuLmFuZ2xlLG8ucG9zaXRpb24sZC5wb3NpdGlvbikpLGEudXBkYXRlKGQuYm91bmRzLGQudmVydGljZXMsby52ZWxvY2l0eSl9bi5hbmdsZT0wLG4ueD0wLG4ueT0wfX19fSgpfSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9TbGVlcGluZ1wiOjIwLFwiLi4vZ2VvbWV0cnkvQXhlc1wiOjIzLFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6Mjd9XSwxMzpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiKSxyPWUoXCIuLi9jb3JlL1NsZWVwaW5nXCIpLHM9ZShcIi4uL2NvcmUvTW91c2VcIiksYT1lKFwiLi4vY29yZS9FdmVudHNcIiksbD1lKFwiLi4vY29sbGlzaW9uL0RldGVjdG9yXCIpLGM9ZShcIi4vQ29uc3RyYWludFwiKSxkPWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSx1PWUoXCIuLi9jb3JlL0NvbW1vblwiKSxwPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIik7XG4hZnVuY3Rpb24oKXtuLmNyZWF0ZT1mdW5jdGlvbih0LG8pe3ZhciBpPSh0P3QubW91c2U6bnVsbCl8fChvP28ubW91c2U6bnVsbCk7aXx8KHQmJnQucmVuZGVyJiZ0LnJlbmRlci5jYW52YXM/aT1zLmNyZWF0ZSh0LnJlbmRlci5jYW52YXMpOm8mJm8uZWxlbWVudD9pPXMuY3JlYXRlKG8uZWxlbWVudCk6KGk9cy5jcmVhdGUoKSx1LmxvZyhcIk1vdXNlQ29uc3RyYWludC5jcmVhdGU6IG9wdGlvbnMubW91c2Ugd2FzIHVuZGVmaW5lZCwgb3B0aW9ucy5lbGVtZW50IHdhcyB1bmRlZmluZWQsIG1heSBub3QgZnVuY3Rpb24gYXMgZXhwZWN0ZWRcIixcIndhcm5cIikpKTt2YXIgcj1jLmNyZWF0ZSh7bGFiZWw6XCJNb3VzZSBDb25zdHJhaW50XCIscG9pbnRBOmkucG9zaXRpb24scG9pbnRCOnt4OjAseTowfSxsZW5ndGg6LjAxLHN0aWZmbmVzczouMSxhbmd1bGFyU3RpZmZuZXNzOjEscmVuZGVyOntzdHJva2VTdHlsZTpcIiM5MEVFOTBcIixsaW5lV2lkdGg6M319KSxsPXt0eXBlOlwibW91c2VDb25zdHJhaW50XCIsbW91c2U6aSxlbGVtZW50Om51bGwsYm9keTpudWxsLGNvbnN0cmFpbnQ6cixjb2xsaXNpb25GaWx0ZXI6e2NhdGVnb3J5OjEsbWFzazo0Mjk0OTY3Mjk1LGdyb3VwOjB9fSxwPXUuZXh0ZW5kKGwsbyk7cmV0dXJuIGEub24odCxcInRpY2tcIixmdW5jdGlvbigpe3ZhciBvPWQuYWxsQm9kaWVzKHQud29ybGQpO24udXBkYXRlKHAsbyksZShwKX0pLHB9LG4udXBkYXRlPWZ1bmN0aW9uKGUsdCl7dmFyIG89ZS5tb3VzZSxuPWUuY29uc3RyYWludCxzPWUuYm9keTtpZigwPT09by5idXR0b24pe2lmKG4uYm9keUIpci5zZXQobi5ib2R5QiwhMSksbi5wb2ludEE9by5wb3NpdGlvbjtlbHNlIGZvcih2YXIgYz0wO2M8dC5sZW5ndGg7YysrKWlmKHM9dFtjXSxwLmNvbnRhaW5zKHMuYm91bmRzLG8ucG9zaXRpb24pJiZsLmNhbkNvbGxpZGUocy5jb2xsaXNpb25GaWx0ZXIsZS5jb2xsaXNpb25GaWx0ZXIpKWZvcih2YXIgZD1zLnBhcnRzLmxlbmd0aD4xPzE6MDtkPHMucGFydHMubGVuZ3RoO2QrKyl7XG52YXIgdT1zLnBhcnRzW2RdO2lmKGkuY29udGFpbnModS52ZXJ0aWNlcyxvLnBvc2l0aW9uKSl7bi5wb2ludEE9by5wb3NpdGlvbixuLmJvZHlCPWUuYm9keT1zLG4ucG9pbnRCPXt4Om8ucG9zaXRpb24ueC1zLnBvc2l0aW9uLngseTpvLnBvc2l0aW9uLnktcy5wb3NpdGlvbi55fSxuLmFuZ2xlQj1zLmFuZ2xlLHIuc2V0KHMsITEpLGEudHJpZ2dlcihlLFwic3RhcnRkcmFnXCIse21vdXNlOm8sYm9keTpzfSk7YnJlYWt9fX1lbHNlIG4uYm9keUI9ZS5ib2R5PW51bGwsbi5wb2ludEI9bnVsbCxzJiZhLnRyaWdnZXIoZSxcImVuZGRyYWdcIix7bW91c2U6byxib2R5OnN9KX07dmFyIGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5tb3VzZSxvPXQuc291cmNlRXZlbnRzO28ubW91c2Vtb3ZlJiZhLnRyaWdnZXIoZSxcIm1vdXNlbW92ZVwiLHttb3VzZTp0fSksby5tb3VzZWRvd24mJmEudHJpZ2dlcihlLFwibW91c2Vkb3duXCIse21vdXNlOnR9KSxvLm1vdXNldXAmJmEudHJpZ2dlcihlLFwibW91c2V1cFwiLHttb3VzZTp0fSkscy5jbGVhclNvdXJjZUV2ZW50cyh0KX19KCl9LHtcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2NvbGxpc2lvbi9EZXRlY3RvclwiOjUsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4uL2NvcmUvTW91c2VcIjoxOCxcIi4uL2NvcmUvU2xlZXBpbmdcIjoyMCxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI0LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyNyxcIi4vQ29uc3RyYWludFwiOjEyfV0sMTQ6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bixmdW5jdGlvbigpe24uX25leHRJZD0wLG4uX3NlZWQ9MCxuLmV4dGVuZD1mdW5jdGlvbihlLHQpe3ZhciBvLGkscjtcImJvb2xlYW5cIj09dHlwZW9mIHQ/KG89MixyPXQpOihvPTEscj0hMCksaT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsbyk7Zm9yKHZhciBzPTA7czxpLmxlbmd0aDtzKyspe3ZhciBhPWlbc107aWYoYSlmb3IodmFyIGwgaW4gYSlyJiZhW2xdJiZhW2xdLmNvbnN0cnVjdG9yPT09T2JqZWN0P2VbbF0mJmVbbF0uY29uc3RydWN0b3IhPT1PYmplY3Q/ZVtsXT1hW2xdOihlW2xdPWVbbF18fHt9LFxubi5leHRlbmQoZVtsXSxyLGFbbF0pKTplW2xdPWFbbF19cmV0dXJuIGV9LG4uY2xvbmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5leHRlbmQoe30sdCxlKX0sbi5rZXlzPWZ1bmN0aW9uKGUpe2lmKE9iamVjdC5rZXlzKXJldHVybiBPYmplY3Qua2V5cyhlKTt2YXIgdD1bXTtmb3IodmFyIG8gaW4gZSl0LnB1c2gobyk7cmV0dXJuIHR9LG4udmFsdWVzPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKE9iamVjdC5rZXlzKXtmb3IodmFyIG89T2JqZWN0LmtleXMoZSksbj0wO248by5sZW5ndGg7bisrKXQucHVzaChlW29bbl1dKTtyZXR1cm4gdH1mb3IodmFyIGkgaW4gZSl0LnB1c2goZVtpXSk7cmV0dXJuIHR9LG4uc2hhZGVDb2xvcj1mdW5jdGlvbihlLHQpe3ZhciBvPXBhcnNlSW50KGUuc2xpY2UoMSksMTYpLG49TWF0aC5yb3VuZCgyLjU1KnQpLGk9KG8+PjE2KStuLHI9KG8+PjgmMjU1KStuLHM9KDI1NSZvKStuO3JldHVyblwiI1wiKygxNjc3NzIxNis2NTUzNiooMjU1Pmk/MT5pPzA6aToyNTUpKzI1NiooMjU1PnI/MT5yPzA6cjoyNTUpKygyNTU+cz8xPnM/MDpzOjI1NSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKX0sbi5zaHVmZmxlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aC0xO3Q+MDt0LS0pe3ZhciBvPU1hdGguZmxvb3Iobi5yYW5kb20oKSoodCsxKSksaT1lW3RdO2VbdF09ZVtvXSxlW29dPWl9cmV0dXJuIGV9LG4uY2hvb3NlPWZ1bmN0aW9uKGUpe3JldHVybiBlW01hdGguZmxvb3Iobi5yYW5kb20oKSplLmxlbmd0aCldfSxuLmlzRWxlbWVudD1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudH1jYXRjaCh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZSYmMT09PWUubm9kZVR5cGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlLnN0eWxlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5vd25lckRvY3VtZW50fX0sbi5pc0FycmF5PWZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKTtcbn0sbi5jbGFtcD1mdW5jdGlvbihlLHQsbyl7cmV0dXJuIHQ+ZT90OmU+bz9vOmV9LG4uc2lnbj1mdW5jdGlvbihlKXtyZXR1cm4gMD5lPy0xOjF9LG4ubm93PWZ1bmN0aW9uKCl7dmFyIGU9d2luZG93LnBlcmZvcm1hbmNlfHx7fTtyZXR1cm4gZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gZS5ub3d8fGUud2Via2l0Tm93fHxlLm1zTm93fHxlLm9Ob3d8fGUubW96Tm93fHxmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX19KCksZS5ub3coKX0sbi5yYW5kb209ZnVuY3Rpb24odCxvKXtyZXR1cm4gdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgdD90OjAsbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygbz9vOjEsdCtlKCkqKG8tdCl9LG4uY29sb3JUb051bWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLnJlcGxhY2UoXCIjXCIsXCJcIiksMz09ZS5sZW5ndGgmJihlPWUuY2hhckF0KDApK2UuY2hhckF0KDApK2UuY2hhckF0KDEpK2UuY2hhckF0KDEpK2UuY2hhckF0KDIpK2UuY2hhckF0KDIpKSxwYXJzZUludChlLDE2KX0sbi5sb2c9ZnVuY3Rpb24oZSx0KXtpZihjb25zb2xlJiZjb25zb2xlLmxvZyYmY29uc29sZS53YXJuKXN3aXRjaCh0KXtjYXNlXCJ3YXJuXCI6Y29uc29sZS53YXJuKFwiTWF0dGVyLmpzOlwiLGUpO2JyZWFrO2Nhc2VcImVycm9yXCI6Y29uc29sZS5sb2coXCJNYXR0ZXIuanM6XCIsZSl9fSxuLm5leHRJZD1mdW5jdGlvbigpe3JldHVybiBuLl9uZXh0SWQrK30sbi5pbmRleE9mPWZ1bmN0aW9uKGUsdCl7aWYoZS5pbmRleE9mKXJldHVybiBlLmluZGV4T2YodCk7Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspaWYoZVtvXT09PXQpcmV0dXJuIG87cmV0dXJuLTF9O3ZhciBlPWZ1bmN0aW9uKCl7cmV0dXJuIG4uX3NlZWQ9KDkzMDEqbi5fc2VlZCs0OTI5NyklMjMzMjgwLG4uX3NlZWQvMjMzMjgwfX0oKX0se31dLDE1OltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4uL2JvZHkvV29ybGRcIikscj1lKFwiLi9TbGVlcGluZ1wiKSxzPWUoXCIuLi9jb2xsaXNpb24vUmVzb2x2ZXJcIiksYT1lKFwiLi4vcmVuZGVyL1JlbmRlclwiKSxsPWUoXCIuLi9jb2xsaXNpb24vUGFpcnNcIiksYz0oZShcIi4vTWV0cmljc1wiKSxcbmUoXCIuLi9jb2xsaXNpb24vR3JpZFwiKSksZD1lKFwiLi9FdmVudHNcIiksdT1lKFwiLi4vYm9keS9Db21wb3NpdGVcIikscD1lKFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCIpLGY9ZShcIi4vQ29tbW9uXCIpLHY9ZShcIi4uL2JvZHkvQm9keVwiKTshZnVuY3Rpb24oKXtuLmNyZWF0ZT1mdW5jdGlvbihlLHQpe3Q9Zi5pc0VsZW1lbnQoZSk/dDplLGU9Zi5pc0VsZW1lbnQoZSk/ZTpudWxsLHQ9dHx8e30sKGV8fHQucmVuZGVyKSYmZi5sb2coXCJFbmdpbmUuY3JlYXRlOiBlbmdpbmUucmVuZGVyIGlzIGRlcHJlY2F0ZWQgKHNlZSBkb2NzKVwiLFwid2FyblwiKTt2YXIgbz17cG9zaXRpb25JdGVyYXRpb25zOjYsdmVsb2NpdHlJdGVyYXRpb25zOjQsY29uc3RyYWludEl0ZXJhdGlvbnM6MixlbmFibGVTbGVlcGluZzohMSxldmVudHM6W10sdGltaW5nOnt0aW1lc3RhbXA6MCx0aW1lU2NhbGU6MX0sYnJvYWRwaGFzZTp7Y29udHJvbGxlcjpjfX0sbj1mLmV4dGVuZChvLHQpO2lmKGV8fG4ucmVuZGVyKXt2YXIgcj17ZWxlbWVudDplLGNvbnRyb2xsZXI6YX07bi5yZW5kZXI9Zi5leHRlbmQocixuLnJlbmRlcil9cmV0dXJuIG4ucmVuZGVyJiZuLnJlbmRlci5jb250cm9sbGVyJiYobi5yZW5kZXI9bi5yZW5kZXIuY29udHJvbGxlci5jcmVhdGUobi5yZW5kZXIpKSxuLnJlbmRlciYmKG4ucmVuZGVyLmVuZ2luZT1uKSxuLndvcmxkPXQud29ybGR8fGkuY3JlYXRlKG4ud29ybGQpLG4ucGFpcnM9bC5jcmVhdGUoKSxuLmJyb2FkcGhhc2U9bi5icm9hZHBoYXNlLmNvbnRyb2xsZXIuY3JlYXRlKG4uYnJvYWRwaGFzZSksbi5tZXRyaWNzPW4ubWV0cmljc3x8e2V4dGVuZGVkOiExfSxufSxuLnVwZGF0ZT1mdW5jdGlvbihuLGksYSl7aT1pfHwxZTMvNjAsYT1hfHwxO3ZhciBjLGY9bi53b3JsZCx2PW4udGltaW5nLG09bi5icm9hZHBoYXNlLHk9W107di50aW1lc3RhbXArPWkqdi50aW1lU2NhbGU7dmFyIGc9e3RpbWVzdGFtcDp2LnRpbWVzdGFtcH07ZC50cmlnZ2VyKG4sXCJiZWZvcmVVcGRhdGVcIixnKTtcbnZhciB4PXUuYWxsQm9kaWVzKGYpLGg9dS5hbGxDb25zdHJhaW50cyhmKTtmb3Iobi5lbmFibGVTbGVlcGluZyYmci51cGRhdGUoeCx2LnRpbWVTY2FsZSksdCh4LGYuZ3Jhdml0eSksbyh4LGksdi50aW1lU2NhbGUsYSxmLmJvdW5kcyksYz0wO2M8bi5jb25zdHJhaW50SXRlcmF0aW9ucztjKyspcC5zb2x2ZUFsbChoLHYudGltZVNjYWxlKTtwLnBvc3RTb2x2ZUFsbCh4KSxtLmNvbnRyb2xsZXI/KGYuaXNNb2RpZmllZCYmbS5jb250cm9sbGVyLmNsZWFyKG0pLG0uY29udHJvbGxlci51cGRhdGUobSx4LG4sZi5pc01vZGlmaWVkKSx5PW0ucGFpcnNMaXN0KTp5PXgsZi5pc01vZGlmaWVkJiZ1LnNldE1vZGlmaWVkKGYsITEsITEsITApO3ZhciBiPW0uZGV0ZWN0b3IoeSxuKSx3PW4ucGFpcnMsUz12LnRpbWVzdGFtcDtmb3IobC51cGRhdGUodyxiLFMpLGwucmVtb3ZlT2xkKHcsUyksbi5lbmFibGVTbGVlcGluZyYmci5hZnRlckNvbGxpc2lvbnMody5saXN0LHYudGltZVNjYWxlKSx3LmNvbGxpc2lvblN0YXJ0Lmxlbmd0aD4wJiZkLnRyaWdnZXIobixcImNvbGxpc2lvblN0YXJ0XCIse3BhaXJzOncuY29sbGlzaW9uU3RhcnR9KSxzLnByZVNvbHZlUG9zaXRpb24ody5saXN0KSxjPTA7YzxuLnBvc2l0aW9uSXRlcmF0aW9ucztjKyspcy5zb2x2ZVBvc2l0aW9uKHcubGlzdCx2LnRpbWVTY2FsZSk7Zm9yKHMucG9zdFNvbHZlUG9zaXRpb24oeCkscy5wcmVTb2x2ZVZlbG9jaXR5KHcubGlzdCksYz0wO2M8bi52ZWxvY2l0eUl0ZXJhdGlvbnM7YysrKXMuc29sdmVWZWxvY2l0eSh3Lmxpc3Qsdi50aW1lU2NhbGUpO3JldHVybiB3LmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGg+MCYmZC50cmlnZ2VyKG4sXCJjb2xsaXNpb25BY3RpdmVcIix7cGFpcnM6dy5jb2xsaXNpb25BY3RpdmV9KSx3LmNvbGxpc2lvbkVuZC5sZW5ndGg+MCYmZC50cmlnZ2VyKG4sXCJjb2xsaXNpb25FbmRcIix7cGFpcnM6dy5jb2xsaXNpb25FbmR9KSxlKHgpLGQudHJpZ2dlcihuLFwiYWZ0ZXJVcGRhdGVcIixnKSxufSxcbm4ubWVyZ2U9ZnVuY3Rpb24oZSx0KXtpZihmLmV4dGVuZChlLHQpLHQud29ybGQpe2Uud29ybGQ9dC53b3JsZCxuLmNsZWFyKGUpO2Zvcih2YXIgbz11LmFsbEJvZGllcyhlLndvcmxkKSxpPTA7aTxvLmxlbmd0aDtpKyspe3ZhciBzPW9baV07ci5zZXQocywhMSkscy5pZD1mLm5leHRJZCgpfX19LG4uY2xlYXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS53b3JsZDtsLmNsZWFyKGUucGFpcnMpO3ZhciBvPWUuYnJvYWRwaGFzZTtpZihvLmNvbnRyb2xsZXIpe3ZhciBuPXUuYWxsQm9kaWVzKHQpO28uY29udHJvbGxlci5jbGVhcihvKSxvLmNvbnRyb2xsZXIudXBkYXRlKG8sbixlLCEwKX19O3ZhciBlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgbz1lW3RdO28uZm9yY2UueD0wLG8uZm9yY2UueT0wLG8udG9ycXVlPTB9fSx0PWZ1bmN0aW9uKGUsdCl7dmFyIG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuc2NhbGU/dC5zY2FsZTouMDAxO2lmKCgwIT09dC54fHwwIT09dC55KSYmMCE9PW8pZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07aS5pc1N0YXRpY3x8aS5pc1NsZWVwaW5nfHwoaS5mb3JjZS55Kz1pLm1hc3MqdC55Km8saS5mb3JjZS54Kz1pLm1hc3MqdC54Km8pfX0sbz1mdW5jdGlvbihlLHQsbyxuLGkpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgcz1lW3JdO3MuaXNTdGF0aWN8fHMuaXNTbGVlcGluZ3x8di51cGRhdGUocyx0LG8sbil9fX0oKX0se1wiLi4vYm9keS9Cb2R5XCI6MSxcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2JvZHkvV29ybGRcIjozLFwiLi4vY29sbGlzaW9uL0dyaWRcIjo2LFwiLi4vY29sbGlzaW9uL1BhaXJzXCI6OCxcIi4uL2NvbGxpc2lvbi9SZXNvbHZlclwiOjEwLFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCI6MTIsXCIuLi9yZW5kZXIvUmVuZGVyXCI6MjksXCIuL0NvbW1vblwiOjE0LFwiLi9FdmVudHNcIjoxNixcIi4vTWV0cmljc1wiOjE3LFwiLi9TbGVlcGluZ1wiOjIwfV0sMTY6W2Z1bmN0aW9uKGUsdCxvKXtcbnZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuL0NvbW1vblwiKTshZnVuY3Rpb24oKXtuLm9uPWZ1bmN0aW9uKGUsdCxvKXtmb3IodmFyIG4saT10LnNwbGl0KFwiIFwiKSxyPTA7cjxpLmxlbmd0aDtyKyspbj1pW3JdLGUuZXZlbnRzPWUuZXZlbnRzfHx7fSxlLmV2ZW50c1tuXT1lLmV2ZW50c1tuXXx8W10sZS5ldmVudHNbbl0ucHVzaChvKTtyZXR1cm4gb30sbi5vZmY9ZnVuY3Rpb24oZSx0LG8pe2lmKCF0KXJldHVybiB2b2lkKGUuZXZlbnRzPXt9KTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobz10LHQ9aS5rZXlzKGUuZXZlbnRzKS5qb2luKFwiIFwiKSk7Zm9yKHZhciBuPXQuc3BsaXQoXCIgXCIpLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIHM9ZS5ldmVudHNbbltyXV0sYT1bXTtpZihvJiZzKWZvcih2YXIgbD0wO2w8cy5sZW5ndGg7bCsrKXNbbF0hPT1vJiZhLnB1c2goc1tsXSk7ZS5ldmVudHNbbltyXV09YX19LG4udHJpZ2dlcj1mdW5jdGlvbihlLHQsbyl7dmFyIG4scixzLGE7aWYoZS5ldmVudHMpe298fChvPXt9KSxuPXQuc3BsaXQoXCIgXCIpO2Zvcih2YXIgbD0wO2w8bi5sZW5ndGg7bCsrKWlmKHI9bltsXSxzPWUuZXZlbnRzW3JdKXthPWkuY2xvbmUobywhMSksYS5uYW1lPXIsYS5zb3VyY2U9ZTtmb3IodmFyIGM9MDtjPHMubGVuZ3RoO2MrKylzW2NdLmFwcGx5KGUsW2FdKX19fX0oKX0se1wiLi9Db21tb25cIjoxNH1dLDE3OltmdW5jdGlvbihlLHQsbyl7fSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuL0NvbW1vblwiOjE0fV0sMTg6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj17fTt0LmV4cG9ydHM9bjt2YXIgaT1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24odCl7dmFyIG89e307cmV0dXJuIHR8fGkubG9nKFwiTW91c2UuY3JlYXRlOiBlbGVtZW50IHdhcyB1bmRlZmluZWQsIGRlZmF1bHRpbmcgdG8gZG9jdW1lbnQuYm9keVwiLFwid2FyblwiKSxvLmVsZW1lbnQ9dHx8ZG9jdW1lbnQuYm9keSxvLmFic29sdXRlPXt4OjAseTowXG59LG8ucG9zaXRpb249e3g6MCx5OjB9LG8ubW91c2Vkb3duUG9zaXRpb249e3g6MCx5OjB9LG8ubW91c2V1cFBvc2l0aW9uPXt4OjAseTowfSxvLm9mZnNldD17eDowLHk6MH0sby5zY2FsZT17eDoxLHk6MX0sby53aGVlbERlbHRhPTAsby5idXR0b249LTEsby5waXhlbFJhdGlvPW8uZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBpeGVsLXJhdGlvXCIpfHwxLG8uc291cmNlRXZlbnRzPXttb3VzZW1vdmU6bnVsbCxtb3VzZWRvd246bnVsbCxtb3VzZXVwOm51bGwsbW91c2V3aGVlbDpudWxsfSxvLm1vdXNlbW92ZT1mdW5jdGlvbih0KXt2YXIgbj1lKHQsby5lbGVtZW50LG8ucGl4ZWxSYXRpbyksaT10LmNoYW5nZWRUb3VjaGVzO2kmJihvLmJ1dHRvbj0wLHQucHJldmVudERlZmF1bHQoKSksby5hYnNvbHV0ZS54PW4ueCxvLmFic29sdXRlLnk9bi55LG8ucG9zaXRpb24ueD1vLmFic29sdXRlLngqby5zY2FsZS54K28ub2Zmc2V0Lngsby5wb3NpdGlvbi55PW8uYWJzb2x1dGUueSpvLnNjYWxlLnkrby5vZmZzZXQueSxvLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmU9dH0sby5tb3VzZWRvd249ZnVuY3Rpb24odCl7dmFyIG49ZSh0LG8uZWxlbWVudCxvLnBpeGVsUmF0aW8pLGk9dC5jaGFuZ2VkVG91Y2hlcztpPyhvLmJ1dHRvbj0wLHQucHJldmVudERlZmF1bHQoKSk6by5idXR0b249dC5idXR0b24sby5hYnNvbHV0ZS54PW4ueCxvLmFic29sdXRlLnk9bi55LG8ucG9zaXRpb24ueD1vLmFic29sdXRlLngqby5zY2FsZS54K28ub2Zmc2V0Lngsby5wb3NpdGlvbi55PW8uYWJzb2x1dGUueSpvLnNjYWxlLnkrby5vZmZzZXQueSxvLm1vdXNlZG93blBvc2l0aW9uLng9by5wb3NpdGlvbi54LG8ubW91c2Vkb3duUG9zaXRpb24ueT1vLnBvc2l0aW9uLnksby5zb3VyY2VFdmVudHMubW91c2Vkb3duPXR9LG8ubW91c2V1cD1mdW5jdGlvbih0KXt2YXIgbj1lKHQsby5lbGVtZW50LG8ucGl4ZWxSYXRpbyksaT10LmNoYW5nZWRUb3VjaGVzO2kmJnQucHJldmVudERlZmF1bHQoKSxvLmJ1dHRvbj0tMSxcbm8uYWJzb2x1dGUueD1uLngsby5hYnNvbHV0ZS55PW4ueSxvLnBvc2l0aW9uLng9by5hYnNvbHV0ZS54Km8uc2NhbGUueCtvLm9mZnNldC54LG8ucG9zaXRpb24ueT1vLmFic29sdXRlLnkqby5zY2FsZS55K28ub2Zmc2V0Lnksby5tb3VzZXVwUG9zaXRpb24ueD1vLnBvc2l0aW9uLngsby5tb3VzZXVwUG9zaXRpb24ueT1vLnBvc2l0aW9uLnksby5zb3VyY2VFdmVudHMubW91c2V1cD10fSxvLm1vdXNld2hlZWw9ZnVuY3Rpb24oZSl7by53aGVlbERlbHRhPU1hdGgubWF4KC0xLE1hdGgubWluKDEsZS53aGVlbERlbHRhfHwtZS5kZXRhaWwpKSxlLnByZXZlbnREZWZhdWx0KCl9LG4uc2V0RWxlbWVudChvLG8uZWxlbWVudCksb30sbi5zZXRFbGVtZW50PWZ1bmN0aW9uKGUsdCl7ZS5lbGVtZW50PXQsdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsZS5tb3VzZW1vdmUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGUubW91c2Vkb3duKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsZS5tb3VzZXVwKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsZS5tb3VzZXdoZWVsKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLGUubW91c2V3aGVlbCksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZS5tb3VzZW1vdmUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixlLm1vdXNlZG93biksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixlLm1vdXNldXApfSxuLmNsZWFyU291cmNlRXZlbnRzPWZ1bmN0aW9uKGUpe2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZT1udWxsLGUuc291cmNlRXZlbnRzLm1vdXNlZG93bj1udWxsLGUuc291cmNlRXZlbnRzLm1vdXNldXA9bnVsbCxlLnNvdXJjZUV2ZW50cy5tb3VzZXdoZWVsPW51bGwsZS53aGVlbERlbHRhPTB9LG4uc2V0T2Zmc2V0PWZ1bmN0aW9uKGUsdCl7ZS5vZmZzZXQueD10LngsZS5vZmZzZXQueT10LnksZS5wb3NpdGlvbi54PWUuYWJzb2x1dGUueCplLnNjYWxlLngrZS5vZmZzZXQueCxcbmUucG9zaXRpb24ueT1lLmFic29sdXRlLnkqZS5zY2FsZS55K2Uub2Zmc2V0Lnl9LG4uc2V0U2NhbGU9ZnVuY3Rpb24oZSx0KXtlLnNjYWxlLng9dC54LGUuc2NhbGUueT10LnksZS5wb3NpdGlvbi54PWUuYWJzb2x1dGUueCplLnNjYWxlLngrZS5vZmZzZXQueCxlLnBvc2l0aW9uLnk9ZS5hYnNvbHV0ZS55KmUuc2NhbGUueStlLm9mZnNldC55fTt2YXIgZT1mdW5jdGlvbihlLHQsbyl7dmFyIG4saSxyPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZXx8ZG9jdW1lbnQuYm9keSxhPXZvaWQgMCE9PXdpbmRvdy5wYWdlWE9mZnNldD93aW5kb3cucGFnZVhPZmZzZXQ6cy5zY3JvbGxMZWZ0LGw9dm9pZCAwIT09d2luZG93LnBhZ2VZT2Zmc2V0P3dpbmRvdy5wYWdlWU9mZnNldDpzLnNjcm9sbFRvcCxjPWUuY2hhbmdlZFRvdWNoZXM7cmV0dXJuIGM/KG49Y1swXS5wYWdlWC1yLmxlZnQtYSxpPWNbMF0ucGFnZVktci50b3AtbCk6KG49ZS5wYWdlWC1yLmxlZnQtYSxpPWUucGFnZVktci50b3AtbCkse3g6bi8odC5jbGllbnRXaWR0aC90LndpZHRoKm8pLHk6aS8odC5jbGllbnRIZWlnaHQvdC5oZWlnaHQqbyl9fX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNH1dLDE5OltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4vRXZlbnRzXCIpLHI9ZShcIi4vRW5naW5lXCIpLHM9ZShcIi4vQ29tbW9uXCIpOyFmdW5jdGlvbigpe3ZhciBlLHQ7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2Uocy5ub3coKSl9LDFlMy82MCl9LHQ9d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUpLFxubi5jcmVhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9e2Zwczo2MCxjb3JyZWN0aW9uOjEsZGVsdGFTYW1wbGVTaXplOjYwLGNvdW50ZXJUaW1lc3RhbXA6MCxmcmFtZUNvdW50ZXI6MCxkZWx0YUhpc3Rvcnk6W10sdGltZVByZXY6bnVsbCx0aW1lU2NhbGVQcmV2OjEsZnJhbWVSZXF1ZXN0SWQ6bnVsbCxpc0ZpeGVkOiExLGVuYWJsZWQ6ITB9LG89cy5leHRlbmQodCxlKTtyZXR1cm4gby5kZWx0YT1vLmRlbHRhfHwxZTMvby5mcHMsby5kZWx0YU1pbj1vLmRlbHRhTWlufHwxZTMvby5mcHMsby5kZWx0YU1heD1vLmRlbHRhTWF4fHwxZTMvKC41Km8uZnBzKSxvLmZwcz0xZTMvby5kZWx0YSxvfSxuLnJ1bj1mdW5jdGlvbih0LG8pe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LnBvc2l0aW9uSXRlcmF0aW9ucyYmKG89dCx0PW4uY3JlYXRlKCkpLGZ1bmN0aW9uIGkocil7dC5mcmFtZVJlcXVlc3RJZD1lKGkpLHImJnQuZW5hYmxlZCYmbi50aWNrKHQsbyxyKX0oKSx0fSxuLnRpY2s9ZnVuY3Rpb24oZSx0LG8pe3ZhciBuLHM9dC50aW1pbmcsYT0xLGw9e3RpbWVzdGFtcDpzLnRpbWVzdGFtcH07aS50cmlnZ2VyKGUsXCJiZWZvcmVUaWNrXCIsbCksaS50cmlnZ2VyKHQsXCJiZWZvcmVUaWNrXCIsbCksZS5pc0ZpeGVkP249ZS5kZWx0YToobj1vLWUudGltZVByZXZ8fGUuZGVsdGEsZS50aW1lUHJldj1vLGUuZGVsdGFIaXN0b3J5LnB1c2gobiksZS5kZWx0YUhpc3Rvcnk9ZS5kZWx0YUhpc3Rvcnkuc2xpY2UoLWUuZGVsdGFTYW1wbGVTaXplKSxuPU1hdGgubWluLmFwcGx5KG51bGwsZS5kZWx0YUhpc3RvcnkpLG49bjxlLmRlbHRhTWluP2UuZGVsdGFNaW46bixuPW4+ZS5kZWx0YU1heD9lLmRlbHRhTWF4Om4sYT1uL2UuZGVsdGEsZS5kZWx0YT1uKSwwIT09ZS50aW1lU2NhbGVQcmV2JiYoYSo9cy50aW1lU2NhbGUvZS50aW1lU2NhbGVQcmV2KSwwPT09cy50aW1lU2NhbGUmJihhPTApLGUudGltZVNjYWxlUHJldj1zLnRpbWVTY2FsZSxlLmNvcnJlY3Rpb249YSxlLmZyYW1lQ291bnRlcis9MSxcbm8tZS5jb3VudGVyVGltZXN0YW1wPj0xZTMmJihlLmZwcz1lLmZyYW1lQ291bnRlciooKG8tZS5jb3VudGVyVGltZXN0YW1wKS8xZTMpLGUuY291bnRlclRpbWVzdGFtcD1vLGUuZnJhbWVDb3VudGVyPTApLGkudHJpZ2dlcihlLFwidGlja1wiLGwpLGkudHJpZ2dlcih0LFwidGlja1wiLGwpLHQud29ybGQuaXNNb2RpZmllZCYmdC5yZW5kZXImJnQucmVuZGVyLmNvbnRyb2xsZXImJnQucmVuZGVyLmNvbnRyb2xsZXIuY2xlYXImJnQucmVuZGVyLmNvbnRyb2xsZXIuY2xlYXIodC5yZW5kZXIpLGkudHJpZ2dlcihlLFwiYmVmb3JlVXBkYXRlXCIsbCksci51cGRhdGUodCxuLGEpLGkudHJpZ2dlcihlLFwiYWZ0ZXJVcGRhdGVcIixsKSx0LnJlbmRlciYmdC5yZW5kZXIuY29udHJvbGxlciYmKGkudHJpZ2dlcihlLFwiYmVmb3JlUmVuZGVyXCIsbCksaS50cmlnZ2VyKHQsXCJiZWZvcmVSZW5kZXJcIixsKSx0LnJlbmRlci5jb250cm9sbGVyLndvcmxkKHQucmVuZGVyKSxpLnRyaWdnZXIoZSxcImFmdGVyUmVuZGVyXCIsbCksaS50cmlnZ2VyKHQsXCJhZnRlclJlbmRlclwiLGwpKSxpLnRyaWdnZXIoZSxcImFmdGVyVGlja1wiLGwpLGkudHJpZ2dlcih0LFwiYWZ0ZXJUaWNrXCIsbCl9LG4uc3RvcD1mdW5jdGlvbihlKXt0KGUuZnJhbWVSZXF1ZXN0SWQpfSxuLnN0YXJ0PWZ1bmN0aW9uKGUsdCl7bi5ydW4oZSx0KX19KCl9LHtcIi4vQ29tbW9uXCI6MTQsXCIuL0VuZ2luZVwiOjE1LFwiLi9FdmVudHNcIjoxNn1dLDIwOltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4vRXZlbnRzXCIpOyFmdW5jdGlvbigpe24uX21vdGlvbldha2VUaHJlc2hvbGQ9LjE4LG4uX21vdGlvblNsZWVwVGhyZXNob2xkPS4wOCxuLl9taW5CaWFzPS45LG4udXBkYXRlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBvPXQqdCp0LGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpXSxzPXIuc3BlZWQqci5zcGVlZCtyLmFuZ3VsYXJTcGVlZCpyLmFuZ3VsYXJTcGVlZDtpZigwPT09ci5mb3JjZS54JiYwPT09ci5mb3JjZS55KXtcbnZhciBhPU1hdGgubWluKHIubW90aW9uLHMpLGw9TWF0aC5tYXgoci5tb3Rpb24scyk7ci5tb3Rpb249bi5fbWluQmlhcyphKygxLW4uX21pbkJpYXMpKmwsci5zbGVlcFRocmVzaG9sZD4wJiZyLm1vdGlvbjxuLl9tb3Rpb25TbGVlcFRocmVzaG9sZCpvPyhyLnNsZWVwQ291bnRlcis9MSxyLnNsZWVwQ291bnRlcj49ci5zbGVlcFRocmVzaG9sZCYmbi5zZXQociwhMCkpOnIuc2xlZXBDb3VudGVyPjAmJihyLnNsZWVwQ291bnRlci09MSl9ZWxzZSBuLnNldChyLCExKX19LG4uYWZ0ZXJDb2xsaXNpb25zPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBvPXQqdCp0LGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpXTtpZihyLmlzQWN0aXZlKXt2YXIgcz1yLmNvbGxpc2lvbixhPXMuYm9keUEucGFyZW50LGw9cy5ib2R5Qi5wYXJlbnQ7aWYoIShhLmlzU2xlZXBpbmcmJmwuaXNTbGVlcGluZ3x8YS5pc1N0YXRpY3x8bC5pc1N0YXRpYykmJihhLmlzU2xlZXBpbmd8fGwuaXNTbGVlcGluZykpe3ZhciBjPWEuaXNTbGVlcGluZyYmIWEuaXNTdGF0aWM/YTpsLGQ9Yz09PWE/bDphOyFjLmlzU3RhdGljJiZkLm1vdGlvbj5uLl9tb3Rpb25XYWtlVGhyZXNob2xkKm8mJm4uc2V0KGMsITEpfX19fSxuLnNldD1mdW5jdGlvbihlLHQpe3ZhciBvPWUuaXNTbGVlcGluZzt0PyhlLmlzU2xlZXBpbmc9ITAsZS5zbGVlcENvdW50ZXI9ZS5zbGVlcFRocmVzaG9sZCxlLnBvc2l0aW9uSW1wdWxzZS54PTAsZS5wb3NpdGlvbkltcHVsc2UueT0wLGUucG9zaXRpb25QcmV2Lng9ZS5wb3NpdGlvbi54LGUucG9zaXRpb25QcmV2Lnk9ZS5wb3NpdGlvbi55LGUuYW5nbGVQcmV2PWUuYW5nbGUsZS5zcGVlZD0wLGUuYW5ndWxhclNwZWVkPTAsZS5tb3Rpb249MCxvfHxpLnRyaWdnZXIoZSxcInNsZWVwU3RhcnRcIikpOihlLmlzU2xlZXBpbmc9ITEsZS5zbGVlcENvdW50ZXI9MCxvJiZpLnRyaWdnZXIoZSxcInNsZWVwRW5kXCIpKX19KCl9LHtcIi4vRXZlbnRzXCI6MTZ9XSwyMTpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O1xudC5leHBvcnRzPW47dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCIpLHI9ZShcIi4uL2NvcmUvQ29tbW9uXCIpLHM9ZShcIi4uL2JvZHkvQm9keVwiKSxhPWUoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIiksbD1lKFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCIpOyFmdW5jdGlvbigpe24ucmVjdGFuZ2xlPWZ1bmN0aW9uKGUsdCxvLG4sYSl7YT1hfHx7fTt2YXIgbD17bGFiZWw6XCJSZWN0YW5nbGUgQm9keVwiLHBvc2l0aW9uOnt4OmUseTp0fSx2ZXJ0aWNlczppLmZyb21QYXRoKFwiTCAwIDAgTCBcIitvK1wiIDAgTCBcIitvK1wiIFwiK24rXCIgTCAwIFwiK24pfTtpZihhLmNoYW1mZXIpe3ZhciBjPWEuY2hhbWZlcjtsLnZlcnRpY2VzPWkuY2hhbWZlcihsLnZlcnRpY2VzLGMucmFkaXVzLGMucXVhbGl0eSxjLnF1YWxpdHlNaW4sYy5xdWFsaXR5TWF4KSxkZWxldGUgYS5jaGFtZmVyfXJldHVybiBzLmNyZWF0ZShyLmV4dGVuZCh7fSxsLGEpKX0sbi50cmFwZXpvaWQ9ZnVuY3Rpb24oZSx0LG8sbixhLGwpe2w9bHx8e30sYSo9LjU7dmFyIGMsZD0oMS0yKmEpKm8sdT1vKmEscD11K2QsZj1wK3U7Yz0uNT5hP1wiTCAwIDAgTCBcIit1K1wiIFwiKy1uK1wiIEwgXCIrcCtcIiBcIistbitcIiBMIFwiK2YrXCIgMFwiOlwiTCAwIDAgTCBcIitwK1wiIFwiKy1uK1wiIEwgXCIrZitcIiAwXCI7dmFyIHY9e2xhYmVsOlwiVHJhcGV6b2lkIEJvZHlcIixwb3NpdGlvbjp7eDplLHk6dH0sdmVydGljZXM6aS5mcm9tUGF0aChjKX07aWYobC5jaGFtZmVyKXt2YXIgbT1sLmNoYW1mZXI7di52ZXJ0aWNlcz1pLmNoYW1mZXIodi52ZXJ0aWNlcyxtLnJhZGl1cyxtLnF1YWxpdHksbS5xdWFsaXR5TWluLG0ucXVhbGl0eU1heCksZGVsZXRlIGwuY2hhbWZlcn1yZXR1cm4gcy5jcmVhdGUoci5leHRlbmQoe30sdixsKSl9LG4uY2lyY2xlPWZ1bmN0aW9uKGUsdCxvLGkscyl7aT1pfHx7fTt2YXIgYT17bGFiZWw6XCJDaXJjbGUgQm9keVwiLGNpcmNsZVJhZGl1czpvfTtzPXN8fDI1O3ZhciBsPU1hdGguY2VpbChNYXRoLm1heCgxMCxNYXRoLm1pbihzLG8pKSk7cmV0dXJuIGwlMj09PTEmJihsKz0xKSxcbm4ucG9seWdvbihlLHQsbCxvLHIuZXh0ZW5kKHt9LGEsaSkpfSxuLnBvbHlnb249ZnVuY3Rpb24oZSx0LG8sYSxsKXtpZihsPWx8fHt9LDM+bylyZXR1cm4gbi5jaXJjbGUoZSx0LGEsbCk7Zm9yKHZhciBjPTIqTWF0aC5QSS9vLGQ9XCJcIix1PS41KmMscD0wO28+cDtwKz0xKXt2YXIgZj11K3AqYyx2PU1hdGguY29zKGYpKmEsbT1NYXRoLnNpbihmKSphO2QrPVwiTCBcIit2LnRvRml4ZWQoMykrXCIgXCIrbS50b0ZpeGVkKDMpK1wiIFwifXZhciB5PXtsYWJlbDpcIlBvbHlnb24gQm9keVwiLHBvc2l0aW9uOnt4OmUseTp0fSx2ZXJ0aWNlczppLmZyb21QYXRoKGQpfTtpZihsLmNoYW1mZXIpe3ZhciBnPWwuY2hhbWZlcjt5LnZlcnRpY2VzPWkuY2hhbWZlcih5LnZlcnRpY2VzLGcucmFkaXVzLGcucXVhbGl0eSxnLnF1YWxpdHlNaW4sZy5xdWFsaXR5TWF4KSxkZWxldGUgbC5jaGFtZmVyfXJldHVybiBzLmNyZWF0ZShyLmV4dGVuZCh7fSx5LGwpKX0sbi5mcm9tVmVydGljZXM9ZnVuY3Rpb24oZSx0LG8sbixjLGQsdSl7dmFyIHAsZix2LG0seSxnLHgsaCxiO2ZvcihuPW58fHt9LGY9W10sYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgYz9jOiExLGQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGQ/ZDouMDEsdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgdT91OjEwLHdpbmRvdy5kZWNvbXB8fHIubG9nKFwiQm9kaWVzLmZyb21WZXJ0aWNlczogcG9seS1kZWNvbXAuanMgcmVxdWlyZWQuIENvdWxkIG5vdCBkZWNvbXBvc2UgdmVydGljZXMuIEZhbGxiYWNrIHRvIGNvbnZleCBodWxsLlwiLFwid2FyblwiKSxyLmlzQXJyYXkob1swXSl8fChvPVtvXSksaD0wO2g8by5sZW5ndGg7aCs9MSlpZihtPW9baF0sdj1pLmlzQ29udmV4KG0pLHZ8fCF3aW5kb3cuZGVjb21wKW09dj9pLmNsb2Nrd2lzZVNvcnQobSk6aS5odWxsKG0pLGYucHVzaCh7cG9zaXRpb246e3g6ZSx5OnR9LHZlcnRpY2VzOm19KTtlbHNle3ZhciB3PW5ldyBkZWNvbXAuUG9seWdvbjtmb3IoeT0wO3k8bS5sZW5ndGg7eSsrKXcudmVydGljZXMucHVzaChbbVt5XS54LG1beV0ueV0pO1xudy5tYWtlQ0NXKCksZCE9PSExJiZ3LnJlbW92ZUNvbGxpbmVhclBvaW50cyhkKTt2YXIgUz13LnF1aWNrRGVjb21wKCk7Zm9yKHk9MDt5PFMubGVuZ3RoO3krKyl7dmFyIEM9U1t5XSxBPVtdO2ZvcihnPTA7ZzxDLnZlcnRpY2VzLmxlbmd0aDtnKyspQS5wdXNoKHt4OkMudmVydGljZXNbZ11bMF0seTpDLnZlcnRpY2VzW2ddWzFdfSk7dT4wJiZpLmFyZWEoQSk8dXx8Zi5wdXNoKHtwb3NpdGlvbjppLmNlbnRyZShBKSx2ZXJ0aWNlczpBfSl9fWZvcih5PTA7eTxmLmxlbmd0aDt5KyspZlt5XT1zLmNyZWF0ZShyLmV4dGVuZChmW3ldLG4pKTtpZihjKXt2YXIgQj01O2Zvcih5PTA7eTxmLmxlbmd0aDt5Kyspe3ZhciBQPWZbeV07Zm9yKGc9eSsxO2c8Zi5sZW5ndGg7ZysrKXt2YXIgTT1mW2ddO2lmKGEub3ZlcmxhcHMoUC5ib3VuZHMsTS5ib3VuZHMpKXt2YXIgaz1QLnZlcnRpY2VzLEk9TS52ZXJ0aWNlcztmb3IoeD0wO3g8UC52ZXJ0aWNlcy5sZW5ndGg7eCsrKWZvcihiPTA7YjxNLnZlcnRpY2VzLmxlbmd0aDtiKyspe3ZhciBUPWwubWFnbml0dWRlU3F1YXJlZChsLnN1YihrWyh4KzEpJWsubGVuZ3RoXSxJW2JdKSksVj1sLm1hZ25pdHVkZVNxdWFyZWQobC5zdWIoa1t4XSxJWyhiKzEpJUkubGVuZ3RoXSkpO0I+VCYmQj5WJiYoa1t4XS5pc0ludGVybmFsPSEwLElbYl0uaXNJbnRlcm5hbD0hMCl9fX19fXJldHVybiBmLmxlbmd0aD4xPyhwPXMuY3JlYXRlKHIuZXh0ZW5kKHtwYXJ0czpmLnNsaWNlKDApfSxuKSkscy5zZXRQb3NpdGlvbihwLHt4OmUseTp0fSkscCk6ZlswXX19KCl9LHtcIi4uL2JvZHkvQm9keVwiOjEsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6Mjd9XSwyMjpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSxyPWUoXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIikscz1lKFwiLi4vY29yZS9Db21tb25cIiksYT1lKFwiLi4vYm9keS9Cb2R5XCIpLGw9ZShcIi4vQm9kaWVzXCIpO1xuIWZ1bmN0aW9uKCl7bi5zdGFjaz1mdW5jdGlvbihlLHQsbyxuLHIscyxsKXtmb3IodmFyIGMsZD1pLmNyZWF0ZSh7bGFiZWw6XCJTdGFja1wifSksdT1lLHA9dCxmPTAsdj0wO24+djt2Kyspe2Zvcih2YXIgbT0wLHk9MDtvPnk7eSsrKXt2YXIgZz1sKHUscCx5LHYsYyxmKTtpZihnKXt2YXIgeD1nLmJvdW5kcy5tYXgueS1nLmJvdW5kcy5taW4ueSxoPWcuYm91bmRzLm1heC54LWcuYm91bmRzLm1pbi54O3g+bSYmKG09eCksYS50cmFuc2xhdGUoZyx7eDouNSpoLHk6LjUqeH0pLHU9Zy5ib3VuZHMubWF4LngrcixpLmFkZEJvZHkoZCxnKSxjPWcsZis9MX1lbHNlIHUrPXJ9cCs9bStzLHU9ZX1yZXR1cm4gZH0sbi5jaGFpbj1mdW5jdGlvbihlLHQsbyxuLGEsbCl7Zm9yKHZhciBjPWUuYm9kaWVzLGQ9MTtkPGMubGVuZ3RoO2QrKyl7dmFyIHU9Y1tkLTFdLHA9Y1tkXSxmPXUuYm91bmRzLm1heC55LXUuYm91bmRzLm1pbi55LHY9dS5ib3VuZHMubWF4LngtdS5ib3VuZHMubWluLngsbT1wLmJvdW5kcy5tYXgueS1wLmJvdW5kcy5taW4ueSx5PXAuYm91bmRzLm1heC54LXAuYm91bmRzLm1pbi54LGc9e2JvZHlBOnUscG9pbnRBOnt4OnYqdCx5OmYqb30sYm9keUI6cCxwb2ludEI6e3g6eSpuLHk6bSphfX0seD1zLmV4dGVuZChnLGwpO2kuYWRkQ29uc3RyYWludChlLHIuY3JlYXRlKHgpKX1yZXR1cm4gZS5sYWJlbCs9XCIgQ2hhaW5cIixlfSxuLm1lc2g9ZnVuY3Rpb24oZSx0LG8sbixhKXt2YXIgbCxjLGQsdSxwLGY9ZS5ib2RpZXM7Zm9yKGw9MDtvPmw7bCsrKXtmb3IoYz0xO3Q+YztjKyspZD1mW2MtMStsKnRdLHU9ZltjK2wqdF0saS5hZGRDb25zdHJhaW50KGUsci5jcmVhdGUocy5leHRlbmQoe2JvZHlBOmQsYm9keUI6dX0sYSkpKTtpZihsPjApZm9yKGM9MDt0PmM7YysrKWQ9ZltjKyhsLTEpKnRdLHU9ZltjK2wqdF0saS5hZGRDb25zdHJhaW50KGUsci5jcmVhdGUocy5leHRlbmQoe2JvZHlBOmQsYm9keUI6dX0sYSkpKSxuJiZjPjAmJihwPWZbYy0xKyhsLTEpKnRdLGkuYWRkQ29uc3RyYWludChlLHIuY3JlYXRlKHMuZXh0ZW5kKHtcbmJvZHlBOnAsYm9keUI6dX0sYSkpKSksbiYmdC0xPmMmJihwPWZbYysxKyhsLTEpKnRdLGkuYWRkQ29uc3RyYWludChlLHIuY3JlYXRlKHMuZXh0ZW5kKHtib2R5QTpwLGJvZHlCOnV9LGEpKSkpfXJldHVybiBlLmxhYmVsKz1cIiBNZXNoXCIsZX0sbi5weXJhbWlkPWZ1bmN0aW9uKGUsdCxvLGkscixzLGwpe3JldHVybiBuLnN0YWNrKGUsdCxvLGkscixzLGZ1bmN0aW9uKHQsbixzLGMsZCx1KXt2YXIgcD1NYXRoLm1pbihpLE1hdGguY2VpbChvLzIpKSxmPWQ/ZC5ib3VuZHMubWF4LngtZC5ib3VuZHMubWluLng6MDtpZighKGM+cCkpe2M9cC1jO3ZhciB2PWMsbT1vLTEtYztpZighKHY+c3x8cz5tKSl7MT09PXUmJmEudHJhbnNsYXRlKGQse3g6KHMrKG8lMj09PTE/MTotMSkpKmYseTowfSk7dmFyIHk9ZD9zKmY6MDtyZXR1cm4gbChlK3krcypyLG4scyxjLGQsdSl9fX0pfSxuLm5ld3RvbnNDcmFkbGU9ZnVuY3Rpb24oZSx0LG8sbixzKXtmb3IodmFyIGE9aS5jcmVhdGUoe2xhYmVsOlwiTmV3dG9ucyBDcmFkbGVcIn0pLGM9MDtvPmM7YysrKXt2YXIgZD0xLjksdT1sLmNpcmNsZShlK2MqKG4qZCksdCtzLG4se2luZXJ0aWE6MS8wLHJlc3RpdHV0aW9uOjEsZnJpY3Rpb246MCxmcmljdGlvbkFpcjoxZS00LHNsb3A6MX0pLHA9ci5jcmVhdGUoe3BvaW50QTp7eDplK2MqKG4qZCkseTp0fSxib2R5Qjp1fSk7aS5hZGRCb2R5KGEsdSksaS5hZGRDb25zdHJhaW50KGEscCl9cmV0dXJuIGF9LG4uY2FyPWZ1bmN0aW9uKGUsdCxvLG4scyl7dmFyIGM9YS5uZXh0R3JvdXAoITApLGQ9LTIwLHU9LjUqLW8rZCxwPS41Km8tZCxmPTAsdj1pLmNyZWF0ZSh7bGFiZWw6XCJDYXJcIn0pLG09bC50cmFwZXpvaWQoZSx0LG8sbiwuMyx7Y29sbGlzaW9uRmlsdGVyOntncm91cDpjfSxmcmljdGlvbjouMDEsY2hhbWZlcjp7cmFkaXVzOjEwfX0pLHk9bC5jaXJjbGUoZSt1LHQrZixzLHtjb2xsaXNpb25GaWx0ZXI6e2dyb3VwOmN9LGZyaWN0aW9uOi44LGRlbnNpdHk6LjAxfSksZz1sLmNpcmNsZShlK3AsdCtmLHMse1xuY29sbGlzaW9uRmlsdGVyOntncm91cDpjfSxmcmljdGlvbjouOCxkZW5zaXR5Oi4wMX0pLHg9ci5jcmVhdGUoe2JvZHlBOm0scG9pbnRBOnt4OnUseTpmfSxib2R5Qjp5LHN0aWZmbmVzczouMn0pLGg9ci5jcmVhdGUoe2JvZHlBOm0scG9pbnRBOnt4OnAseTpmfSxib2R5QjpnLHN0aWZmbmVzczouMn0pO3JldHVybiBpLmFkZEJvZHkodixtKSxpLmFkZEJvZHkodix5KSxpLmFkZEJvZHkodixnKSxpLmFkZENvbnN0cmFpbnQodix4KSxpLmFkZENvbnN0cmFpbnQodixoKSx2fSxuLnNvZnRCb2R5PWZ1bmN0aW9uKGUsdCxvLGkscixhLGMsZCx1LHApe3U9cy5leHRlbmQoe2luZXJ0aWE6MS8wfSx1KSxwPXMuZXh0ZW5kKHtzdGlmZm5lc3M6LjR9LHApO3ZhciBmPW4uc3RhY2soZSx0LG8saSxyLGEsZnVuY3Rpb24oZSx0KXtyZXR1cm4gbC5jaXJjbGUoZSx0LGQsdSl9KTtyZXR1cm4gbi5tZXNoKGYsbyxpLGMscCksZi5sYWJlbD1cIlNvZnQgQm9keVwiLGZ9fSgpfSx7XCIuLi9ib2R5L0JvZHlcIjoxLFwiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCI6MTIsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi9Cb2RpZXNcIjoyMX1dLDIzOltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47dmFyIGk9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKSxyPWUoXCIuLi9jb3JlL0NvbW1vblwiKTshZnVuY3Rpb24oKXtuLmZyb21WZXJ0aWNlcz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e30sbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgbj0obysxKSVlLmxlbmd0aCxzPWkubm9ybWFsaXNlKHt4OmVbbl0ueS1lW29dLnkseTplW29dLngtZVtuXS54fSksYT0wPT09cy55PzEvMDpzLngvcy55O2E9YS50b0ZpeGVkKDMpLnRvU3RyaW5nKCksdFthXT1zfXJldHVybiByLnZhbHVlcyh0KX0sbi5yb3RhdGU9ZnVuY3Rpb24oZSx0KXtpZigwIT09dClmb3IodmFyIG89TWF0aC5jb3ModCksbj1NYXRoLnNpbih0KSxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciByLHM9ZVtpXTtcbnI9cy54Km8tcy55Km4scy55PXMueCpuK3MueSpvLHMueD1yfX19KCl9LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyNn1dLDI0OltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW4sZnVuY3Rpb24oKXtuLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17bWluOnt4OjAseTowfSxtYXg6e3g6MCx5OjB9fTtyZXR1cm4gZSYmbi51cGRhdGUodCxlKSx0fSxuLnVwZGF0ZT1mdW5jdGlvbihlLHQsbyl7ZS5taW4ueD0xLzAsZS5tYXgueD0tKDEvMCksZS5taW4ueT0xLzAsZS5tYXgueT0tKDEvMCk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aS54PmUubWF4LngmJihlLm1heC54PWkueCksaS54PGUubWluLngmJihlLm1pbi54PWkueCksaS55PmUubWF4LnkmJihlLm1heC55PWkueSksaS55PGUubWluLnkmJihlLm1pbi55PWkueSl9byYmKG8ueD4wP2UubWF4LngrPW8ueDplLm1pbi54Kz1vLngsby55PjA/ZS5tYXgueSs9by55OmUubWluLnkrPW8ueSl9LG4uY29udGFpbnM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC54Pj1lLm1pbi54JiZ0Lng8PWUubWF4LngmJnQueT49ZS5taW4ueSYmdC55PD1lLm1heC55fSxuLm92ZXJsYXBzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWluLng8PXQubWF4LngmJmUubWF4Lng+PXQubWluLngmJmUubWF4Lnk+PXQubWluLnkmJmUubWluLnk8PXQubWF4Lnl9LG4udHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCl7ZS5taW4ueCs9dC54LGUubWF4LngrPXQueCxlLm1pbi55Kz10LnksZS5tYXgueSs9dC55fSxuLnNoaWZ0PWZ1bmN0aW9uKGUsdCl7dmFyIG89ZS5tYXgueC1lLm1pbi54LG49ZS5tYXgueS1lLm1pbi55O2UubWluLng9dC54LGUubWF4Lng9dC54K28sZS5taW4ueT10LnksZS5tYXgueT10Lnkrbn19KCl9LHt9XSwyNTpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO2UoXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIik7IWZ1bmN0aW9uKCl7bi5wYXRoVG9WZXJ0aWNlcz1mdW5jdGlvbih0LG8pe1xudmFyIG4saSxyLHMsYSxsLGMsZCx1LHAsZix2LG09W10seT0wLGc9MCx4PTA7bz1vfHwxNTt2YXIgaD1mdW5jdGlvbihlLHQsbyl7dmFyIG49byUyPT09MSYmbz4xO2lmKCF1fHxlIT11Lnh8fHQhPXUueSl7dSYmbj8oZj11Lngsdj11LnkpOihmPTAsdj0wKTt2YXIgaT17eDpmK2UseTp2K3R9OyFuJiZ1fHwodT1pKSxtLnB1c2goaSksZz1mK2UseD12K3R9fSxiPWZ1bmN0aW9uKGUpe3ZhciB0PWUucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpO2lmKFwiWlwiIT09dCl7c3dpdGNoKHQpe2Nhc2VcIk1cIjpjYXNlXCJMXCI6Y2FzZVwiVFwiOmNhc2VcIkNcIjpjYXNlXCJTXCI6Y2FzZVwiUVwiOmc9ZS54LHg9ZS55O2JyZWFrO2Nhc2VcIkhcIjpnPWUueDticmVhaztjYXNlXCJWXCI6eD1lLnl9aChnLHgsZS5wYXRoU2VnVHlwZSl9fTtmb3IoZSh0KSxyPXQuZ2V0VG90YWxMZW5ndGgoKSxsPVtdLG49MDtuPHQucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtcztuKz0xKWwucHVzaCh0LnBhdGhTZWdMaXN0LmdldEl0ZW0obikpO2ZvcihjPWwuY29uY2F0KCk7cj55Oyl7aWYocD10LmdldFBhdGhTZWdBdExlbmd0aCh5KSxhPWxbcF0sYSE9ZCl7Zm9yKDtjLmxlbmd0aCYmY1swXSE9YTspYihjLnNoaWZ0KCkpO2Q9YX1zd2l0Y2goYS5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCkpe2Nhc2VcIkNcIjpjYXNlXCJUXCI6Y2FzZVwiU1wiOmNhc2VcIlFcIjpjYXNlXCJBXCI6cz10LmdldFBvaW50QXRMZW5ndGgoeSksaChzLngscy55LDApfXkrPW99Zm9yKG49MCxpPWMubGVuZ3RoO2k+bjsrK24pYihjW25dKTtyZXR1cm4gbX07dmFyIGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG8sbixpLHIscyxhPWUucGF0aFNlZ0xpc3QsbD0wLGM9MCxkPWEubnVtYmVyT2ZJdGVtcyx1PTA7ZD51OysrdSl7dmFyIHA9YS5nZXRJdGVtKHUpLGY9cC5wYXRoU2VnVHlwZUFzTGV0dGVyO2lmKC9bTUxIVkNTUVRBXS8udGVzdChmKSlcInhcImluIHAmJihsPXAueCksXCJ5XCJpbiBwJiYoYz1wLnkpO2Vsc2Ugc3dpdGNoKFwieDFcImluIHAmJihuPWwrcC54MSksXG5cIngyXCJpbiBwJiYocj1sK3AueDIpLFwieTFcImluIHAmJihpPWMrcC55MSksXCJ5MlwiaW4gcCYmKHM9YytwLnkyKSxcInhcImluIHAmJihsKz1wLngpLFwieVwiaW4gcCYmKGMrPXAueSksZil7Y2FzZVwibVwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKGwsYyksdSk7YnJlYWs7Y2FzZVwibFwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzKGwsYyksdSk7YnJlYWs7Y2FzZVwiaFwiOmEucmVwbGFjZUl0ZW0oZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyhsKSx1KTticmVhaztjYXNlXCJ2XCI6YS5yZXBsYWNlSXRlbShlLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicyhjKSx1KTticmVhaztjYXNlXCJjXCI6YS5yZXBsYWNlSXRlbShlLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMobCxjLG4saSxyLHMpLHUpO2JyZWFrO2Nhc2VcInNcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyhsLGMscixzKSx1KTticmVhaztjYXNlXCJxXCI6YS5yZXBsYWNlSXRlbShlLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzKGwsYyxuLGkpLHUpO2JyZWFrO2Nhc2VcInRcIjphLnJlcGxhY2VJdGVtKGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMobCxjKSx1KTticmVhaztjYXNlXCJhXCI6YS5yZXBsYWNlSXRlbShlLmNyZWF0ZVNWR1BhdGhTZWdBcmNBYnMobCxjLHAucjEscC5yMixwLmFuZ2xlLHAubGFyZ2VBcmNGbGFnLHAuc3dlZXBGbGFnKSx1KTticmVhaztjYXNlXCJ6XCI6Y2FzZVwiWlwiOmw9dCxjPW99XCJNXCIhPWYmJlwibVwiIT1mfHwodD1sLG89Yyl9fX0oKX0se1wiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjR9XSwyNjpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uLGZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm57eDplfHwwLHk6dHx8MH19LG4uY2xvbmU9ZnVuY3Rpb24oZSl7cmV0dXJue1xueDplLngseTplLnl9fSxuLm1hZ25pdHVkZT1mdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5zcXJ0KGUueCplLngrZS55KmUueSl9LG4ubWFnbml0dWRlU3F1YXJlZD1mdW5jdGlvbihlKXtyZXR1cm4gZS54KmUueCtlLnkqZS55fSxuLnJvdGF0ZT1mdW5jdGlvbihlLHQpe3ZhciBvPU1hdGguY29zKHQpLG49TWF0aC5zaW4odCk7cmV0dXJue3g6ZS54Km8tZS55Km4seTplLngqbitlLnkqb319LG4ucm90YXRlQWJvdXQ9ZnVuY3Rpb24oZSx0LG8sbil7dmFyIGk9TWF0aC5jb3ModCkscj1NYXRoLnNpbih0KTtufHwobj17fSk7dmFyIHM9by54KygoZS54LW8ueCkqaS0oZS55LW8ueSkqcik7cmV0dXJuIG4ueT1vLnkrKChlLngtby54KSpyKyhlLnktby55KSppKSxuLng9cyxufSxuLm5vcm1hbGlzZT1mdW5jdGlvbihlKXt2YXIgdD1uLm1hZ25pdHVkZShlKTtyZXR1cm4gMD09PXQ/e3g6MCx5OjB9Ont4OmUueC90LHk6ZS55L3R9fSxuLmRvdD1mdW5jdGlvbihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9LG4uY3Jvc3M9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS54KnQueS1lLnkqdC54fSxuLmNyb3NzMz1mdW5jdGlvbihlLHQsbyl7cmV0dXJuKHQueC1lLngpKihvLnktZS55KS0odC55LWUueSkqKG8ueC1lLngpfSxuLmFkZD1mdW5jdGlvbihlLHQsbyl7cmV0dXJuIG98fChvPXt9KSxvLng9ZS54K3QueCxvLnk9ZS55K3QueSxvfSxuLnN1Yj1mdW5jdGlvbihlLHQsbyl7cmV0dXJuIG98fChvPXt9KSxvLng9ZS54LXQueCxvLnk9ZS55LXQueSxvfSxuLm11bHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm57eDplLngqdCx5OmUueSp0fX0sbi5kaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm57eDplLngvdCx5OmUueS90fX0sbi5wZXJwPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dD09PSEwPy0xOjEse3g6dCotZS55LHk6dCplLnh9fSxuLm5lZz1mdW5jdGlvbihlKXtyZXR1cm57eDotZS54LHk6LWUueX19LG4uYW5nbGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpO1xufSxuLl90ZW1wPVtuLmNyZWF0ZSgpLG4uY3JlYXRlKCksbi5jcmVhdGUoKSxuLmNyZWF0ZSgpLG4uY3JlYXRlKCksbi5jcmVhdGUoKV19KCl9LHt9XSwyNzpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuLi9nZW9tZXRyeS9WZWN0b3JcIikscj1lKFwiLi4vY29yZS9Db21tb25cIik7IWZ1bmN0aW9uKCl7bi5jcmVhdGU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89W10sbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dLHI9e3g6aS54LHk6aS55LGluZGV4Om4sYm9keTp0LGlzSW50ZXJuYWw6ITF9O28ucHVzaChyKX1yZXR1cm4gb30sbi5mcm9tUGF0aD1mdW5jdGlvbihlLHQpe3ZhciBvPS9MP1xccyooW1xcLVxcZFxcLmVdKylbXFxzLF0qKFtcXC1cXGRcXC5lXSspKi9naSxpPVtdO3JldHVybiBlLnJlcGxhY2UobyxmdW5jdGlvbihlLHQsbyl7aS5wdXNoKHt4OnBhcnNlRmxvYXQodCkseTpwYXJzZUZsb2F0KG8pfSl9KSxuLmNyZWF0ZShpLHQpfSxuLmNlbnRyZT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbyxyLHM9bi5hcmVhKGUsITApLGE9e3g6MCx5OjB9LGw9MDtsPGUubGVuZ3RoO2wrKylyPShsKzEpJWUubGVuZ3RoLHQ9aS5jcm9zcyhlW2xdLGVbcl0pLG89aS5tdWx0KGkuYWRkKGVbbF0sZVtyXSksdCksYT1pLmFkZChhLG8pO3JldHVybiBpLmRpdihhLDYqcyl9LG4ubWVhbj1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e3g6MCx5OjB9LG89MDtvPGUubGVuZ3RoO28rKyl0LngrPWVbb10ueCx0LnkrPWVbb10ueTtyZXR1cm4gaS5kaXYodCxlLmxlbmd0aCl9LG4uYXJlYT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbz0wLG49ZS5sZW5ndGgtMSxpPTA7aTxlLmxlbmd0aDtpKyspbys9KGVbbl0ueC1lW2ldLngpKihlW25dLnkrZVtpXS55KSxuPWk7cmV0dXJuIHQ/by8yOk1hdGguYWJzKG8pLzJ9LG4uaW5lcnRpYT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbyxuLHI9MCxzPTAsYT1lLGw9MDtsPGEubGVuZ3RoO2wrKyluPShsKzEpJWEubGVuZ3RoLG89TWF0aC5hYnMoaS5jcm9zcyhhW25dLGFbbF0pKSxcbnIrPW8qKGkuZG90KGFbbl0sYVtuXSkraS5kb3QoYVtuXSxhW2xdKStpLmRvdChhW2xdLGFbbF0pKSxzKz1vO3JldHVybiB0LzYqKHIvcyl9LG4udHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbjtpZihvKWZvcihuPTA7bjxlLmxlbmd0aDtuKyspZVtuXS54Kz10LngqbyxlW25dLnkrPXQueSpvO2Vsc2UgZm9yKG49MDtuPGUubGVuZ3RoO24rKyllW25dLngrPXQueCxlW25dLnkrPXQueTtyZXR1cm4gZX0sbi5yb3RhdGU9ZnVuY3Rpb24oZSx0LG8pe2lmKDAhPT10KXtmb3IodmFyIG49TWF0aC5jb3ModCksaT1NYXRoLnNpbih0KSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBzPWVbcl0sYT1zLngtby54LGw9cy55LW8ueTtzLng9by54KyhhKm4tbCppKSxzLnk9by55KyhhKmkrbCpuKX1yZXR1cm4gZX19LG4uY29udGFpbnM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIG49ZVtvXSxpPWVbKG8rMSklZS5sZW5ndGhdO2lmKCh0Lngtbi54KSooaS55LW4ueSkrKHQueS1uLnkpKihuLngtaS54KT4wKXJldHVybiExfXJldHVybiEwfSxuLnNjYWxlPWZ1bmN0aW9uKGUsdCxvLHIpe2lmKDE9PT10JiYxPT09bylyZXR1cm4gZTtyPXJ8fG4uY2VudHJlKGUpO2Zvcih2YXIgcyxhLGw9MDtsPGUubGVuZ3RoO2wrKylzPWVbbF0sYT1pLnN1YihzLHIpLGVbbF0ueD1yLngrYS54KnQsZVtsXS55PXIueSthLnkqbztyZXR1cm4gZX0sbi5jaGFtZmVyPWZ1bmN0aW9uKGUsdCxvLG4scyl7dD10fHxbOF0sdC5sZW5ndGh8fCh0PVt0XSksbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygbz9vOi0xLG49bnx8MixzPXN8fDE0O2Zvcih2YXIgYT1bXSxsPTA7bDxlLmxlbmd0aDtsKyspe3ZhciBjPWVbbC0xPj0wP2wtMTplLmxlbmd0aC0xXSxkPWVbbF0sdT1lWyhsKzEpJWUubGVuZ3RoXSxwPXRbbDx0Lmxlbmd0aD9sOnQubGVuZ3RoLTFdO2lmKDAhPT1wKXt2YXIgZj1pLm5vcm1hbGlzZSh7eDpkLnktYy55LHk6Yy54LWQueH0pLHY9aS5ub3JtYWxpc2Uoe3g6dS55LWQueSxcbnk6ZC54LXUueH0pLG09TWF0aC5zcXJ0KDIqTWF0aC5wb3cocCwyKSkseT1pLm11bHQoci5jbG9uZShmKSxwKSxnPWkubm9ybWFsaXNlKGkubXVsdChpLmFkZChmLHYpLC41KSkseD1pLnN1YihkLGkubXVsdChnLG0pKSxoPW87LTE9PT1vJiYoaD0xLjc1Kk1hdGgucG93KHAsLjMyKSksaD1yLmNsYW1wKGgsbixzKSxoJTI9PT0xJiYoaCs9MSk7Zm9yKHZhciBiPU1hdGguYWNvcyhpLmRvdChmLHYpKSx3PWIvaCxTPTA7aD5TO1MrKylhLnB1c2goaS5hZGQoaS5yb3RhdGUoeSx3KlMpLHgpKX1lbHNlIGEucHVzaChkKX1yZXR1cm4gYX0sbi5jbG9ja3dpc2VTb3J0PWZ1bmN0aW9uKGUpe3ZhciB0PW4ubWVhbihlKTtyZXR1cm4gZS5zb3J0KGZ1bmN0aW9uKGUsbyl7cmV0dXJuIGkuYW5nbGUodCxlKS1pLmFuZ2xlKHQsbyl9KSxlfSxuLmlzQ29udmV4PWZ1bmN0aW9uKGUpe3ZhciB0LG8sbixpLHI9MCxzPWUubGVuZ3RoO2lmKDM+cylyZXR1cm4gbnVsbDtmb3IodD0wO3M+dDt0KyspaWYobz0odCsxKSVzLG49KHQrMiklcyxpPShlW29dLngtZVt0XS54KSooZVtuXS55LWVbb10ueSksaS09KGVbb10ueS1lW3RdLnkpKihlW25dLngtZVtvXS54KSwwPmk/cnw9MTppPjAmJihyfD0yKSwzPT09cilyZXR1cm4hMTtyZXR1cm4gMCE9PXI/ITA6bnVsbH0sbi5odWxsPWZ1bmN0aW9uKGUpe3ZhciB0LG8sbj1bXSxyPVtdO2ZvcihlPWUuc2xpY2UoMCksZS5zb3J0KGZ1bmN0aW9uKGUsdCl7dmFyIG89ZS54LXQueDtyZXR1cm4gMCE9PW8/bzplLnktdC55fSksbz0wO288ZS5sZW5ndGg7bysrKXtmb3IodD1lW29dO3IubGVuZ3RoPj0yJiZpLmNyb3NzMyhyW3IubGVuZ3RoLTJdLHJbci5sZW5ndGgtMV0sdCk8PTA7KXIucG9wKCk7ci5wdXNoKHQpfWZvcihvPWUubGVuZ3RoLTE7bz49MDtvLS0pe2Zvcih0PWVbb107bi5sZW5ndGg+PTImJmkuY3Jvc3MzKG5bbi5sZW5ndGgtMl0sbltuLmxlbmd0aC0xXSx0KTw9MDspbi5wb3AoKTtuLnB1c2godCl9cmV0dXJuIG4ucG9wKCksci5wb3AoKSxcbm4uY29uY2F0KHIpfX0oKX0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI2fV0sMjg6W2Z1bmN0aW9uKGUsdCxvKXt2YXIgbj10LmV4cG9ydHM9e307bi52ZXJzaW9uPVwibWFzdGVyXCIsbi5Cb2R5PWUoXCIuLi9ib2R5L0JvZHlcIiksbi5Db21wb3NpdGU9ZShcIi4uL2JvZHkvQ29tcG9zaXRlXCIpLG4uV29ybGQ9ZShcIi4uL2JvZHkvV29ybGRcIiksbi5Db250YWN0PWUoXCIuLi9jb2xsaXNpb24vQ29udGFjdFwiKSxuLkRldGVjdG9yPWUoXCIuLi9jb2xsaXNpb24vRGV0ZWN0b3JcIiksbi5HcmlkPWUoXCIuLi9jb2xsaXNpb24vR3JpZFwiKSxuLlBhaXJzPWUoXCIuLi9jb2xsaXNpb24vUGFpcnNcIiksbi5QYWlyPWUoXCIuLi9jb2xsaXNpb24vUGFpclwiKSxuLlF1ZXJ5PWUoXCIuLi9jb2xsaXNpb24vUXVlcnlcIiksbi5SZXNvbHZlcj1lKFwiLi4vY29sbGlzaW9uL1Jlc29sdmVyXCIpLG4uU0FUPWUoXCIuLi9jb2xsaXNpb24vU0FUXCIpLG4uQ29uc3RyYWludD1lKFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCIpLG4uTW91c2VDb25zdHJhaW50PWUoXCIuLi9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludFwiKSxuLkNvbW1vbj1lKFwiLi4vY29yZS9Db21tb25cIiksbi5FbmdpbmU9ZShcIi4uL2NvcmUvRW5naW5lXCIpLG4uRXZlbnRzPWUoXCIuLi9jb3JlL0V2ZW50c1wiKSxuLk1vdXNlPWUoXCIuLi9jb3JlL01vdXNlXCIpLG4uUnVubmVyPWUoXCIuLi9jb3JlL1J1bm5lclwiKSxuLlNsZWVwaW5nPWUoXCIuLi9jb3JlL1NsZWVwaW5nXCIpLG4uQm9kaWVzPWUoXCIuLi9mYWN0b3J5L0JvZGllc1wiKSxuLkNvbXBvc2l0ZXM9ZShcIi4uL2ZhY3RvcnkvQ29tcG9zaXRlc1wiKSxuLkF4ZXM9ZShcIi4uL2dlb21ldHJ5L0F4ZXNcIiksbi5Cb3VuZHM9ZShcIi4uL2dlb21ldHJ5L0JvdW5kc1wiKSxuLlN2Zz1lKFwiLi4vZ2VvbWV0cnkvU3ZnXCIpLG4uVmVjdG9yPWUoXCIuLi9nZW9tZXRyeS9WZWN0b3JcIiksbi5WZXJ0aWNlcz1lKFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIiksbi5SZW5kZXI9ZShcIi4uL3JlbmRlci9SZW5kZXJcIiksXG5uLlJlbmRlclBpeGk9ZShcIi4uL3JlbmRlci9SZW5kZXJQaXhpXCIpLG4uV29ybGQuYWRkPW4uQ29tcG9zaXRlLmFkZCxuLldvcmxkLnJlbW92ZT1uLkNvbXBvc2l0ZS5yZW1vdmUsbi5Xb3JsZC5hZGRDb21wb3NpdGU9bi5Db21wb3NpdGUuYWRkQ29tcG9zaXRlLG4uV29ybGQuYWRkQm9keT1uLkNvbXBvc2l0ZS5hZGRCb2R5LG4uV29ybGQuYWRkQ29uc3RyYWludD1uLkNvbXBvc2l0ZS5hZGRDb25zdHJhaW50LG4uV29ybGQuY2xlYXI9bi5Db21wb3NpdGUuY2xlYXIsbi5FbmdpbmUucnVuPW4uUnVubmVyLnJ1bn0se1wiLi4vYm9keS9Cb2R5XCI6MSxcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2JvZHkvV29ybGRcIjozLFwiLi4vY29sbGlzaW9uL0NvbnRhY3RcIjo0LFwiLi4vY29sbGlzaW9uL0RldGVjdG9yXCI6NSxcIi4uL2NvbGxpc2lvbi9HcmlkXCI6NixcIi4uL2NvbGxpc2lvbi9QYWlyXCI6NyxcIi4uL2NvbGxpc2lvbi9QYWlyc1wiOjgsXCIuLi9jb2xsaXNpb24vUXVlcnlcIjo5LFwiLi4vY29sbGlzaW9uL1Jlc29sdmVyXCI6MTAsXCIuLi9jb2xsaXNpb24vU0FUXCI6MTEsXCIuLi9jb25zdHJhaW50L0NvbnN0cmFpbnRcIjoxMixcIi4uL2NvbnN0cmFpbnQvTW91c2VDb25zdHJhaW50XCI6MTMsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9FbmdpbmVcIjoxNSxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9jb3JlL01ldHJpY3NcIjoxNyxcIi4uL2NvcmUvTW91c2VcIjoxOCxcIi4uL2NvcmUvUnVubmVyXCI6MTksXCIuLi9jb3JlL1NsZWVwaW5nXCI6MjAsXCIuLi9mYWN0b3J5L0JvZGllc1wiOjIxLFwiLi4vZmFjdG9yeS9Db21wb3NpdGVzXCI6MjIsXCIuLi9nZW9tZXRyeS9BeGVzXCI6MjMsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNCxcIi4uL2dlb21ldHJ5L1N2Z1wiOjI1LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjYsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI3LFwiLi4vcmVuZGVyL1JlbmRlclwiOjI5LFwiLi4vcmVuZGVyL1JlbmRlclBpeGlcIjozMH1dLDI5OltmdW5jdGlvbihlLHQsbyl7dmFyIG49e307dC5leHBvcnRzPW47XG52YXIgaT1lKFwiLi4vY29yZS9Db21tb25cIikscj1lKFwiLi4vYm9keS9Db21wb3NpdGVcIikscz1lKFwiLi4vZ2VvbWV0cnkvQm91bmRzXCIpLGE9ZShcIi4uL2NvcmUvRXZlbnRzXCIpLGw9ZShcIi4uL2NvbGxpc2lvbi9HcmlkXCIpLGM9ZShcIi4uL2dlb21ldHJ5L1ZlY3RvclwiKTshZnVuY3Rpb24oKXt2YXIgZSx0O1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSl7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGkubm93KCkpfSwxZTMvNjApfSx0PXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKSxuLmNyZWF0ZT1mdW5jdGlvbihlKXt2YXIgdD17Y29udHJvbGxlcjpuLGVuZ2luZTpudWxsLGVsZW1lbnQ6bnVsbCxjYW52YXM6bnVsbCxtb3VzZTpudWxsLGZyYW1lUmVxdWVzdElkOm51bGwsb3B0aW9uczp7d2lkdGg6ODAwLGhlaWdodDo2MDAscGl4ZWxSYXRpbzoxLGJhY2tncm91bmQ6XCIjZmFmYWZhXCIsd2lyZWZyYW1lQmFja2dyb3VuZDpcIiMyMjJcIixoYXNCb3VuZHM6ISFlLmJvdW5kcyxlbmFibGVkOiEwLHdpcmVmcmFtZXM6ITAsc2hvd1NsZWVwaW5nOiEwLHNob3dEZWJ1ZzohMSxzaG93QnJvYWRwaGFzZTohMSxzaG93Qm91bmRzOiExLHNob3dWZWxvY2l0eTohMSxzaG93Q29sbGlzaW9uczohMSxzaG93U2VwYXJhdGlvbnM6ITEsc2hvd0F4ZXM6ITEsc2hvd1Bvc2l0aW9uczohMSxzaG93QW5nbGVJbmRpY2F0b3I6ITEsc2hvd0lkczohMSxzaG93U2hhZG93czohMSxzaG93VmVydGV4TnVtYmVyczohMSxzaG93Q29udmV4SHVsbHM6ITEsc2hvd0ludGVybmFsRWRnZXM6ITEsXG5zaG93TW91c2VQb3NpdGlvbjohMX19LHI9aS5leHRlbmQodCxlKTtyZXR1cm4gci5jYW52YXMmJihyLmNhbnZhcy53aWR0aD1yLm9wdGlvbnMud2lkdGh8fHIuY2FudmFzLndpZHRoLHIuY2FudmFzLmhlaWdodD1yLm9wdGlvbnMuaGVpZ2h0fHxyLmNhbnZhcy5oZWlnaHQpLHIubW91c2U9ZS5tb3VzZSxyLmVuZ2luZT1lLmVuZ2luZSxyLmNhbnZhcz1yLmNhbnZhc3x8byhyLm9wdGlvbnMud2lkdGgsci5vcHRpb25zLmhlaWdodCksci5jb250ZXh0PXIuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxyLnRleHR1cmVzPXt9LHIuYm91bmRzPXIuYm91bmRzfHx7bWluOnt4OjAseTowfSxtYXg6e3g6ci5jYW52YXMud2lkdGgseTpyLmNhbnZhcy5oZWlnaHR9fSwxIT09ci5vcHRpb25zLnBpeGVsUmF0aW8mJm4uc2V0UGl4ZWxSYXRpbyhyLHIub3B0aW9ucy5waXhlbFJhdGlvKSxpLmlzRWxlbWVudChyLmVsZW1lbnQpP3IuZWxlbWVudC5hcHBlbmRDaGlsZChyLmNhbnZhcyk6aS5sb2coXCJSZW5kZXIuY3JlYXRlOiBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgcmVuZGVyLmNhbnZhcyB3YXMgY3JlYXRlZCBidXQgbm90IGFwcGVuZGVkXCIsXCJ3YXJuXCIpLHJ9LG4ucnVuPWZ1bmN0aW9uKHQpeyFmdW5jdGlvbiBvKGkpe3QuZnJhbWVSZXF1ZXN0SWQ9ZShvKSxuLndvcmxkKHQpfSgpfSxuLnN0b3A9ZnVuY3Rpb24oZSl7dChlLmZyYW1lUmVxdWVzdElkKX0sbi5zZXRQaXhlbFJhdGlvPWZ1bmN0aW9uKGUsdCl7dmFyIG89ZS5vcHRpb25zLG49ZS5jYW52YXM7XCJhdXRvXCI9PT10JiYodD1kKG4pKSxvLnBpeGVsUmF0aW89dCxuLnNldEF0dHJpYnV0ZShcImRhdGEtcGl4ZWwtcmF0aW9cIix0KSxuLndpZHRoPW8ud2lkdGgqdCxuLmhlaWdodD1vLmhlaWdodCp0LG4uc3R5bGUud2lkdGg9by53aWR0aCtcInB4XCIsbi5zdHlsZS5oZWlnaHQ9by5oZWlnaHQrXCJweFwiLGUuY29udGV4dC5zY2FsZSh0LHQpfSxuLndvcmxkPWZ1bmN0aW9uKGUpe3ZhciB0LG89ZS5lbmdpbmUsaT1vLndvcmxkLGQ9ZS5jYW52YXMsdT1lLmNvbnRleHQsZj1lLm9wdGlvbnMsdj1yLmFsbEJvZGllcyhpKSxtPXIuYWxsQ29uc3RyYWludHMoaSkseT1mLndpcmVmcmFtZXM/Zi53aXJlZnJhbWVCYWNrZ3JvdW5kOmYuYmFja2dyb3VuZCxnPVtdLHg9W10saD17XG50aW1lc3RhbXA6by50aW1pbmcudGltZXN0YW1wfTtpZihhLnRyaWdnZXIoZSxcImJlZm9yZVJlbmRlclwiLGgpLGUuY3VycmVudEJhY2tncm91bmQhPT15JiZwKGUseSksdS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtaW5cIix1LmZpbGxTdHlsZT1cInRyYW5zcGFyZW50XCIsdS5maWxsUmVjdCgwLDAsZC53aWR0aCxkLmhlaWdodCksdS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2Utb3ZlclwiLGYuaGFzQm91bmRzKXt2YXIgYj1lLmJvdW5kcy5tYXgueC1lLmJvdW5kcy5taW4ueCx3PWUuYm91bmRzLm1heC55LWUuYm91bmRzLm1pbi55LFM9Yi9mLndpZHRoLEM9dy9mLmhlaWdodDtmb3IodD0wO3Q8di5sZW5ndGg7dCsrKXt2YXIgQT12W3RdO3Mub3ZlcmxhcHMoQS5ib3VuZHMsZS5ib3VuZHMpJiZnLnB1c2goQSl9Zm9yKHQ9MDt0PG0ubGVuZ3RoO3QrKyl7dmFyIEI9bVt0XSxQPUIuYm9keUEsTT1CLmJvZHlCLGs9Qi5wb2ludEEsST1CLnBvaW50QjtQJiYoaz1jLmFkZChQLnBvc2l0aW9uLEIucG9pbnRBKSksTSYmKEk9Yy5hZGQoTS5wb3NpdGlvbixCLnBvaW50QikpLGsmJkkmJihzLmNvbnRhaW5zKGUuYm91bmRzLGspfHxzLmNvbnRhaW5zKGUuYm91bmRzLEkpKSYmeC5wdXNoKEIpfXUuc2NhbGUoMS9TLDEvQyksdS50cmFuc2xhdGUoLWUuYm91bmRzLm1pbi54LC1lLmJvdW5kcy5taW4ueSl9ZWxzZSB4PW0sZz12OyFmLndpcmVmcmFtZXN8fG8uZW5hYmxlU2xlZXBpbmcmJmYuc2hvd1NsZWVwaW5nP24uYm9kaWVzKGUsZyx1KTooZi5zaG93Q29udmV4SHVsbHMmJm4uYm9keUNvbnZleEh1bGxzKGUsZyx1KSxuLmJvZHlXaXJlZnJhbWVzKGUsZyx1KSksZi5zaG93Qm91bmRzJiZuLmJvZHlCb3VuZHMoZSxnLHUpLChmLnNob3dBeGVzfHxmLnNob3dBbmdsZUluZGljYXRvcikmJm4uYm9keUF4ZXMoZSxnLHUpLGYuc2hvd1Bvc2l0aW9ucyYmbi5ib2R5UG9zaXRpb25zKGUsZyx1KSxmLnNob3dWZWxvY2l0eSYmbi5ib2R5VmVsb2NpdHkoZSxnLHUpLFxuZi5zaG93SWRzJiZuLmJvZHlJZHMoZSxnLHUpLGYuc2hvd1NlcGFyYXRpb25zJiZuLnNlcGFyYXRpb25zKGUsby5wYWlycy5saXN0LHUpLGYuc2hvd0NvbGxpc2lvbnMmJm4uY29sbGlzaW9ucyhlLG8ucGFpcnMubGlzdCx1KSxmLnNob3dWZXJ0ZXhOdW1iZXJzJiZuLnZlcnRleE51bWJlcnMoZSxnLHUpLGYuc2hvd01vdXNlUG9zaXRpb24mJm4ubW91c2VQb3NpdGlvbihlLGUubW91c2UsdSksbi5jb25zdHJhaW50cyh4LHUpLGYuc2hvd0Jyb2FkcGhhc2UmJm8uYnJvYWRwaGFzZS5jb250cm9sbGVyPT09bCYmbi5ncmlkKGUsby5icm9hZHBoYXNlLHUpLGYuc2hvd0RlYnVnJiZuLmRlYnVnKGUsdSksZi5oYXNCb3VuZHMmJnUuc2V0VHJhbnNmb3JtKGYucGl4ZWxSYXRpbywwLDAsZi5waXhlbFJhdGlvLDAsMCksYS50cmlnZ2VyKGUsXCJhZnRlclJlbmRlclwiLGgpfSxuLmRlYnVnPWZ1bmN0aW9uKGUsdCl7dmFyIG89dCxuPWUuZW5naW5lLGk9bi53b3JsZCxzPW4ubWV0cmljcyxhPWUub3B0aW9ucyxsPShyLmFsbEJvZGllcyhpKSxcIiAgICBcIik7aWYobi50aW1pbmcudGltZXN0YW1wLShlLmRlYnVnVGltZXN0YW1wfHwwKT49NTAwKXt2YXIgYz1cIlwiO3MudGltaW5nJiYoYys9XCJmcHM6IFwiK01hdGgucm91bmQocy50aW1pbmcuZnBzKStsKSxlLmRlYnVnU3RyaW5nPWMsZS5kZWJ1Z1RpbWVzdGFtcD1uLnRpbWluZy50aW1lc3RhbXB9aWYoZS5kZWJ1Z1N0cmluZyl7by5mb250PVwiMTJweCBBcmlhbFwiLGEud2lyZWZyYW1lcz9vLmZpbGxTdHlsZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiOm8uZmlsbFN0eWxlPVwicmdiYSgwLDAsMCwwLjUpXCI7Zm9yKHZhciBkPWUuZGVidWdTdHJpbmcuc3BsaXQoXCJcXG5cIiksdT0wO3U8ZC5sZW5ndGg7dSsrKW8uZmlsbFRleHQoZFt1XSw1MCw1MCsxOCp1KX19LG4uY29uc3RyYWludHM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89dCxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07aWYoaS5yZW5kZXIudmlzaWJsZSYmaS5wb2ludEEmJmkucG9pbnRCKXtcbnZhciByPWkuYm9keUEscz1pLmJvZHlCO3I/KG8uYmVnaW5QYXRoKCksby5tb3ZlVG8oci5wb3NpdGlvbi54K2kucG9pbnRBLngsci5wb3NpdGlvbi55K2kucG9pbnRBLnkpKTooby5iZWdpblBhdGgoKSxvLm1vdmVUbyhpLnBvaW50QS54LGkucG9pbnRBLnkpKSxzP28ubGluZVRvKHMucG9zaXRpb24ueCtpLnBvaW50Qi54LHMucG9zaXRpb24ueStpLnBvaW50Qi55KTpvLmxpbmVUbyhpLnBvaW50Qi54LGkucG9pbnRCLnkpLG8ubGluZVdpZHRoPWkucmVuZGVyLmxpbmVXaWR0aCxvLnN0cm9rZVN0eWxlPWkucmVuZGVyLnN0cm9rZVN0eWxlLG8uc3Ryb2tlKCl9fX0sbi5ib2R5U2hhZG93cz1mdW5jdGlvbihlLHQsbyl7Zm9yKHZhciBuPW8saT0oZS5lbmdpbmUsMCk7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07aWYoci5yZW5kZXIudmlzaWJsZSl7aWYoci5jaXJjbGVSYWRpdXMpbi5iZWdpblBhdGgoKSxuLmFyYyhyLnBvc2l0aW9uLngsci5wb3NpdGlvbi55LHIuY2lyY2xlUmFkaXVzLDAsMipNYXRoLlBJKSxuLmNsb3NlUGF0aCgpO2Vsc2V7bi5iZWdpblBhdGgoKSxuLm1vdmVUbyhyLnZlcnRpY2VzWzBdLngsci52ZXJ0aWNlc1swXS55KTtmb3IodmFyIHM9MTtzPHIudmVydGljZXMubGVuZ3RoO3MrKyluLmxpbmVUbyhyLnZlcnRpY2VzW3NdLngsci52ZXJ0aWNlc1tzXS55KTtuLmNsb3NlUGF0aCgpfXZhciBhPXIucG9zaXRpb24ueC0uNSplLm9wdGlvbnMud2lkdGgsbD1yLnBvc2l0aW9uLnktLjIqZS5vcHRpb25zLmhlaWdodCxjPU1hdGguYWJzKGEpK01hdGguYWJzKGwpO24uc2hhZG93Q29sb3I9XCJyZ2JhKDAsMCwwLDAuMTUpXCIsbi5zaGFkb3dPZmZzZXRYPS4wNSphLG4uc2hhZG93T2Zmc2V0WT0uMDUqbCxuLnNoYWRvd0JsdXI9MSsxMipNYXRoLm1pbigxLGMvMWUzKSxuLmZpbGwoKSxuLnNoYWRvd0NvbG9yPW51bGwsbi5zaGFkb3dPZmZzZXRYPW51bGwsbi5zaGFkb3dPZmZzZXRZPW51bGwsbi5zaGFkb3dCbHVyPW51bGx9fX0sbi5ib2RpZXM9ZnVuY3Rpb24oZSx0LG8pe1xudmFyIG4saSxyLHMsYT1vLGw9KGUuZW5naW5lLGUub3B0aW9ucyksYz1sLnNob3dJbnRlcm5hbEVkZ2VzfHwhbC53aXJlZnJhbWVzO2ZvcihyPTA7cjx0Lmxlbmd0aDtyKyspaWYobj10W3JdLG4ucmVuZGVyLnZpc2libGUpZm9yKHM9bi5wYXJ0cy5sZW5ndGg+MT8xOjA7czxuLnBhcnRzLmxlbmd0aDtzKyspaWYoaT1uLnBhcnRzW3NdLGkucmVuZGVyLnZpc2libGUpe2lmKGwuc2hvd1NsZWVwaW5nJiZuLmlzU2xlZXBpbmc/YS5nbG9iYWxBbHBoYT0uNSppLnJlbmRlci5vcGFjaXR5OjEhPT1pLnJlbmRlci5vcGFjaXR5JiYoYS5nbG9iYWxBbHBoYT1pLnJlbmRlci5vcGFjaXR5KSxpLnJlbmRlci5zcHJpdGUmJmkucmVuZGVyLnNwcml0ZS50ZXh0dXJlJiYhbC53aXJlZnJhbWVzKXt2YXIgZD1pLnJlbmRlci5zcHJpdGUscD11KGUsZC50ZXh0dXJlKTthLnRyYW5zbGF0ZShpLnBvc2l0aW9uLngsaS5wb3NpdGlvbi55KSxhLnJvdGF0ZShpLmFuZ2xlKSxhLmRyYXdJbWFnZShwLHAud2lkdGgqLWQueE9mZnNldCpkLnhTY2FsZSxwLmhlaWdodCotZC55T2Zmc2V0KmQueVNjYWxlLHAud2lkdGgqZC54U2NhbGUscC5oZWlnaHQqZC55U2NhbGUpLGEucm90YXRlKC1pLmFuZ2xlKSxhLnRyYW5zbGF0ZSgtaS5wb3NpdGlvbi54LC1pLnBvc2l0aW9uLnkpfWVsc2V7aWYoaS5jaXJjbGVSYWRpdXMpYS5iZWdpblBhdGgoKSxhLmFyYyhpLnBvc2l0aW9uLngsaS5wb3NpdGlvbi55LGkuY2lyY2xlUmFkaXVzLDAsMipNYXRoLlBJKTtlbHNle2EuYmVnaW5QYXRoKCksYS5tb3ZlVG8oaS52ZXJ0aWNlc1swXS54LGkudmVydGljZXNbMF0ueSk7Zm9yKHZhciBmPTE7ZjxpLnZlcnRpY2VzLmxlbmd0aDtmKyspIWkudmVydGljZXNbZi0xXS5pc0ludGVybmFsfHxjP2EubGluZVRvKGkudmVydGljZXNbZl0ueCxpLnZlcnRpY2VzW2ZdLnkpOmEubW92ZVRvKGkudmVydGljZXNbZl0ueCxpLnZlcnRpY2VzW2ZdLnkpLGkudmVydGljZXNbZl0uaXNJbnRlcm5hbCYmIWMmJmEubW92ZVRvKGkudmVydGljZXNbKGYrMSklaS52ZXJ0aWNlcy5sZW5ndGhdLngsaS52ZXJ0aWNlc1soZisxKSVpLnZlcnRpY2VzLmxlbmd0aF0ueSk7XG5hLmxpbmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KSxhLmNsb3NlUGF0aCgpfWwud2lyZWZyYW1lcz8oYS5saW5lV2lkdGg9MSxhLnN0cm9rZVN0eWxlPVwiI2JiYlwiKTooYS5maWxsU3R5bGU9aS5yZW5kZXIuZmlsbFN0eWxlLGEubGluZVdpZHRoPWkucmVuZGVyLmxpbmVXaWR0aCxhLnN0cm9rZVN0eWxlPWkucmVuZGVyLnN0cm9rZVN0eWxlLGEuZmlsbCgpKSxhLnN0cm9rZSgpfWEuZ2xvYmFsQWxwaGE9MX19LG4uYm9keVdpcmVmcmFtZXM9ZnVuY3Rpb24oZSx0LG8pe3ZhciBuLGkscixzLGEsbD1vLGM9ZS5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzO2ZvcihsLmJlZ2luUGF0aCgpLHI9MDtyPHQubGVuZ3RoO3IrKylpZihuPXRbcl0sbi5yZW5kZXIudmlzaWJsZSlmb3IoYT1uLnBhcnRzLmxlbmd0aD4xPzE6MDthPG4ucGFydHMubGVuZ3RoO2ErKyl7Zm9yKGk9bi5wYXJ0c1thXSxsLm1vdmVUbyhpLnZlcnRpY2VzWzBdLngsaS52ZXJ0aWNlc1swXS55KSxzPTE7czxpLnZlcnRpY2VzLmxlbmd0aDtzKyspIWkudmVydGljZXNbcy0xXS5pc0ludGVybmFsfHxjP2wubGluZVRvKGkudmVydGljZXNbc10ueCxpLnZlcnRpY2VzW3NdLnkpOmwubW92ZVRvKGkudmVydGljZXNbc10ueCxpLnZlcnRpY2VzW3NdLnkpLGkudmVydGljZXNbc10uaXNJbnRlcm5hbCYmIWMmJmwubW92ZVRvKGkudmVydGljZXNbKHMrMSklaS52ZXJ0aWNlcy5sZW5ndGhdLngsaS52ZXJ0aWNlc1socysxKSVpLnZlcnRpY2VzLmxlbmd0aF0ueSk7bC5saW5lVG8oaS52ZXJ0aWNlc1swXS54LGkudmVydGljZXNbMF0ueSl9bC5saW5lV2lkdGg9MSxsLnN0cm9rZVN0eWxlPVwiI2JiYlwiLGwuc3Ryb2tlKCl9LG4uYm9keUNvbnZleEh1bGxzPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbixpLHIscz1vO2ZvcihzLmJlZ2luUGF0aCgpLGk9MDtpPHQubGVuZ3RoO2krKylpZihuPXRbaV0sbi5yZW5kZXIudmlzaWJsZSYmMSE9PW4ucGFydHMubGVuZ3RoKXtmb3Iocy5tb3ZlVG8obi52ZXJ0aWNlc1swXS54LG4udmVydGljZXNbMF0ueSksXG5yPTE7cjxuLnZlcnRpY2VzLmxlbmd0aDtyKyspcy5saW5lVG8obi52ZXJ0aWNlc1tyXS54LG4udmVydGljZXNbcl0ueSk7cy5saW5lVG8obi52ZXJ0aWNlc1swXS54LG4udmVydGljZXNbMF0ueSl9cy5saW5lV2lkdGg9MSxzLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIscy5zdHJva2UoKX0sbi52ZXJ0ZXhOdW1iZXJzPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbixpLHIscz1vO2ZvcihuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBhPXRbbl0ucGFydHM7Zm9yKHI9YS5sZW5ndGg+MT8xOjA7cjxhLmxlbmd0aDtyKyspe3ZhciBsPWFbcl07Zm9yKGk9MDtpPGwudmVydGljZXMubGVuZ3RoO2krKylzLmZpbGxTdHlsZT1cInJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLHMuZmlsbFRleHQobitcIl9cIitpLGwucG9zaXRpb24ueCsuOCoobC52ZXJ0aWNlc1tpXS54LWwucG9zaXRpb24ueCksbC5wb3NpdGlvbi55Ky44KihsLnZlcnRpY2VzW2ldLnktbC5wb3NpdGlvbi55KSl9fX0sbi5tb3VzZVBvc2l0aW9uPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbj1vO24uZmlsbFN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjgpXCIsbi5maWxsVGV4dCh0LnBvc2l0aW9uLngrXCIgIFwiK3QucG9zaXRpb24ueSx0LnBvc2l0aW9uLngrNSx0LnBvc2l0aW9uLnktNSl9LG4uYm9keUJvdW5kcz1mdW5jdGlvbihlLHQsbyl7dmFyIG49byxpPShlLmVuZ2luZSxlLm9wdGlvbnMpO24uYmVnaW5QYXRoKCk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPXRbcl07aWYocy5yZW5kZXIudmlzaWJsZSlmb3IodmFyIGE9dFtyXS5wYXJ0cyxsPWEubGVuZ3RoPjE/MTowO2w8YS5sZW5ndGg7bCsrKXt2YXIgYz1hW2xdO24ucmVjdChjLmJvdW5kcy5taW4ueCxjLmJvdW5kcy5taW4ueSxjLmJvdW5kcy5tYXgueC1jLmJvdW5kcy5taW4ueCxjLmJvdW5kcy5tYXgueS1jLmJvdW5kcy5taW4ueSl9fWkud2lyZWZyYW1lcz9uLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMjU1LDI1NSwwLjA4KVwiOm4uc3Ryb2tlU3R5bGU9XCJyZ2JhKDAsMCwwLDAuMSlcIixcbm4ubGluZVdpZHRoPTEsbi5zdHJva2UoKX0sbi5ib2R5QXhlcz1mdW5jdGlvbihlLHQsbyl7dmFyIG4saSxyLHMsYT1vLGw9KGUuZW5naW5lLGUub3B0aW9ucyk7Zm9yKGEuYmVnaW5QYXRoKCksaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgYz10W2ldLGQ9Yy5wYXJ0cztpZihjLnJlbmRlci52aXNpYmxlKWlmKGwuc2hvd0F4ZXMpZm9yKHI9ZC5sZW5ndGg+MT8xOjA7cjxkLmxlbmd0aDtyKyspZm9yKG49ZFtyXSxzPTA7czxuLmF4ZXMubGVuZ3RoO3MrKyl7dmFyIHU9bi5heGVzW3NdO2EubW92ZVRvKG4ucG9zaXRpb24ueCxuLnBvc2l0aW9uLnkpLGEubGluZVRvKG4ucG9zaXRpb24ueCsyMCp1Lngsbi5wb3NpdGlvbi55KzIwKnUueSl9ZWxzZSBmb3Iocj1kLmxlbmd0aD4xPzE6MDtyPGQubGVuZ3RoO3IrKylmb3Iobj1kW3JdLHM9MDtzPG4uYXhlcy5sZW5ndGg7cysrKWEubW92ZVRvKG4ucG9zaXRpb24ueCxuLnBvc2l0aW9uLnkpLGEubGluZVRvKChuLnZlcnRpY2VzWzBdLngrbi52ZXJ0aWNlc1tuLnZlcnRpY2VzLmxlbmd0aC0xXS54KS8yLChuLnZlcnRpY2VzWzBdLnkrbi52ZXJ0aWNlc1tuLnZlcnRpY2VzLmxlbmd0aC0xXS55KS8yKX1sLndpcmVmcmFtZXM/YS5zdHJva2VTdHlsZT1cImluZGlhbnJlZFwiOihhLnN0cm9rZVN0eWxlPVwicmdiYSgwLDAsMCwwLjgpXCIsYS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJvdmVybGF5XCIpLGEubGluZVdpZHRoPTEsYS5zdHJva2UoKSxhLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1vdmVyXCJ9LG4uYm9keVBvc2l0aW9ucz1mdW5jdGlvbihlLHQsbyl7dmFyIG4saSxyLHMsYT1vLGw9KGUuZW5naW5lLGUub3B0aW9ucyk7Zm9yKGEuYmVnaW5QYXRoKCkscj0wO3I8dC5sZW5ndGg7cisrKWlmKG49dFtyXSxuLnJlbmRlci52aXNpYmxlKWZvcihzPTA7czxuLnBhcnRzLmxlbmd0aDtzKyspaT1uLnBhcnRzW3NdLGEuYXJjKGkucG9zaXRpb24ueCxpLnBvc2l0aW9uLnksMywwLDIqTWF0aC5QSSwhMSksYS5jbG9zZVBhdGgoKTtcbmZvcihsLndpcmVmcmFtZXM/YS5maWxsU3R5bGU9XCJpbmRpYW5yZWRcIjphLmZpbGxTdHlsZT1cInJnYmEoMCwwLDAsMC41KVwiLGEuZmlsbCgpLGEuYmVnaW5QYXRoKCkscj0wO3I8dC5sZW5ndGg7cisrKW49dFtyXSxuLnJlbmRlci52aXNpYmxlJiYoYS5hcmMobi5wb3NpdGlvblByZXYueCxuLnBvc2l0aW9uUHJldi55LDIsMCwyKk1hdGguUEksITEpLGEuY2xvc2VQYXRoKCkpO2EuZmlsbFN0eWxlPVwicmdiYSgyNTUsMTY1LDAsMC44KVwiLGEuZmlsbCgpfSxuLmJvZHlWZWxvY2l0eT1mdW5jdGlvbihlLHQsbyl7dmFyIG49bztuLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgcj10W2ldO3IucmVuZGVyLnZpc2libGUmJihuLm1vdmVUbyhyLnBvc2l0aW9uLngsci5wb3NpdGlvbi55KSxuLmxpbmVUbyhyLnBvc2l0aW9uLngrMiooci5wb3NpdGlvbi54LXIucG9zaXRpb25QcmV2LngpLHIucG9zaXRpb24ueSsyKihyLnBvc2l0aW9uLnktci5wb3NpdGlvblByZXYueSkpKX1uLmxpbmVXaWR0aD0zLG4uc3Ryb2tlU3R5bGU9XCJjb3JuZmxvd2VyYmx1ZVwiLG4uc3Ryb2tlKCl9LG4uYm9keUlkcz1mdW5jdGlvbihlLHQsbyl7dmFyIG4saSxyPW87Zm9yKG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dLnJlbmRlci52aXNpYmxlKXt2YXIgcz10W25dLnBhcnRzO2ZvcihpPXMubGVuZ3RoPjE/MTowO2k8cy5sZW5ndGg7aSsrKXt2YXIgYT1zW2ldO3IuZm9udD1cIjEycHggQXJpYWxcIixyLmZpbGxTdHlsZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiLHIuZmlsbFRleHQoYS5pZCxhLnBvc2l0aW9uLngrMTAsYS5wb3NpdGlvbi55LTEwKX19fSxuLmNvbGxpc2lvbnM9ZnVuY3Rpb24oZSx0LG8pe3ZhciBuLGkscixzLGE9byxsPWUub3B0aW9ucztmb3IoYS5iZWdpblBhdGgoKSxyPTA7cjx0Lmxlbmd0aDtyKyspaWYobj10W3JdLG4uaXNBY3RpdmUpZm9yKGk9bi5jb2xsaXNpb24scz0wO3M8bi5hY3RpdmVDb250YWN0cy5sZW5ndGg7cysrKXt2YXIgYz1uLmFjdGl2ZUNvbnRhY3RzW3NdLGQ9Yy52ZXJ0ZXg7XG5hLnJlY3QoZC54LTEuNSxkLnktMS41LDMuNSwzLjUpfWZvcihsLndpcmVmcmFtZXM/YS5maWxsU3R5bGU9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNylcIjphLmZpbGxTdHlsZT1cIm9yYW5nZVwiLGEuZmlsbCgpLGEuYmVnaW5QYXRoKCkscj0wO3I8dC5sZW5ndGg7cisrKWlmKG49dFtyXSxuLmlzQWN0aXZlJiYoaT1uLmNvbGxpc2lvbixuLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aD4wKSl7dmFyIHU9bi5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCxwPW4uYWN0aXZlQ29udGFjdHNbMF0udmVydGV4Lnk7Mj09PW4uYWN0aXZlQ29udGFjdHMubGVuZ3RoJiYodT0obi5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCtuLmFjdGl2ZUNvbnRhY3RzWzFdLnZlcnRleC54KS8yLHA9KG4uYWN0aXZlQ29udGFjdHNbMF0udmVydGV4Lnkrbi5hY3RpdmVDb250YWN0c1sxXS52ZXJ0ZXgueSkvMiksaS5ib2R5Qj09PWkuc3VwcG9ydHNbMF0uYm9keXx8aS5ib2R5QS5pc1N0YXRpYz09PSEwP2EubW92ZVRvKHUtOCppLm5vcm1hbC54LHAtOCppLm5vcm1hbC55KTphLm1vdmVUbyh1KzgqaS5ub3JtYWwueCxwKzgqaS5ub3JtYWwueSksYS5saW5lVG8odSxwKX1sLndpcmVmcmFtZXM/YS5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE2NSwwLDAuNylcIjphLnN0cm9rZVN0eWxlPVwib3JhbmdlXCIsYS5saW5lV2lkdGg9MSxhLnN0cm9rZSgpfSxuLnNlcGFyYXRpb25zPWZ1bmN0aW9uKGUsdCxvKXt2YXIgbixpLHIscyxhLGw9byxjPWUub3B0aW9ucztmb3IobC5iZWdpblBhdGgoKSxhPTA7YTx0Lmxlbmd0aDthKyspaWYobj10W2FdLG4uaXNBY3RpdmUpe2k9bi5jb2xsaXNpb24scj1pLmJvZHlBLHM9aS5ib2R5Qjt2YXIgZD0xO3MuaXNTdGF0aWN8fHIuaXNTdGF0aWN8fChkPS41KSxzLmlzU3RhdGljJiYoZD0wKSxsLm1vdmVUbyhzLnBvc2l0aW9uLngscy5wb3NpdGlvbi55KSxsLmxpbmVUbyhzLnBvc2l0aW9uLngtaS5wZW5ldHJhdGlvbi54KmQscy5wb3NpdGlvbi55LWkucGVuZXRyYXRpb24ueSpkKSxkPTEsXG5zLmlzU3RhdGljfHxyLmlzU3RhdGljfHwoZD0uNSksci5pc1N0YXRpYyYmKGQ9MCksbC5tb3ZlVG8oci5wb3NpdGlvbi54LHIucG9zaXRpb24ueSksbC5saW5lVG8oci5wb3NpdGlvbi54K2kucGVuZXRyYXRpb24ueCpkLHIucG9zaXRpb24ueStpLnBlbmV0cmF0aW9uLnkqZCl9Yy53aXJlZnJhbWVzP2wuc3Ryb2tlU3R5bGU9XCJyZ2JhKDI1NSwxNjUsMCwwLjUpXCI6bC5zdHJva2VTdHlsZT1cIm9yYW5nZVwiLGwuc3Ryb2tlKCl9LG4uZ3JpZD1mdW5jdGlvbihlLHQsbyl7dmFyIG49byxyPWUub3B0aW9ucztyLndpcmVmcmFtZXM/bi5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE4MCwwLDAuMSlcIjpuLnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMTgwLDAsMC41KVwiLG4uYmVnaW5QYXRoKCk7Zm9yKHZhciBzPWkua2V5cyh0LmJ1Y2tldHMpLGE9MDthPHMubGVuZ3RoO2ErKyl7dmFyIGw9c1thXTtpZighKHQuYnVja2V0c1tsXS5sZW5ndGg8Mikpe3ZhciBjPWwuc3BsaXQoXCIsXCIpO24ucmVjdCguNStwYXJzZUludChjWzBdLDEwKSp0LmJ1Y2tldFdpZHRoLC41K3BhcnNlSW50KGNbMV0sMTApKnQuYnVja2V0SGVpZ2h0LHQuYnVja2V0V2lkdGgsdC5idWNrZXRIZWlnaHQpfX1uLmxpbmVXaWR0aD0xLG4uc3Ryb2tlKCl9LG4uaW5zcGVjdG9yPWZ1bmN0aW9uKGUsdCl7dmFyIG8sbj0oZS5lbmdpbmUsZS5zZWxlY3RlZCksaT1lLnJlbmRlcixyPWkub3B0aW9ucztpZihyLmhhc0JvdW5kcyl7dmFyIHM9aS5ib3VuZHMubWF4LngtaS5ib3VuZHMubWluLngsYT1pLmJvdW5kcy5tYXgueS1pLmJvdW5kcy5taW4ueSxsPXMvaS5vcHRpb25zLndpZHRoLGM9YS9pLm9wdGlvbnMuaGVpZ2h0O3Quc2NhbGUoMS9sLDEvYyksdC50cmFuc2xhdGUoLWkuYm91bmRzLm1pbi54LC1pLmJvdW5kcy5taW4ueSl9Zm9yKHZhciBkPTA7ZDxuLmxlbmd0aDtkKyspe3ZhciB1PW5bZF0uZGF0YTtzd2l0Y2godC50cmFuc2xhdGUoLjUsLjUpLHQubGluZVdpZHRoPTEsdC5zdHJva2VTdHlsZT1cInJnYmEoMjU1LDE2NSwwLDAuOSlcIixcbnQuc2V0TGluZURhc2goWzEsMl0pLHUudHlwZSl7Y2FzZVwiYm9keVwiOm89dS5ib3VuZHMsdC5iZWdpblBhdGgoKSx0LnJlY3QoTWF0aC5mbG9vcihvLm1pbi54LTMpLE1hdGguZmxvb3Ioby5taW4ueS0zKSxNYXRoLmZsb29yKG8ubWF4Lngtby5taW4ueCs2KSxNYXRoLmZsb29yKG8ubWF4Lnktby5taW4ueSs2KSksdC5jbG9zZVBhdGgoKSx0LnN0cm9rZSgpO2JyZWFrO2Nhc2VcImNvbnN0cmFpbnRcIjp2YXIgcD11LnBvaW50QTt1LmJvZHlBJiYocD11LnBvaW50QiksdC5iZWdpblBhdGgoKSx0LmFyYyhwLngscC55LDEwLDAsMipNYXRoLlBJKSx0LmNsb3NlUGF0aCgpLHQuc3Ryb2tlKCl9dC5zZXRMaW5lRGFzaChbXSksdC50cmFuc2xhdGUoLS41LC0uNSl9bnVsbCE9PWUuc2VsZWN0U3RhcnQmJih0LnRyYW5zbGF0ZSguNSwuNSksdC5saW5lV2lkdGg9MSx0LnN0cm9rZVN0eWxlPVwicmdiYSgyNTUsMTY1LDAsMC42KVwiLHQuZmlsbFN0eWxlPVwicmdiYSgyNTUsMTY1LDAsMC4xKVwiLG89ZS5zZWxlY3RCb3VuZHMsdC5iZWdpblBhdGgoKSx0LnJlY3QoTWF0aC5mbG9vcihvLm1pbi54KSxNYXRoLmZsb29yKG8ubWluLnkpLE1hdGguZmxvb3Ioby5tYXgueC1vLm1pbi54KSxNYXRoLmZsb29yKG8ubWF4Lnktby5taW4ueSkpLHQuY2xvc2VQYXRoKCksdC5zdHJva2UoKSx0LmZpbGwoKSx0LnRyYW5zbGF0ZSgtLjUsLS41KSksci5oYXNCb3VuZHMmJnQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKX07dmFyIG89ZnVuY3Rpb24oZSx0KXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3JldHVybiBvLndpZHRoPWUsby5oZWlnaHQ9dCxvLm9uY29udGV4dG1lbnU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sby5vbnNlbGVjdHN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuITF9LG99LGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRDb250ZXh0KFwiMmRcIiksbz13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSxuPXQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxO1xucmV0dXJuIG8vbn0sdT1mdW5jdGlvbihlLHQpe3ZhciBvPWUudGV4dHVyZXNbdF07cmV0dXJuIG8/bzoobz1lLnRleHR1cmVzW3RdPW5ldyBJbWFnZSxvLnNyYz10LG8pfSxwPWZ1bmN0aW9uKGUsdCl7dmFyIG89dDsvKGpwZ3xnaWZ8cG5nKSQvLnRlc3QodCkmJihvPVwidXJsKFwiK3QrXCIpXCIpLGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmQ9byxlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZT1cImNvbnRhaW5cIixlLmN1cnJlbnRCYWNrZ3JvdW5kPXR9fSgpfSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuLi9jb2xsaXNpb24vR3JpZFwiOjYsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI0LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjZ9XSwzMDpbZnVuY3Rpb24oZSx0LG8pe3ZhciBuPXt9O3QuZXhwb3J0cz1uO3ZhciBpPWUoXCIuLi9ib2R5L0NvbXBvc2l0ZVwiKSxyPWUoXCIuLi9jb3JlL0NvbW1vblwiKTshZnVuY3Rpb24oKXt2YXIgZSx0O1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSl7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKHIubm93KCkpfSwxZTMvNjApfSx0PXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKSxuLmNyZWF0ZT1mdW5jdGlvbihlKXtyLmxvZyhcIlJlbmRlclBpeGkuY3JlYXRlOiBNYXR0ZXIuUmVuZGVyUGl4aSBpcyBkZXByZWNhdGVkIChzZWUgZG9jcylcIixcIndhcm5cIik7dmFyIHQ9e2NvbnRyb2xsZXI6bixlbmdpbmU6bnVsbCxlbGVtZW50Om51bGwsXG5mcmFtZVJlcXVlc3RJZDpudWxsLGNhbnZhczpudWxsLHJlbmRlcmVyOm51bGwsY29udGFpbmVyOm51bGwsc3ByaXRlQ29udGFpbmVyOm51bGwscGl4aU9wdGlvbnM6bnVsbCxvcHRpb25zOnt3aWR0aDo4MDAsaGVpZ2h0OjYwMCxiYWNrZ3JvdW5kOlwiI2ZhZmFmYVwiLHdpcmVmcmFtZUJhY2tncm91bmQ6XCIjMjIyXCIsaGFzQm91bmRzOiExLGVuYWJsZWQ6ITAsd2lyZWZyYW1lczohMCxzaG93U2xlZXBpbmc6ITAsc2hvd0RlYnVnOiExLHNob3dCcm9hZHBoYXNlOiExLHNob3dCb3VuZHM6ITEsc2hvd1ZlbG9jaXR5OiExLHNob3dDb2xsaXNpb25zOiExLHNob3dBeGVzOiExLHNob3dQb3NpdGlvbnM6ITEsc2hvd0FuZ2xlSW5kaWNhdG9yOiExLHNob3dJZHM6ITEsc2hvd1NoYWRvd3M6ITF9fSxvPXIuZXh0ZW5kKHQsZSksaT0hby5vcHRpb25zLndpcmVmcmFtZXMmJlwidHJhbnNwYXJlbnRcIj09PW8ub3B0aW9ucy5iYWNrZ3JvdW5kO3JldHVybiBvLnBpeGlPcHRpb25zPW8ucGl4aU9wdGlvbnN8fHt2aWV3Om8uY2FudmFzLHRyYW5zcGFyZW50OmksYW50aWFsaWFzOiEwLGJhY2tncm91bmRDb2xvcjplLmJhY2tncm91bmR9LG8ubW91c2U9ZS5tb3VzZSxvLmVuZ2luZT1lLmVuZ2luZSxvLnJlbmRlcmVyPW8ucmVuZGVyZXJ8fG5ldyBQSVhJLldlYkdMUmVuZGVyZXIoby5vcHRpb25zLndpZHRoLG8ub3B0aW9ucy5oZWlnaHQsby5waXhpT3B0aW9ucyksby5jb250YWluZXI9by5jb250YWluZXJ8fG5ldyBQSVhJLkNvbnRhaW5lcixvLnNwcml0ZUNvbnRhaW5lcj1vLnNwcml0ZUNvbnRhaW5lcnx8bmV3IFBJWEkuQ29udGFpbmVyLG8uY2FudmFzPW8uY2FudmFzfHxvLnJlbmRlcmVyLnZpZXcsby5ib3VuZHM9by5ib3VuZHN8fHttaW46e3g6MCx5OjB9LG1heDp7eDpvLm9wdGlvbnMud2lkdGgseTpvLm9wdGlvbnMuaGVpZ2h0fX0sby50ZXh0dXJlcz17fSxvLnNwcml0ZXM9e30sby5wcmltaXRpdmVzPXt9LG8uY29udGFpbmVyLmFkZENoaWxkKG8uc3ByaXRlQ29udGFpbmVyKSxyLmlzRWxlbWVudChvLmVsZW1lbnQpP28uZWxlbWVudC5hcHBlbmRDaGlsZChvLmNhbnZhcyk6ci5sb2coJ05vIFwicmVuZGVyLmVsZW1lbnRcIiBwYXNzZWQsIFwicmVuZGVyLmNhbnZhc1wiIHdhcyBub3QgaW5zZXJ0ZWQgaW50byBkb2N1bWVudC4nLFwid2FyblwiKSxcbm8uY2FudmFzLm9uY29udGV4dG1lbnU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sby5jYW52YXMub25zZWxlY3RzdGFydD1mdW5jdGlvbigpe3JldHVybiExfSxvfSxuLnJ1bj1mdW5jdGlvbih0KXshZnVuY3Rpb24gbyhpKXt0LmZyYW1lUmVxdWVzdElkPWUobyksbi53b3JsZCh0KX0oKX0sbi5zdG9wPWZ1bmN0aW9uKGUpe3QoZS5mcmFtZVJlcXVlc3RJZCl9LG4uY2xlYXI9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuY29udGFpbmVyLG89ZS5zcHJpdGVDb250YWluZXI7dC5jaGlsZHJlblswXTspdC5yZW1vdmVDaGlsZCh0LmNoaWxkcmVuWzBdKTtmb3IoO28uY2hpbGRyZW5bMF07KW8ucmVtb3ZlQ2hpbGQoby5jaGlsZHJlblswXSk7dmFyIG49ZS5zcHJpdGVzW1wiYmctMFwiXTtlLnRleHR1cmVzPXt9LGUuc3ByaXRlcz17fSxlLnByaW1pdGl2ZXM9e30sZS5zcHJpdGVzW1wiYmctMFwiXT1uLG4mJnQuYWRkQ2hpbGRBdChuLDApLGUuY29udGFpbmVyLmFkZENoaWxkKGUuc3ByaXRlQ29udGFpbmVyKSxlLmN1cnJlbnRCYWNrZ3JvdW5kPW51bGwsdC5zY2FsZS5zZXQoMSwxKSx0LnBvc2l0aW9uLnNldCgwLDApfSxuLnNldEJhY2tncm91bmQ9ZnVuY3Rpb24oZSx0KXtpZihlLmN1cnJlbnRCYWNrZ3JvdW5kIT09dCl7dmFyIG89dC5pbmRleE9mJiYtMSE9PXQuaW5kZXhPZihcIiNcIiksbj1lLnNwcml0ZXNbXCJiZy0wXCJdO2lmKG8pe3ZhciBpPXIuY29sb3JUb051bWJlcih0KTtlLnJlbmRlcmVyLmJhY2tncm91bmRDb2xvcj1pLG4mJmUuY29udGFpbmVyLnJlbW92ZUNoaWxkKG4pfWVsc2UgaWYoIW4pe3ZhciBzPWEoZSx0KTtuPWUuc3ByaXRlc1tcImJnLTBcIl09bmV3IFBJWEkuU3ByaXRlKHMpLG4ucG9zaXRpb24ueD0wLG4ucG9zaXRpb24ueT0wLGUuY29udGFpbmVyLmFkZENoaWxkQXQobiwwKX1lLmN1cnJlbnRCYWNrZ3JvdW5kPXR9fSxuLndvcmxkPWZ1bmN0aW9uKGUpe3ZhciB0LG89ZS5lbmdpbmUscj1vLndvcmxkLHM9ZS5yZW5kZXJlcixhPWUuY29udGFpbmVyLGw9ZS5vcHRpb25zLGM9aS5hbGxCb2RpZXMociksZD1pLmFsbENvbnN0cmFpbnRzKHIpLHU9W107XG5sLndpcmVmcmFtZXM/bi5zZXRCYWNrZ3JvdW5kKGUsbC53aXJlZnJhbWVCYWNrZ3JvdW5kKTpuLnNldEJhY2tncm91bmQoZSxsLmJhY2tncm91bmQpO3ZhciBwPWUuYm91bmRzLm1heC54LWUuYm91bmRzLm1pbi54LGY9ZS5ib3VuZHMubWF4LnktZS5ib3VuZHMubWluLnksdj1wL2Uub3B0aW9ucy53aWR0aCxtPWYvZS5vcHRpb25zLmhlaWdodDtpZihsLmhhc0JvdW5kcyl7Zm9yKHQ9MDt0PGMubGVuZ3RoO3QrKyl7dmFyIHk9Y1t0XTt5LnJlbmRlci5zcHJpdGUudmlzaWJsZT1Cb3VuZHMub3ZlcmxhcHMoeS5ib3VuZHMsZS5ib3VuZHMpfWZvcih0PTA7dDxkLmxlbmd0aDt0Kyspe3ZhciBnPWRbdF0seD1nLmJvZHlBLGg9Zy5ib2R5QixiPWcucG9pbnRBLHc9Zy5wb2ludEI7eCYmKGI9VmVjdG9yLmFkZCh4LnBvc2l0aW9uLGcucG9pbnRBKSksaCYmKHc9VmVjdG9yLmFkZChoLnBvc2l0aW9uLGcucG9pbnRCKSksYiYmdyYmKEJvdW5kcy5jb250YWlucyhlLmJvdW5kcyxiKXx8Qm91bmRzLmNvbnRhaW5zKGUuYm91bmRzLHcpKSYmdS5wdXNoKGcpfWEuc2NhbGUuc2V0KDEvdiwxL20pLGEucG9zaXRpb24uc2V0KC1lLmJvdW5kcy5taW4ueCooMS92KSwtZS5ib3VuZHMubWluLnkqKDEvbSkpfWVsc2UgdT1kO2Zvcih0PTA7dDxjLmxlbmd0aDt0Kyspbi5ib2R5KGUsY1t0XSk7Zm9yKHQ9MDt0PHUubGVuZ3RoO3QrKyluLmNvbnN0cmFpbnQoZSx1W3RdKTtzLnJlbmRlcihhKX0sbi5jb25zdHJhaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG89KGUuZW5naW5lLHQuYm9keUEpLG49dC5ib2R5QixpPXQucG9pbnRBLHM9dC5wb2ludEIsYT1lLmNvbnRhaW5lcixsPXQucmVuZGVyLGM9XCJjLVwiK3QuaWQsZD1lLnByaW1pdGl2ZXNbY107cmV0dXJuIGR8fChkPWUucHJpbWl0aXZlc1tjXT1uZXcgUElYSS5HcmFwaGljcyksbC52aXNpYmxlJiZ0LnBvaW50QSYmdC5wb2ludEI/KC0xPT09ci5pbmRleE9mKGEuY2hpbGRyZW4sZCkmJmEuYWRkQ2hpbGQoZCksZC5jbGVhcigpLGQuYmVnaW5GaWxsKDAsMCksXG5kLmxpbmVTdHlsZShsLmxpbmVXaWR0aCxyLmNvbG9yVG9OdW1iZXIobC5zdHJva2VTdHlsZSksMSksbz9kLm1vdmVUbyhvLnBvc2l0aW9uLngraS54LG8ucG9zaXRpb24ueStpLnkpOmQubW92ZVRvKGkueCxpLnkpLG4/ZC5saW5lVG8obi5wb3NpdGlvbi54K3MueCxuLnBvc2l0aW9uLnkrcy55KTpkLmxpbmVUbyhzLngscy55KSx2b2lkIGQuZW5kRmlsbCgpKTp2b2lkIGQuY2xlYXIoKX0sbi5ib2R5PWZ1bmN0aW9uKGUsdCl7dmFyIG49KGUuZW5naW5lLHQucmVuZGVyKTtpZihuLnZpc2libGUpaWYobi5zcHJpdGUmJm4uc3ByaXRlLnRleHR1cmUpe3ZhciBpPVwiYi1cIit0LmlkLGE9ZS5zcHJpdGVzW2ldLGw9ZS5zcHJpdGVDb250YWluZXI7YXx8KGE9ZS5zcHJpdGVzW2ldPW8oZSx0KSksLTE9PT1yLmluZGV4T2YobC5jaGlsZHJlbixhKSYmbC5hZGRDaGlsZChhKSxhLnBvc2l0aW9uLng9dC5wb3NpdGlvbi54LGEucG9zaXRpb24ueT10LnBvc2l0aW9uLnksYS5yb3RhdGlvbj10LmFuZ2xlLGEuc2NhbGUueD1uLnNwcml0ZS54U2NhbGV8fDEsYS5zY2FsZS55PW4uc3ByaXRlLnlTY2FsZXx8MX1lbHNle3ZhciBjPVwiYi1cIit0LmlkLGQ9ZS5wcmltaXRpdmVzW2NdLHU9ZS5jb250YWluZXI7ZHx8KGQ9ZS5wcmltaXRpdmVzW2NdPXMoZSx0KSxkLmluaXRpYWxBbmdsZT10LmFuZ2xlKSwtMT09PXIuaW5kZXhPZih1LmNoaWxkcmVuLGQpJiZ1LmFkZENoaWxkKGQpLGQucG9zaXRpb24ueD10LnBvc2l0aW9uLngsZC5wb3NpdGlvbi55PXQucG9zaXRpb24ueSxkLnJvdGF0aW9uPXQuYW5nbGUtZC5pbml0aWFsQW5nbGV9fTt2YXIgbz1mdW5jdGlvbihlLHQpe3ZhciBvPXQucmVuZGVyLG49by5zcHJpdGUudGV4dHVyZSxpPWEoZSxuKSxyPW5ldyBQSVhJLlNwcml0ZShpKTtyZXR1cm4gci5hbmNob3IueD10LnJlbmRlci5zcHJpdGUueE9mZnNldCxyLmFuY2hvci55PXQucmVuZGVyLnNwcml0ZS55T2Zmc2V0LHJ9LHM9ZnVuY3Rpb24oZSx0KXt2YXIgbyxuPXQucmVuZGVyLGk9ZS5vcHRpb25zLHM9bmV3IFBJWEkuR3JhcGhpY3MsYT1yLmNvbG9yVG9OdW1iZXIobi5maWxsU3R5bGUpLGw9ci5jb2xvclRvTnVtYmVyKG4uc3Ryb2tlU3R5bGUpLGM9ci5jb2xvclRvTnVtYmVyKG4uc3Ryb2tlU3R5bGUpLGQ9ci5jb2xvclRvTnVtYmVyKFwiI2JiYlwiKSx1PXIuY29sb3JUb051bWJlcihcIiNDRDVDNUNcIik7XG5zLmNsZWFyKCk7Zm9yKHZhciBwPXQucGFydHMubGVuZ3RoPjE/MTowO3A8dC5wYXJ0cy5sZW5ndGg7cCsrKXtvPXQucGFydHNbcF0saS53aXJlZnJhbWVzPyhzLmJlZ2luRmlsbCgwLDApLHMubGluZVN0eWxlKDEsZCwxKSk6KHMuYmVnaW5GaWxsKGEsMSkscy5saW5lU3R5bGUobi5saW5lV2lkdGgsbCwxKSkscy5tb3ZlVG8oby52ZXJ0aWNlc1swXS54LXQucG9zaXRpb24ueCxvLnZlcnRpY2VzWzBdLnktdC5wb3NpdGlvbi55KTtmb3IodmFyIGY9MTtmPG8udmVydGljZXMubGVuZ3RoO2YrKylzLmxpbmVUbyhvLnZlcnRpY2VzW2ZdLngtdC5wb3NpdGlvbi54LG8udmVydGljZXNbZl0ueS10LnBvc2l0aW9uLnkpO3MubGluZVRvKG8udmVydGljZXNbMF0ueC10LnBvc2l0aW9uLngsby52ZXJ0aWNlc1swXS55LXQucG9zaXRpb24ueSkscy5lbmRGaWxsKCksKGkuc2hvd0FuZ2xlSW5kaWNhdG9yfHxpLnNob3dBeGVzKSYmKHMuYmVnaW5GaWxsKDAsMCksaS53aXJlZnJhbWVzP3MubGluZVN0eWxlKDEsdSwxKTpzLmxpbmVTdHlsZSgxLGMpLHMubW92ZVRvKG8ucG9zaXRpb24ueC10LnBvc2l0aW9uLngsby5wb3NpdGlvbi55LXQucG9zaXRpb24ueSkscy5saW5lVG8oKG8udmVydGljZXNbMF0ueCtvLnZlcnRpY2VzW28udmVydGljZXMubGVuZ3RoLTFdLngpLzItdC5wb3NpdGlvbi54LChvLnZlcnRpY2VzWzBdLnkrby52ZXJ0aWNlc1tvLnZlcnRpY2VzLmxlbmd0aC0xXS55KS8yLXQucG9zaXRpb24ueSkscy5lbmRGaWxsKCkpfXJldHVybiBzfSxhPWZ1bmN0aW9uKGUsdCl7dmFyIG89ZS50ZXh0dXJlc1t0XTtyZXR1cm4gb3x8KG89ZS50ZXh0dXJlc1t0XT1QSVhJLlRleHR1cmUuZnJvbUltYWdlKHQpKSxvfX0oKX0se1wiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vY29yZS9Db21tb25cIjoxNH1dfSx7fSxbMjhdKSgyOCl9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NsaWVudC9hcHAvbGlicy9tYXR0ZXIubWluLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///415\n");

/***/ })

});